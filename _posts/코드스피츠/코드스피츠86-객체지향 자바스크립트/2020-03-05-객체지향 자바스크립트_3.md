---
title: ê°ì²´ì§€í–¥ ìžë°”ìŠ¤í¬ë¦½íŠ¸ 3íšŒì°¨(MVVM pattern ê°œì„ )
date: 2020-03-05
tags:
  - ì½”ë“œìŠ¤í”¼ì¸ 
  - ê°ì œì§€í–¥ ìžë°”ìŠ¤í¬ë¦½íŠ¸
keywords:
  - ê°ì²´ì§€í–¥
  - MVVM
---

ê³¼ì œ - ê°•ì˜ ë“¤ìœ¼ë©´ [ë³´ì™„]ì´ë¼ê³  í•œ ê²ƒë“¤ ì°¾ì•„ì„œ ìŠ¤í„°ë””í•´ì„œ ì°¾ì•„ ë„£ê¸°

# ëª©í‘œ 
* ì „ëžµì  íŒ¨í„´ ì ìš©
    - ê¸°ì¡´ binderê°€ ì½”ë“œë¡œ í™•ì • ë˜ì–´ ìžˆë‹¤. ì´ ë¶€ë¶„ì„ ì „ëžµì ìœ¼ë¡œ ë¹¼ë‚´ëŠ” ë°©ë²•ì„ ì‚´íŽ´ë³¸ë‹¤. 
    
* call -> Observation
    - Binder, ViewModel í†µì‹ ì„ ì´ì „ ê°•ì˜ ê¹Œì§€ callë¡œ í•´ê²°í•´ì“´ëŠ”ë° ì´ë²ˆì— Observationìœ¼ë¡œ í•´ê²°ì„ ì„¤ëª…í•©ë‹ˆë‹¤.  
    ê·¸ëž˜ì„œ ê²°ê³¼ì ìœ¼ë¡œ ëª¨ë¸ì´ ë³€í•˜ë©´ binderê°€ ìžë™ìœ¼ë¡œ viewë¥¼ë³€í•˜ê²Œ í•´ì¤€ëŠ”ê²Œ ëª©í‘œì´ë‹¤.   
        * [ì „ ê°•ì˜ observe -> callë¡œ ëŒ€ì²´](https://happyjy.github.io/ê°ì²´ì§€í–¥%20ìžë°”ìŠ¤í¬ë¦½íŠ¸_2/#observe---callë¡œ-ëŒ€ì²´)  



* ë°°ìš¸ keyword 
    - Strategy Pattern, Dependency Injection, 
    - Observer Pattern
    - Template method Pattern
    - Composite Pattern


# Strategy Pattern(Binder Classì— ì ìš©)
## ë°°ìš¸ ê²ƒ 
ìš°ë¦¬ëŠ” 5ê°€ì§€ ë‹¨ê³„ë¥¼ í†µí•´ì„œ ì „ëžµ íŒ¨í„´ê³¼, ì „ëžµíŒ¨í„´ì´ ì ìš©ë˜ê¸° ìœ„í•´ í•„ìˆ˜ ì¡°ê±´ì¸ ì•Œê³ ë¦¬ì¦˜ì˜ ì¼ë°˜í™”ë¥¼ ë°°ìš¸ê²ƒì´ë‹¤. 

1. Binder Classì—ì„œ Structure, strategyë¶€ë¶„ì„ ë‚˜ëˆˆë‹¤. 
2. strategyì˜ ê³µí†µì ì„ ì°¾ëŠ”ë‹¤. 
3. ì°¾ì€ strategyê°€ ì–´ë–»ê²Œ ìƒíƒœì™€ ê´€ê³„ë¥¼ ë§žëŠ”ì§€ í™•ì¸
    * ìƒíƒœ: ì´ì „ê°•ì˜ì—ì„œ ìµœì¢…ì½”ë“œ Binder class render methodì— ìžˆëŠ” ì½”ë“œ vm.styles, vm.attrivutes, vm.properties, vm.events
    * ê³µí†µëœ Strategy: k, v, el, viewmodel))  
4. 1,2,3ì— ë„ì¶œëœ í˜•ì„ ë§Œë“¤ê³  (Strategy, composite, template method pattern ì ìš©)
5. ë§Œë“  í˜•ì„ ê°€ì§€ê³  ì•Œê³ ë¦¬ì¦˜ì„ ë§Œë“¤ê²ƒ ìž…ë‹ˆë‹¤. (ì•Œê³ ë¦¬ì¦˜ ì¼ë°˜í™”)

* Strategy pattern
    - Composite pattern: Binder classì—ì„œ Stratege ë¶€ë¶„ì„ ë½‘ì•„ë‚´ëŠ” 
    - Compositioní•˜ëŠ” ê³¼ì •ì—ì„œ ì•„ëž˜ ê°œë… 
        * dependency, dependency injection 
        * Template method pattern
* ì•Œê³ ë¦¬ì¦˜ì˜ ì¼ë°˜í™” 
    - Strtegy Patternì„ í†µí•´ì„œ Binder Classë¥¼ ìˆ˜ì •í•œë‹¤(addProcess methodì¶”ê°€, render methodìˆ˜ì •)

## Strategy Pattern ì •ì˜
* ì–´ë–¤ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ì§€ì‹ì ì¸ ë¶€ë¶„, ë„ë©”ì¸, ì•Œê³ ë¦¬ì¦˜ì„ êµì²´í•˜ë©´ì„œ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìžˆë‹¤. 

## Binder classì— Strategy ì ìš© ì¤€ë¹„
> `Binder class`ì˜ `Strategy`ë¶€ë¶„ì„ ì™¸ì œí™” ì‹œì¼œ`Processor class`ì¸ìŠ¤í„´ìŠ¤ ìœ„ìž„ì„ ë°›ì•„ì„œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ ê³¼ì •ì„ ì„¤ëª…í•  ê²ƒìž…ë‹ˆë‹¤.
> Binder classëŠ” Structure&control, Strategyë¶€ë¶„ìœ¼ë¡œ ë‚˜ë‰˜ì–´ ìžˆë‹¤. ì•„ëž˜ë¥´ í™•ì¸í•´ë³´ìž 

### Binder classì˜ êµ¬ì¡°ë¶€ë¶„ í™•ì¸
![Structure & control](./3íšŒ/1.Strategy_Structure&Control.png) 

### Binder classì˜ ì „ëžµ ë¶€ë¶„ í™•ì¸
* ì „ëžµë¶€ë¶„: íŠ¹ì • ë„ë©”ì¸(ì•Œê³ ë¦¬ì¦˜,ì§€ì‹)ì„ í•´ê²°í•˜ê¸° ìœ„í•œ ì „ëžµì ì¸ ë¶€ë¶„ 
![Strategy](./3íšŒ/2.Strategy_Strategy.png)

* Binder class ì „ëžµ ë¶€ë¶„ codeë¥¼ Objectë¡œ ë³€ê²½í•´ì•¼í•œë‹¤.
    - codeë¥¼ Obejctë¡œ ë³€ê²½í•˜ëŠ” ìž‘ì—…ì„ Compositionì´ë¼ê³ í•˜ë©° ë°”ë¡œì•„ëž˜ ì„¤ëª…ì´ ì‹œìž‘í•©ë‹ˆë‹¤.
![Code->Object](./3íšŒ/3.Strategy_CodeToObject.png)

## Compositionì— ëŒ€í•´ì„œ 
> * Binderì—ì„œ strategy(algorithm, knowlege, domain) codeë¥¼ ë½‘ì•„ë‚´ Objectë¡œ ë³€ê²½ìœ¼ë¡œ ì¸í„°íŽ˜ì´ë¥¼ ì •ì˜í•´ ì£¼ìž… ë°›ëŠ” ë¶€ë¶„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìžˆë„ë¡ ë³€ê²½í•˜ëŠ” ìž‘ì—… 
> * Depency Injection & Composition ê´€ê³„
>   - Compositionìž‘ì—…ìœ¼ë¡œ Binder classëŠ” dependencyê°€ ìƒê¸°ê³  ì™¸ë¶€ì—ì„œ Strategyë¶€ë¶„ì„ ì£¼ìž… ë°›ìœ¼ë©´ì„œ Depency Injectionì´ ì¼ì–´ë‚œë‹¤. 

* ê°ì²´ ì§€í–¥ì—ì„œëŠ” compositionì„ ì‚¬ìš©í•´ì„œ í•´ê²°í•œë‹¤.
compositionì´ëž€ **codeë¥¼ objectë¡œ ë°”ê¾¸ëŠ”ê²ƒì´ë‹¤**.
ê·¸ëŸ°ë° codeë¥¼ ê³ ì¹˜ë©´ ì˜ì¡´í•˜ê³  ìžˆëŠ” ë¶€ë¶„ì„ í…ŒìŠ¤íŠ¸ë¥¼ ë‹¤ì‹œ í•´ì•¼í•œë‹¤.
ê·¸ëž˜ì„œ **codeë¥¼ ì•ˆë°”ê¾¸ê³ ì„œ objectë¡œ ë°”ê¾¸ê³  ì‹¶ë‹¤.(ì™œëƒí•˜ë©´ ë³€í™”ê°€ ìžˆì„ë•Œ ë§ˆë‹¤ codeë¥¼ ë³€ê²½í•´ì•¼ í•˜ê¸°ë•Œë¬¸)**
ì „ëžµì„ ë„ì¶œí•˜ëŠ”ë° ì„±ê³µí–ˆìœ¼ë©´ codeì—ì„œ strategyë¶€ë¶„ì´ structureì™€ ì–´ë–»ê²Œ ê´€ê³„ë¥¼ ë§ºëŠ”ì§€ ìž˜ í™•ì¸í•´ë³´ê³  ê·¸ë¦¬ê³ ë‚˜ì„œ codeë¶€ë¶„ì„ objectë¡œ ë³€ê²½í•´ì•¼ í•œë‹¤.
í•˜ì§€ë§Œ ìž„ì˜ì˜ ê°ì²´ë¡œ ë³€ê²½í•˜ë©´ ë³€ê²½í•˜ë ¤ëŠ” codeì™€ ì¼ë°˜í™” ê´€ê³„ë¥¼ ë§ºì„ ìˆ˜ ì—†ë‹¤. 
ê·¸ëž˜ì„œ **ìš°ë¦¬ëŠ” ê°ì²´ë¥¼ ë„ì¶œí• ë–„ interfaceë‚˜ classë¡œ typeìœ¼ë¡œ ë…¸ì¶œ**í•´ì•¼ í•œë‹¤. 
ì™œëƒí•˜ë©´ typeì„ ì •í•´ì•¼ì§€ë§Œ codeê°€ ì–´ë–¤ì‹ì˜ ê°ì²´ì¸ì§€ë¥¼ ì•Œì•„ì•¼ ë³€ê²½í–ˆì„ë•Œ ì ìš©í•  ìˆ˜ ìžˆê¸° ë•Œë¬¸ì´ë‹¤. 
        
### Dependencyê°€ ìƒê¸°ëŠ” ì´ìœ  
* ì½”ë“œë¥¼ ê°ì²´ë¡œ ë³€ê²½í–ˆê¸°ë•Œë¬¸ 
* ì½”ë“œ ëŒ€ì‹ ì— typeì„ ì •ì˜í•´ì„œ ê°ì²´ë¥¼ ë°›ì•„ ë“¤ì´ë©´ ê¸°ì¡´ì½”ë“œì—ëŠ” ì˜ì¡´ì´ ì—†ì—ˆëŠ”ë° ê°ì²´ë¥¼ ì•Œì•„ì•¼ Binderë¥¼ ì§„í–‰í•  ìˆ˜ ìžˆë‹¤.  
ê·¸ëž˜ì„œ ì½”ë“œë¥¼ ì™¸ë¶€ê°ì²´ compositionìœ¼ë¡œ ë°”ê¿€ ê²ƒì´ë‹¤. ê·¸ëŸ¬ë©´ ì™¸ë¶€ì—ì„œ ê³µê¸‰ë˜ëŠ” ê°ì²´ë¥¼ ì•Œì•„ì•¼ Binderê°€ ìž‘ë™í•  ìˆ˜ ìžˆë‹¤.(ê·¸ëž˜ì„œ Strategy ë¶€ë¶„ì— ëŒ€í•´ì„œ ì˜ì¡´ì„±ì´ ìƒê¸´ë‹¤ )
* ê°ì²´ì§€í–¥ì—ì„œ Dependencyê°€ ìƒê¸°ëŠ” ì´ìœ ê°€ ë­˜ê¹Œ? 
    - ìœ„ìž„í–ˆê¸°ë•Œë¬¸ì´ ì•„ë‹ˆë‹¤! Strategyë¥¼ ì™¸ë¶€ ê°ì²´ì— ì˜í•´ì„œ í•´ê²°í•˜ê³  ì‹¶ë‹¤. ì´ë ‡ê²Œ í•˜ê³  ì‹¶ì€ ì´ìœ ëŠ” ë³€í™”ê°€ ìžˆì„ë•Œ ë§ˆë‹¤ codeë¥¼ ë³€ê²½í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ê·¸ëž˜ì„œ codeë¥¼ objectë¡œ ë°”ê¿”ì£¼ë©´ ë°”ê¿”ì¤€ objectì— ëŒ€í•´ì„œ ì˜ì¡´ì„±ì´ ìƒê¸°ëŠ” ê²ƒ ìž…ë‹ˆë‹¤. ì´ë ‡ê²Œ BinderëŠ” Binder strategyì™€ ì˜ì¡´ê´‘ê³„ê°€ ìƒì„±ì´ ëœë‹¤.

### DI(Dependency Injection)
* ì˜ì¡´ì„±ì´ ìƒê²¼ì„ë•Œ ë‚´ë¶€ì—ì„œ ì˜ì¡´ì„±ì´ ìžˆëŠ” sub Typeì„ ë§Œë“¤ì–´ ë‚´ëŠ” ê²½ìš°ê°€ ìžˆê³  ê³µê¸‰ë°›ëŠ” ê²½ìš°ê°€ ìžˆëŠ”ë° ë‚´ë¶€ì—ì„œ ë§Œë“¤ë©´ ë‹¤ì‹œ í•˜ë“œì½”ë”©ì„ í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— **ì™¸ë¶€ì—ì„œ ê³µê¸‰**ë°›ëŠ” ê²ƒì„ ë§í•œë‹¤.(ê·¸ëž˜ì•¼ ë‚´ë¶€ì—ëŠ” typeì— ëŒ€í•œ ì˜ì¡´ë§Œ ìžˆê³  íŠ¹ì • ê°ì²´ì—ëŒ€í•œ ì˜ì¡´ì„±ì„ ì—†ì•¨ ìˆ˜ ìžˆë‹¤.) 

### ì •ë¦¬
> Binderì˜ Strategy ë¶€ë¶„ì„ Composite patternìœ¼ë¡œ ë³€ê²½ì˜ ê²°ë¡  
* **Composition(ì½”ë“œë¥¼ ê°ì²´ë¡œ ë¹¼ë‚´ëŠ” ìˆœê°„)ì„ í•˜ë©´ `Dependency`,`Dependency Injection`ì´ ìƒê¸´ë‹¤.**
* `Dependency`ê°€ ìƒê¸°ëŠ” ì´ìœ ëŠ” ì½”ë“œë¥¼ ê°ì²´ë¡œ ë³€ê²½í–ˆê¸° ë•Œë¬¸ 
    - ê°ì²´ì— ëŒ€í•œ ì˜ì¡´ì„±ì„ ë‚´ë¶€ì—ì„œ ìƒì„±í•´ë²„ë¦¬ë©´ dependencyë§Œ ìƒê¸´ë‹¤. ì´ëŸ¬ë©´ ë‹¤ì‹œ ì½”ë“œë¥¼ ê±´ë“œë ¤ì•¼ í•´ì„œ ì™¸ë¶€ì—ì„œ ê³µê¸‰(`Dependency Injection`)ë°›ì•„ì•¼ì§€ë©´ ê°ì²´ë¥¼ ëº€ì´ìœ ê°€ ìƒê¸´ë‹¤.  


## Binder Classì— Composition ì ìš© ê³¼ì •
![Processor Class & Tempalte Method](./3íšŒ/4.ProcessorClass_TempalteMethod.png) 
1. ì—°ì—­ì  ì¶”ë¦¬(ë‹¤ì–‘í•œ í˜„ìƒìœ¼ë¡œ ë¶€í„° ì›ë¦¬ê°€ ë˜ëŠ” ì¶”ìƒí™”ë¥¼ ë„ì¶œ)ë¥¼ í†µí•´ì„œ strategyë¡œ ë¶€í„° ê³µí†µì ì„ ì´ëŒì–´ë‚¸ë‹¤. 
    - ì—°ì—­ì  ì¶”ë¦¬ë¥¼ í†µí•´ ë„ì¶œí•œ ê²°ê³¼ë¬¼: viewmodel, el, k, v
2. ë„ì¶œí•œ ê²°ê³¼ë¬¼ì„ í†µí•´ì„œ Processor Class ìƒì„±
3. ìƒì„ í•œ Processort ClassëŠ” Template Method Pattenrì„ ê°€ì§€ê³  ìžˆë‹¤.

### Template method Pattern(Processor Class)
> * ìžì‹ ì´ í•´ì•¼í• ì¼ì„ í•˜ê³  Hook methodì— ìœ„ìž„ì„ í†µí•´ì„œ ë‚˜ë¨¸ì§€ ì¼ì„ ì²˜ë¦¬í•œë‹¤.   
> * ì™¸ë¶€ì—ì„œ Processorí´ëž˜ìŠ¤ _processë¥¼ ë°”ë¡œ í˜¸ì¶œí•˜ë©´ throwê±¸ë¦°ë‹¤.  
    - ê·¸ëž˜ì„œ **Proccessor í´ëž˜ìŠ¤ë¥¼ í™•ìž¥(ìƒì†)í•œ í´ëž˜ìŠ¤ì— _processë¥¼ ìž¬ì •ì˜(overriding)í•œ ê³³ì—ì„œ ì²˜ë¦¬**í•˜ë„ë¡ ì˜ë„í•´ì•¼ í•œë‹¤. 
* ë¶€ëª¨ì™€ ìžì‹ì‚¬ì´ì— Composition ì¼ì–´ë‚œë‹¤. 
    - ì „ëžµì„ ìœ„ìž„ í–ˆëŠ”ë° ì™¸ë¶€ì—ì„œ ì£¼ìž… ë°›ì•„ ìœ„ìž„í•œê²ƒì´ ì•„ë‹ˆë¼ ìƒì† ë°›ì€ ê°ì²´ì—ê²Œ ìœ„ìž„í–ˆë‹¤. 
    - ê·¸ëž˜ì„œ ìš°ë¦¬ê°€ DIë¥¼ ë‘ê°€ì§€ ë°©í–¥ìœ¼ë¡œ ìœ„ìž„í•  ìˆ˜ ìžˆë‹¤. 
        1. ì™¸ë¶€ì—ì„œ ì£¼ìž…
        2. ìžì‹ì—ì„œ ì£¼ìž… 
* process method
    - ì™¸ë¶€ì—ì„œëŠ” processê°€ template methodë‹¤. 
    - ë‚´ë¶€ì—ì„œëŠ” processê°€ ì²˜ë¦¬í• ë•ŒëŠ” ë‚´ë¶€ì—ì„œ ì„ ì–¸í•œ ë©”ì†Œë“œ(_process)ì— ì˜ì¡´ë˜ì–´ ìžˆë‹¤. 
* _process method
    -  Hook mehtodë¼ê³  í•œë‹¤.
* [ë³´ì™„]ê°ì²´ì§€í–¥ ì±…ì—ì„œ í…œí”Œë¦¿ ë©”ì†Œë“œ ë¶€ë¶„ ì •ë¦¬í•´ì„œ ì¶”ê°€í•˜ê¸° 



## Binder classì—ì„œ Processor class ì •ë¦¬
> Binder classì—ì„œ strategy pattern, composition patternì„ í†µí•´ì„œ Processor classë¥¼ ìƒì„±í•˜ê³   
> Processorì— ì—¬ëŸ¬ ì „ëžµì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œ Template Method patternì„ ì ìš©  
> ì•„ëž˜ì—ì„œ Template Method patternì„ ì ìš©í•˜ê¸° ìœ„í•´ì„œ Processor Classë¥¼ ìƒì†í•œê²ƒì„ ì„¤ëª…í•©ë‹ˆë‹¤.

* Binder classì˜ Strategyë¶€ë¶„ì€ Processor class ì¸ìŠ¤í„´ìŠ¤ ìœ„ìž„ì„ ë°›ì•„ì„œ ì²˜ë¦¬í•˜ë ¤ê³ í•œë‹¤. 
* Binder classëŠ” compositionì€ Processor classë¥¼ ì†Œìœ ë¥¼ í†µí•´ì„œ(Processor classë¥¼ Dependency Injection)ì„ í†µí•´ì„œ í•´ê²°í•˜ë ¤ê³  ìžˆê³  ì´ë¥¼ ì²˜ë¦¬í•´ì£¼ëŠ” 
* Processor classì—ì„œëŠ” processë§ˆë‹¤ ë‹¤ì–‘í•œ ì²˜ë¦¬ ë°©ë²•ì„ Template Methodë°©ë²•ì„ í†µí•´ì„œ í•´ê²° 



## Processor Classë¥¼ ìƒì† ë°›ì€ Hook Method 
![Processor Class & Hook Method](./3íšŒ/5.Processor_HookMethod.png) 
* ì „ëžµì´ ì–´ë–¤ structureì™€ ê´€ë ¨ì´ ë˜ì–´ ìžˆëŠ”ì§€ ë‚´ìš©ì´ ë¶€ì¡±í•˜ë‹¤.
    * ê·¸ëž˜ì„œ Processortì—ì„œ ë°›ì„ë§Œí•œ ížŒíŠ¸ëŠ” vmì˜ key Stringê°’(viewmodelì— ì •ì˜)ìœ¼ë¡œ ì¶©ë¶„í•˜ë‹¤.
* Processorë¥¼ ìƒì†ë°›ì€ í´ëž˜ìŠ¤ì— _processë¥¼ overrideí•´ì„œ ë” ì´ìƒ throwë¥¼ ë˜ì§€ì§€ ì•Šê³  el.styleì— kê°’ì˜ í‚¤ì— vë¥¼ ì„¸íŒ… 
    - Binder class renderëŠ” viewë¥¼ ì‹¤ì œë¡œ ìˆ˜ì •í• ë•Œ ì‚¬ìš©ë˜ëŠ” ì½”ë“œ
    - ì—¬ê¸°ì„œ k, vëŠ” viewmodelì—ì„œ ë°›ì€ key, valueê°’ì´ë‹¤. 
* ì˜ˆë¥¼ ë“¤ì–´ ì²«ë²ˆì§¸ el.styleê°€ ìžˆëŠ” ì½”ë“œëŠ” cat(=category)ëŠ” Stylesë¡œ ì •ì˜í–ˆë‹¤.
* ìµëª…ìƒì†ëœ í´ëž˜ìŠ¤ì˜ ìž¥ì : ë§Œë“  ì¸ìŠ¤í„´ìŠ¤ë¥¼ í•œë²ˆë§Œ ë§Œë“¤ì–´ í•œë²ˆë§Œ ì‚¬ìš©í•˜ê²Œí•´ ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ í•œë‹¤. 
* ìš°ë¦¬ëŠ” ì´ë ‡ê²Œ elì— style, property, attribute, eventë¥¼ ì„¤ì •í•  ìˆ˜ ìžˆëŠ” ì „ëžµ 4ê°œë¥¼ ë§Œë“¤ì—ˆë‹¤. 
    - 4ê°œ ì „ëžµ ì´ì™¸ì— ì˜ˆë¥¼ë“¤ì–´ lazy loader, scroll injectorë“±ì˜ ê¸°ëŠ¥ì„ ë„£ì„ ìˆ˜ ìžˆê²Œ ëë‹¤.  
* ì´ë ‡ê²Œ Processorë¥¼ ìƒì†ë°›ì•„ ë§Œì€ ì¸ìŠ¤í„´ìŠ¤ëŠ” ê°ê¸° ë‹¤ë¥¸ ê°ì²´ì´ì§€ë§Œ í•˜ë‚˜ ì˜ Processor typeìœ¼ë¡œ ì¸ì‹í•˜ê²Œ ëœë‹¤.  


### ê°ì²´ ë§ì„ êµ¬ì„±í•˜ëŠ” 3ìš”ì†Œ
* ê°ì²´í–¥ì€ ê°ì²´ë§ì— ì˜í•´ì„œ ë¬¸ì œë¥¼ í•´ê²°
* ì–´ë–¤ ê°ì²´ê°€ ë‹¤ë¥¸ ê°ì²´ë¥¼ 'í•„ë“œ'ìˆ˜ì¤€, 'ë©”ì†Œë“œ'ìˆ˜ì¤€, 'ìžì‹'ìˆ˜ì¤€ìœ¼ë¡œ ì•ˆë‹¤. 


## Binder class ë³€ê²½ 
> Binderì—ì„œ strategy ë¶€ë¶„ì„ ê³µê¸‰ ë°›ê¸° ìœ„í•´ì„œ ë§Œë“  Process classë¥¼ ìƒì„±/ ìƒì† ë°›ì€ í´ëž˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ê¹Œì§€ ë§Œë“¤ì–´ ë´¤ìœ¼ë‹ˆ ì™¸ë¶€ì—ì„œ Strategyë¥¼ ì£¼ìž… ë°›ê¸°ì— ì£¼ìž…ë°›ëŠ” Binderë¥¼ ìˆ˜ì •í•´ë³´ìž 

![Processor Class & Hook Method](./3íšŒ/6.BinderClass_modification.png) 
* #processors ì„¤ëª…

    - setìœ¼ë¡œ ì•ˆë§Œë“¤ê³  Arrayë¡œ ë§Œë“  ì´ìœ  
    - í•œê°œê°œì˜ categoryë‹¹ í•œê°œì˜ ê°’ë§Œ ê°–ê¸° ìœ„í•´ì„œ(ì œì¼ ë§ˆì§€ë§‰ì— ë“¤ì–´ ì˜¨ê²ƒë§Œ ë®ì–´ ì“´ë‹¤)
* ì•„ëž˜ ì½”ë“œ ì„¤ëª…
    - ì•„ëž˜ ì£¼ì„ ì„¤ëª…1, ì„¤ëª…2 ì°¸ê³  
    - pk: Processorì˜ catetory(cat)   
```js
    //# ì„¤ëª…1: ìžë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” single thread machineì´ê¸° ë•Œë¬¸ì— render methodê°€ ëŒë•Œ ê°‘ìžê¸° addProcessorê°€ ë™ìž‘í•  ìˆ˜ ì—†ë‹¤.
    const processors = Object.entries(this.#processors);
    this.#item.forEach(item => {
        const vm = type(viewmodel[item.viewmodel], ViewModel);
        const el = item.el;
        //# ì„¤ëª…2
        /*
            # processor value 
            : Binder Class addProcessorì— ì˜í•´ì„œ ìƒì„±ëœ #processors value
                {
                    styles: {category: "styles"}, 
                    attribute: {category:"attribtues"},
                    properties: {category:"properties"},
                    events: {category: "events"}
                }

            # vm value: ViewModel instance
            : Binder Class renderì— ì˜í•´ì„œ ë°›ì€ value
                : videModel Instacneì— ì•„ëž˜ keyê°’ì´ ìžˆë‹¤.
                : ê·¸ëž˜ì„œ vm[pk]ê°€ ì„±ë¦½ ê°€ëŠ¥
                instance.styles
                instance.attribute
                instance.properties
                instance.events                
            
            # processor.process()
            : processor ì¸ìŠ¤í„´ìŠ¤ëŠ” Process classë¥¼ ìƒì†ë°›ì•„ì„œ ìƒì„±

        */
        processors.forEach(([pk, processor]) => {
            Object.entries(vm[pk]).forEach(([k,v])=>{
                processor.process(vm, el, k, v);    //interfaceì— êµí™˜í•˜ëŠ” ìž‘ì—… 
            });
        });
    });
```

### ì•Œê³ ë¦¬ì¦˜ì˜ ì¼ë°˜í™” 
* êµ¬ì¡°ë¶€ë¶„ì„ ë‚¨ê¸°ê³  Strategyì— í•´ë‹¹í•˜ëŠ” codeë¥¼ objectë¥¼ typeìœ¼ë¡œ ë¹¼ëƒˆë‹¤. 
* ê·¸ë¦¬ê³  ë¹¼ë‚¸ Objectë¥¼ DIë¥¼ í•œë‹¤. 
* ê·¸ë¦¬ê³  ë°›ì€ Objctê¸°ì¤€ìœ¼ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ë°”ê¾¸ëŠ”ê²ƒì„ ë§í•œë‹¤.
* **ì•Œê³ ë¦¬ì¦˜ì˜ ì¼ë°˜í™”ê°€ ì–´ë µê¸°ë•Œë¬¸ì— ì „ëžµíŒ¨í„´ì„ ì‚¬ìš©í•˜ê¸° ì–´ë µë‹¤**
    - ì•ˆì •í™” ì‹œí‚¤ë ¤ë©´ Process classì— ê¸°ëŠ¥ì´ ì ì€ê²Œ ì¢‹ë‹¤. 
    - ê·¸ëž˜ì•¼ Procssorë¥¼ ì˜ì¡´í•˜ê³  ìžˆëŠ” Binderë„ ì½”ë“œê°€ ì•ˆ ë³€í•˜ë‹ˆê¹Œ. 
    - ê·¸ëž˜ì„œ Binderì½”ë“œë¥¼ ì§œê¸° ì–´ë µë‹¤. 
    - ì´ë ‡ê²Œ ì•ˆì •í™” ë˜ì–´ ìžˆëŠ” ì½”ë“œëŠ” **ì•½ì†í•˜ê³  ìžˆëŠ” protocol ë‚´ìš©ì´ ì ë‹¤.** 
    - ì ì€ë°ë„ ë˜‘ê°™ì€ ì•Œê³ ë¦¬ì¦˜ì„ ìž‘ì„±í•˜ëŠ” ê²ƒì´ ì–´ë µë‹¤. 
    - **ê·¸ë¶„ì´ processorsë¥¼ forEach ëŒë¦¬ëŠ” ë¶€ë¶„ì´ë‹¤.**

 ## binderì— addProcessort ì¶”ê°€
 > Binder classê°€ ì „ëžµ íŒ¨í„´ìœ¼ë¡œ ë°”ë€œìœ¼ë¡œ addProcessorë¥¼ ì¶”ê°€í•´ ì „ëžµì„ ì¶”ê°€í•˜ëŠ” ë¡œì§ì¹˜ ì¶”ê°€ ëë‹¤.
 
 ![binderInstane_modification](./3íšŒ/7.BinderInstance_modification.png) 

 * Binderê°€ Processorë¥¼ Dependencyí•œë‹¤. 
    - Processorê°€ ë³€ê²½ë˜ë©´ Binderê°€ ë³€ê²½ëœë‹¤.
    - ì˜ì¡´ì„±ì€ í•œë°©í–¥ìœ¼ë¡œë§Œ ë˜ì–´ì•¼í•œë‹¤. 
* Dependencyê°€ ìƒê¸°ë©´ Dependency Injectionì´ ìƒê¸´ë‹¤. 
    - codeë¥¼ Objectë¡œ typeìœ¼ë¡œ ë¹¼ë‚´ë©´ Dependencyê°€ ìƒê¸°ê³  Dependency Injectionì´ ìƒê¸´ë‹¤.  

 

* ì°¸ê³  
(ì œë¡œì´ˆ ì „ëžµíŒ¨í„´)[https://www.zerocho.com/category/JavaScript/post/580f17ef77023c0015ee9688]

# Observation Pattern
![binderInstane_modification](./3íšŒ/8.ObserverPatternInMVVM.png) 
* ì „ ê°•ì˜ì—ì„œ binderëŒ€ì‹ ì— callì„ ì‚¬ìš©í–ˆë‹¤. ì´ë²ˆ ì‹œê°„ì—ëŠ” Observer Patternì„ ì ìš©í•  ê²ƒìž…ë‹ˆë‹¤. 
* ë°©ë²• 
    - observe: Binderê°€ ViewModelì„ ê°ì‹œí•œë‹¤ê³  ì„¤ì •í•˜ê³  
    - notify: ViewModelì´ ë³€í•˜ë©´ Binderì—ê²Œ ì•Œë ¤ì£¼ëŠ” í˜•ì‹ì´ë‹¤. 
* recognize property change
    - ì–´ë–»ê²Œ ì¸ë©”ëª¨ë¦¬ê°ì²´ê°€ ë³€í• ë–„ ì•Œë ¤ì¤„ ìˆ˜ ìžˆì„ê¹Œ? ë¥¼ ìžë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” "defineProperty, Proxy"ì´ ë‘ê°€ì§€ë¥¼ ì§€ì›í•´ì¤ë‹ˆë‹¤. 
* defineProperty & Proxy ``
    - defineProperty: 
        * [defineProperty mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
        * [defineProperties mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)
    - Proxy: ex6 ë¶€í„° ì ìš©, babelë¡œ ë³€í™˜ì´ ì•ˆë¨

    
## Listener & ViewModel
### ViewModelListener class 
* eventì—ì„œ eventListenerë¥¼ ë“±ë¡í•  ë•Œ í•¨ìˆ˜ë¡œ ë“±ë¡í•©ë‹ˆë‹¤. 
    í•˜ì§€ë§Œ ì§€ê¸ˆì€ ê°ì²´ì˜ íŠ¹ì •í•œ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ observing ì‹œí‚¨ë‹¤. 
### ViewModel Classì— Observer Pattern ì ìš© 
``` js
/*
    #index class
    * ViewModelValue
    * ViewModelListener
    * ViewModel
*/
const ViewModelValue = class {
    category; k; v;
    constructor(subKey, category, k, v) {        
        this.category = category; 
        this.k = k; 
        this.v = v; 
        Object.freeze(this)
    }
}

const ViewModelListener = class {
    viewmodelUpdated(updated){ throw 'override'; }
}

const ViewModel = class extends ViewModelListener {
    static get = data => new ViewModel(data);
    static #subjects = new Set;
    static #inited = false;
    static notify(vm) {
        this.#subjects.add(vm);
        if (this.#inited) return
        this.#inited = true;
        const f = () => {
            this.#subjects.forEach(vm => {
                if (vm.#isUpdated.size) {
                    vm.notify();
                    vm.#isUpdated.clear();
                }
            })
            requestAnimationFrame(f);
        }
        requestAnimationFrame(f);
    }
    static descriptor = (vm, category, k, v) => ({
        enumerable: true,
        get: () => v,
        set(newV) {
            v = newV;
            //POINT4.2 defineProperties setì •ì˜
            vm.#isUpdated.add(new ViewModelValue(category, k, v))
        }
    })

    static define = (vm, category, obj) => (
        //POINT4.1 reducing 
        Object.defineProperties(obj,
            Object.entries(obj).reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {})
        )
    )

    subKey = '', parent = null;
    styles = {}, attributes = {}, properties = {}, events = {};
    //POINT1: #isUpdated, #listeners
    #isUpdated = new Set, #listeners = new Set;

    constructor(data, _ = type(data, 'object')) {
        super();
        //POTIN4: ì¤‘ë³µì„ ì—†ì•´ë‹¤.
        Object.entries(data).forEach(([k, v]) => {
            if ('styles,attributes,properties'.includes(k)) {
                if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`
                this[k] = ViewModel.define(this, k, v);
            } else {
                Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))
                if (v instanceof ViewModel) {
                    v.parent = this;
                    v.subKey = k;
                    v.addListener(this);
                }
            }
        })
        //
        ViewModel.notify(this);
        Object.seal(this);
    }

    viewmodelUpdated(updated){ updated.forEach(v => this.#isUpdated.add(v));}
    //POINT2: addListener, removeListener method
    addListener(v, _ = type(v, ViewModelListener)){ this.#listeners.add(v);}
    removeListener(v, _ = type(v, ViewModelListener)){ this.#listeners.delete(v);}
    //POINT3: notify method
    notify(){ this.#listeners.forEach(v => v.viewmodelUpdated(this.#isUpdated));}
}

```
* 1.subjectì´ê¸°ë•Œë¬¸ì— listenerë¥¼ ê±°ëŠë¦¬ê³  ìžˆì–´ì•¼ notificationì„ í•  ìˆ˜ ìžˆë‹¤. 
    * #listenerì— listenerë¥¼ ë°›ì•„ì„œ notificationë ë•Œ #listenerì— noficationì„ ë•Œë ¤ì¤€ë‹¤!
* 2.addListener, removeListener method
    * #listenerì— ì¶”ê°€, ì œê±°í•´ì£¼ëŠ” method
* 3.notify method
    * true, falseê°€ ì•„ë‹ˆë¼ Set typeì„ ë³´ë‚´ì£¼ëŠ” ì´ìœ  
        - updateê°€ ì—¬ëŸ¬ë²ˆ ì¼ì–´ ë‚  ìˆ˜ ìžˆê¸° ë•Œë¬¸ì— 
* 4.ì¤‘ë³µì„ ì—†ì•´ë‹¤
    * "".inclues.(k)
        - ë¬¸ìžì—´ì˜ indexofëŠ” ìžë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ íŠ¹ë³„í•˜ê²Œ ë¹ ë¥´ë‹¤. (objectì—ì„œ keyë¥¼ ì°¾ëŠ” ê²ƒë³´ë‹¤)
    * definePropertyë¥¼ í• ê²ƒì´ë‹¤ ì™œëƒí•˜ë©´ setterë¥¼ ê°ì‹œí•˜ê¸° ìœ„í•´ì„œ 
* 4.1.reducing
    * [reduce mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
    * reducing ì„¤ëª…
        - reduceë‘ë²ˆì§¸ ì¸ìžëŠ” accumulaotr ì´ˆê¸°ê°’ì„ ì„¤ì •
        - reduceí•¨ìˆ˜ì—ëŠ” í•˜ë‚˜ì˜ ì¸ìž callback functionì´ ë“¤ì–´ì™€ì•¼ í•©ë‹ˆë‹¤. 
        - callback functionì˜ ì¸ìž ì„¤ëª…
            * ì²«ë²ˆì§¸ ì¸ìž: callback's return values(reduceì˜ ë‘ë²ˆì§¸ ì¸ìžë¡œ ì´ˆê¸°í™” ê°€ëŠ¥)
            * ë‘ë²ˆìž¬ ì¸ìž: Current Value(ë°°ì—´ì˜ ìš”ì†Œ)
            * ì„¸ë²ˆì§¸ ì¸ìž: Current Index
            * ë„¤ë²ˆì§¸ ì¸ìž: Source Array
        - ë°°ì—´ ë‘ë²ˆì§¸ ìˆœíšŒ ì„¤ëª…  
            * ê·¸ëŸ¼ ë‹¤ìŒ 2ë²ˆì§¸ ë°°ì—´ ì¸ìžë¥¼ ìˆœíšŒ í–ˆì„ë•Œ callbackì˜ ì²«ë²ˆì§¸ ì¸ìž "accumulator"ëŠ” reduce ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ ìˆœíšŒ í–ˆì„ë•Œ accumulatorì˜ return ê°’ callbcak function ì˜ ì²«ë²ˆì§¸ ì¸ìž(accumulator)ê°€ ëœë‹¤. 
        - ê²°êµ­ ìœ„ ì½”ë“œì—ì„œëŠ” rê°ì²´ê°€ ë°˜í™˜ ë˜ê² ìŠµë‹ˆë‹¤. 
            * ë°˜ëœ ê°’ì€ ì•„ëž˜ì™€ ê°™ìŠµë‹ˆë‹¤. 
            ```js
            //Object.entries(obj)ê°€ ì•„ëž˜ì™€ ê°™ì€ ê°’ì„ ê°€ì§ˆë•Œ ë°˜í™˜ ê°’ ìž…ë‹ˆë‹¤.
            //ViewModelì˜ descriptor methodë¥¼ ì°¸ê³ í•˜ë©´ ì´í•´ê°€ ë  ê²ƒìž…ë‹ˆë‹¤.
            [["width", "50%"], ["background", "#ffa"], ["cursor", "pointer"]] 

            {
                width: {enumerable: true, get f, set: f ...}
                background: {enumerable: true, get f, set: f ...}
                cursor: {enumerable: true, get f, set: f ...}
            }
            ```
    * reduceì˜ ë‘ë²ˆì§¸ ì¸ìžëŠ” ì´ˆê¸°í™” ë°ì´í„° íƒ€ìž…ìœ¼ë¡œ, returnì‹œ ì´ typeìœ¼ë¡œ ë°˜í™˜ëœë‹¤. 
        - í˜„ìž¬ {} ìœ¼ë¡œ ì´ˆê¸°í™”
        - 
    * Object.entries(obj)ëŠ” 2ì°¨ì› ë°°ì—´ì„ ë°˜í™˜
        ```js
            [["width", "50%"], ["background", "#ffa"], ["cursor", "pointer"]] 
        ```
* POINT4.2 defineProperties setì •ì˜
    - vm(ViewModel instance)ì— #isUpdated(Set type)ì— ë­”ê°€ë¥¼ ì¶”ê°€í•´ì£¼ê³  ì‹¶ë‹¤. 
    - ë­”ê°€ëž€?
        * ViewModelValueì˜ instance!!! ì½”ë“œ ì°¸ê³  
        ```js
            vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v))
        ```
    - ì´ë ‡ê²Œ setì— ì„¤ì •ì„ í•˜ê²Œ ë˜ë©´ ì´ê²ƒì„ ë„ì§‘ì–´ ë‚¼ë•Œ ì˜ˆë¥¼ ë“¤ì–´ styleì— backgroundê°€ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë°”ë€Œì—ˆë„¤ ë¼ê³  ì•Œìˆ˜ ìžˆìŠµë‹ˆë‹¤. 
    - ì˜µì €ë²„íŒ¨í„´ì—ì„œ subject... ì§€ì˜¥ì´ë„¤ ðŸ¶ë¹¡ì„¸ë„¤ 

## í•µì‹¬
* POINT4.2 defineProperties setì •ì˜ì— ì•„ëž˜ì™€ ê°™ì´ ViewModeValue instanceë¥¼ ë„˜ê²¨ì£¼ê³  notificationë˜ë©´ setì— ë‹´ê²¨ìžˆëŠ” ê²ƒì„ í˜¸ì¶œí•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ ì´í•´ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. 
 ```js
    new ViewModelValue(vm.subKey, category, k, v))
 ```

# Composite(ViewModel class ìˆ˜ì •)
> ë‚´ê°€ ë‚´ ë¬¸ì œë¥¼ ë™ì¼í•œ ë¬¸ì œìž„ì—ë„ ë¶ˆêµ¬í•˜ê³  ë‚´ê°€ í•´ê²°í•˜ì§€ ì•Šê³  ìœ„ìž„ì„ ê³„ì† ë°˜ë³µí•´ì„œ ê·¸ê²ƒë“¤ì„ ì·¨í•¨í•˜ëŠ” í–‰ë™ë“¤ì„ ë§í•©ë‹ˆë‹¤. 
> ì´ ë¶€ë¶„ì€ ViewModel classì™€ ê´€ë ¨ë˜ ìžˆìŠµë‹ˆë‹¤. 
* ëŒ€ì¤‘ ê³„ì¸µì— ëŒ€í•œ ê³ ë¯¼ì´ ìƒí•­ ìžˆë‹¤. 
    - ì˜ˆë¥¼ ë“¤ì–´ í´ë”ì•ˆì— íŒŒì¼ í´ë”ì•ˆì— íŒŒì¼
    - ë‹¤ì¤‘ë…¸ë“œê°€ ì „ê°œë˜ì–´ ìžˆëŠ” íŠ¸ë¦¬ë¥¼ ì–¼ë§ˆë‚˜ ë¹ ë¥´ê²Œ í™”ë©´ì— ë¿Œë¦´ ìˆ˜ ìžˆëŠ”ì§€ ì¤‘ìš”!
* ë™ì íƒìƒ‰, íŠ¸ë¦¬íƒìƒ‰ìœ¼ë¡œ í’€ ìˆ˜ ìžˆëŠ”ë°
    - ì†ë„ëŠ” ë™ì íƒìƒ‰ì´ ë¹ ë¥¸ë° ì •í˜•í™”ëœ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê°€ë©´ íŠ¸ë¦¬ íƒìƒ‰ì´ ì‰½ë‹¤.  

* ìš°ë¦¬ì—ê²Œ Composite ë¬¸ì œê°€ í•„ìš”í•œê°€? 
    - ìš°ë¦¬ê°€ ë§Œë“  ViewModel ì•ˆì— ViewModelì´ ìžˆì—ˆë‹¤.(wrapper, title, contents)
    - ì´ë ‡ê²Œ viewModelì•ˆì— ìžˆëŠ” ViewModelì´ ë³€í™”ê°€ ì¼ì–´ë‚¬ì„ë•Œ ìžê¸°ì˜ ë³€í™”ëŠ” ìžê¸°ê°€ êµ¬ë…í•˜ê³  ìžˆëŠ”ì—ê²ŒëŠ” ê°„ë‹¤. 
    - ê·¸ëŸ°ë° ìš°ë¦¬ëŠ” êµ¬ë…ì„ ViewModelì—ê²Œ ê±¸ê°€? ì•„ë‹ˆ ì´ ViewModelì„ ì†Œìœ í•˜ê³  ìžˆëŠ” ViewModelì—ê²Œ ê±´ë‹¤(sub ViewModelì—ê²Œ êµ¬ë…ì„ ê±¸ì§€ ì•ŠëŠ”ë‹¤.)
    - ê·¸ ì´ìœ ëŠ” binderëŠ” í†µ VeiwModelì„ ì•Œì•„ì•¼ì§€ ì•„ì´í…œì´ ë§µí•‘ë˜ì–´ ìžˆëŠ” ì „ì²´ ViewModelì„ ë§¤í•‘ í•  ìˆ˜ ìžˆê¸° ë•Œë¬¸ìž…ë‹ˆë‹¤. ê·¸ëž˜ì„œ ë‹¤ ê°ì‹¸ê³  ìžˆëŠ” ViewModelì— êµ¬ë…ì„ í•œë‹¤. (sub ViewModelì— êµ¬ë…ì„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.)
    - ê·¸ëŸ¬ë©´ ìš°ë¦¬ëŠ” ì „ì œ ë‹¤ ê°ì‹¸ê³  ìž‡ëŠ” ViewModelë¿ì´ ì•„ë‹ˆë¼ sub ViewModelì—ê²Œë„ Listenerì—ê²Œ ì•Œë ¤ì•¼ í•©ë‹ˆë‹¤. sub ViewModelì•ˆì— ë˜ sub ViewModelì´ ìžˆë‹¤ë©´ ì´ê²ƒë„ Lsitenerì—ê²Œ ì•Œë ¤ ì¤ë‹ˆë‹¤. ëª¨ë“ ê±¸ ë‹¤ ì•Œë ¤ì¤˜ì•¼ í•©ë‹ˆë‹¤.    
    - ì´ëŸ° ë¬¸ì œë¥¼ ë™ì íƒìƒ‰, íŠ¸ë¦¬íƒìƒ‰ìœ¼ë¡œ í’€ì§€ ì•Šê³  ê°ì²´ì§€í–¥ì—ì„œëŠ” `ë™ì ìœ„ìž„`ìœ¼ë¡œ í•´ê²°í•œë‹¤!!!


* Binder Classê°€ ë³€ê²½ëœ ë¶€ë¶„ ì£¼ì„ìœ¼ë¡œ ê±¸ì–´ ë†“ì€ POINT1, 2, 3, 4, 5, 5.1 ë‚´ìš© í™•ì¸
``` js
/*
    #index class
    * ViewModelValue
    * ViewModelListener
    * ViewModel
*/
const ViewModelValue = class {
    //POINT3: subKey
    subKey; category; k; v;
    constructor(subKey, category, k, v) {
        this.subKey = subKey; 
        this.category = category; 
        this.k = k; 
        this.v = v; 
        Object.freeze(this)
    }
}

const ViewModelListener = class {
    viewmodelUpdated(updated){ throw 'override'; }
}

const ViewModel = class extends ViewModelListener {
    static get = data => new ViewModel(data);
    static #subjects = new Set;
    static #inited = false;
    //POINT5.1 notify: observerì—ê²Œ í†µë³´í•  subjectsë“¤ì´ ëª¨ì¸ ê³³
    // vm.notifyëŠ” ê²°êµ­ v.viewmodelUpdatedë¥¼ í†µí•´ì„œ binderì˜ viewmodelupdatedë¥¼ í†µí•´ì„œ elì„ ë³€ê²½í•œë‹¤ !!!
    static notify(vm) {
        this.#subjects.a dd(vm);
        if (this.#inited) return
        this.#inited = true;
        const f = () => {
            this.#subjects.forEach(vm => {
                if (vm.#isUpdated.size) {   //ì—…ë°ì´íŠ¸ ì—¬ë¶€ í™•ì¸ 
                    vm.notify();            //vmì´ ê°€ì§€ê³  ìžˆëŠ” Listenerë“¤ì—ê²Œ notify 
                    vm.#isUpdated.clear();  //notifyí•œ ê²ƒì€ ì œê±° í•´ì¤€ë‹¤. 
                }
            })
            requestAnimationFrame(f);
        }
        requestAnimationFrame(f);
    }
    static descriptor = (vm, category, k, v) => ({
        enumerable: true,
        get: () => v,
        set(newV) {
            v = newV;
            //POINT4 vm.subKey ì¶”ê°€: ìžì‹ì´ìž ìžì‹ ìž…ì„ ì•Œë ¤ì£¼ê¸° ìœ„í•´ì„œ 
            vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v))
        }
    })

    static define = (vm, category, obj) => (
        Object.defineProperties(obj,
            Object.entries(obj).reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {})
        )
    )

    subKey = '', parent = null;
    styles = {}, attributes = {}, properties = {}, events = {};
    #isUpdated = new Set, #listeners = new Set;

    constructor(data, _ = type(data, 'object')) {
        super();
        Object.entries(data).forEach(([k, v]) => {
            if ('styles,attributes,properties'.includes(k)) {
                if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`
                this[k] = ViewModel.define(this, k, v);
            } else {
                //POINT1: elì˜ wrapper, title, contents
                Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))
                if (v instanceof ViewModel) {
                    //ë¶€ëª¨ìžì‹ ê°œë…ì´ ìƒê²¼ë‹¤. 
                    v.parent = this;      //ë¶€ëª¨
                    v.subKey = k;         //subKeyê°€ ëˆ„êµ¬ ì†Œì†ì¼ë•Œ í• ë‹¹(ë¶€ëª¨ë¥¼ ì•Œê²Œ ëœë‹¤), ì—†ëŠ”ê±´ root
                    v.addListener(this);  //ìžì‹ì˜ Listenerê°€ ë˜ëŠ” ì½”ë“œ(ìžì‹ì´ ë³€í™” í–ˆì„ë•Œ ë³€í™”ë¥¼ ì•Œì•„ì°¨ë ¤ ë‚˜ì˜ ì¼ë¶€ì˜ ë³€í™”ë¡œ í¬í•¨ ì‹œí‚¬ ìˆ˜ ìžˆë‹¤. )
                }
                //
            }
        })
        //POINT5: ViewModel.notify
        ViewModel.notify(this); //ViewModelì´ ìƒˆë¡œ ë§Œë“¤ì–´ì¡Œì„ë•Œ ë³€ê²½ëë‹¤ê³  ì•Œë ¤ì¤€ë‹¤.(ViewModelê¸°ì¤€ìœ¼ë¡œ ViewModelì´ ë°”ë€Œë©´ í•œë²ˆë§Œ)
        Object.seal(this);
    }

    //POINT2: viewmodelUpdated
    viewmodelUpdated(updated){ updated.forEach(v => this.#isUpdated.add(v));}
    addListener(v, _ = type(v, ViewModelListener)){ this.#listeners.add(v);}
    removeListener(v, _ = type(v, ViewModelListener)){ this.#listeners.delete(v);}
    notify(){ this.#listeners.forEach(v => v.viewmodelUpdated(this.#isUpdated));}
}

```  
`ì¤‘ìš”: Observer pattenrì€ ë³´í†µ Composite ê°™ì´ ì¼ì–´ë‚˜ëŠ”ë° conceptì€ ì´í•´ê°€ ë˜ì§€ë§Œ ì½”ë“œì™€ ì—°ê´€ ì§€ì–´ì„œ ê³ ë¯¼í•´ë³¼ í•„ìš”ê°€ ìžˆìŠµë‹ˆë‹¤.`
* POINT1 elì˜ wrapper, title, contentsê°€ ë“¤ì–´ì˜¤ëŠ” ì¼€ì´ìŠ¤
    - ì´ê²ƒì˜ ë³€í™”ë„ ìœ„ë¡œ ë³´ê³  í•´ì•¼í•œë‹¤.( ViewModelì˜ ì˜µì €ë²„ê°€ ë˜ì•¼ í•œë‹¤.) ê·¸ëž˜ì•¼ ì–˜ë¥¼ ìˆ˜ì‹  í•  ìˆ˜ ìžˆë‹¤. 
    - subjectì¼ ê²½ìš° ê·¸ì˜ ìžì‹ì¸ viewModelì—ê²ŒëŠ” ì˜µì €ë²„ê°€ ë˜ì–´ì•¼ í•œë‹¤.(ë³€í™”ë¥¼ ìˆ˜ì‹ í•´ì•¼ ë³€í™”ë¥¼ ì™¸ë¶€ì— í†µë³´í•  ìˆ˜ ìžˆë‹¤.)  
    - subjectì´ë©´ì„œ ë™ì‹œì— viewModelì— ì˜µì €ë²„ì´ê¸°ë„ í•©ë‹ˆë‹¤. ê·¸ëž˜ì„œ ë‚´ê°€ viewModelì´ ì•„ë‹ˆë©´ ì „íŒŒê°€ ëë‚¨
* [ë³´ì™„] - ë¶„ì„
    - ViewModel Classì˜ notifyë¶€ë¶„ ë¶„ì„ í•„ìš”(subjectì˜ ê¸°ëŠ¥ì´ ë“¤ì—ˆë‹¤.)
    - ViewModel Class Constructorì˜ ViewModel.notifyì—ì„œ vì— ë”°ë¼ì„œ VeiwModelì˜ viewmodelUpdated, binderì˜ viewModelUpdatedê°€ í˜¸ì¶œ ëœë‹¤. ì–´ë–¤ ê²½ìš°ì¸ì§€ í™•ì¸í•„ìš”(í™•ì¸í•˜ë©´ì„œ conceptì •ë¦¬)



# Observer(Binder Class ìˆ˜ì •)
* Binderê°€ ì‹¤ì œë¡œ ViewModelì„ êµ¬ë…ì—­í• (Observer)ì„í•œë‹¤. 
* Binder Classê°€ ë³€ê²½ëœ ë¶€ë¶„ ì£¼ì„ìœ¼ë¡œ ê±¸ì–´ ë†“ì€ POINT1, 2 ë‚´ìš© í™•ì¸
```js
    const Binder = class extends ViewModelListener {
        #items = new Set;
        #processors = {};

        //POINT2: ê³µí¬ì˜ Listenerë¥¼ êµ¬í˜„
        viewmodelUpdated(updated) {
            const items = {};
            this.#items.forEach(({ vmName, el }) => {
                items[vmName] = [type(rootViewModel[vmName], ViewModel), el];
            });
            updated.forEach(({ subKey, category, k, v }) => {
                if (!items[subKey]) return;
                const [vm, el] = items[subKey], processor = this.#processors[category];
                if (!el || !processor) return;
                processor.process(vm, el, k, v);
            })
        }

        add(v, _ = type(v, BinderItem)) { this.#items.add(v); }
        addProcessor(v, _ = type(v, Processor)) { this.#processors[v.category] = v; }
        render(viewmodel, _ = type(viewmodel, ViewModel)) {
            const processores = Object.entries(this.#processors)
            this.#items.forEach(({ vmName,el }) => {
                const vm = type(viewmodel[vmName], ViewModel);
                processores.forEach(([pk, processor]) => {
                    Object.entries(vm[pk]).forEach(([k, v]) => {
                        processor.process(vm, el, k, v)
                    })
                })
            })
        }
        //POINT1: íŠ¹ì • ViewModelì— listenerì— ë“±ë¡ë˜ê³  ë§ê³ ë¥¼ ê²°ì •í•œë‹¤. 
        watch(viewmodel, _ = type(viewmodel, ViewModel)) {
            viewmodel.addListener(this);
            this.render(viewmodel);
        }
        unwatch(viewmodel, _ = type(viewmodel, ViewModel)) {
            viewmodel.removeListener(this);
        }

    }
```
* [ë³´ì™„] - ë¶„ì„
    - viewmodelUpdated method breakpointê±¸ì–´ í™•ì¸í•´ë³´ê¸°



# Client
```js
const Scanner = class {
    scan(el, _ = type(el, HTMLElement)) {
        const binder = new Binder();
        this.checkItem(binder, el);
        const stack = [el.firstElementChild];
        let target;
        while (target = stack.pop()) {
            this.checkItem(binder, target);
            if (target.firstElementChild) stack.push(target.firstElementChild);
            if (target.nextElementSibling) stack.push(target.nextElementSibling);
        }
        return binder;
    }
    checkItem(binder, el) {
        const vmName = el.getAttribute('data-viewmodel');
        if (vmName) binder.add(new BinderItem(el, vmName));
    }
}

const scanner = new Scanner();
const binder = scanner.scan(document.querySelector('#target'));
binder.addProcessor(new class extends Processor {
    _process(vm, el, k, v) { el.style[k] = v; }
}('styles'))
binder.addProcessor(new class extends Processor {
    _process(vm, el, k, v) { el.setAttribute(k, v); }
}('attributes'))
binder.addProcessor(new class extends Processor {
    _process(vm, el, k, v) { el[k] = v; }
}('properties'))
binder.addProcessor(new class extends Processor {
    _process(vm, el, k, v) { el[`on${k}`] = e => v.call(el, e, vm); }
}('events'))

const getRandom = () => parseInt(Math.random() * 150) + 100
const wrapper = ViewModel.get({
    styles: {
        width: '50%',
        background: '#ffa',
        cursor: 'pointer'
    },
    events: {
        click(e, vm) {
            vm.parent.isStop = true
        }
    }
})
const title = ViewModel.get({
    properties: {
        innerHTML: 'Title'
    }
})
const contents = ViewModel.get({
    properties: {
        innerHTML: 'Contents'
    }
})
const rootViewModel = ViewModel.get({
    isStop: false,
    changeContents() {
        this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`
        this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '')
    },
    wrapper,
    title,
    contents
})
binder.watch(rootViewModel)
const f = () => {
    rootViewModel.changeContents()
    if (!rootViewModel.isStop) requestAnimationFrame(f)
}
requestAnimationFrame(f)
```





# ì „ì²´ì½”ë“œ
```html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MVVM</title>
</head>

<body>
    <section id="target" data-viewmodel="wrapper">
        <h2 data-viewmodel="title"></h2>
        <section data-viewmodel="contents"></section>
    </section>
    <script>
        const type = (target, type) => {
            if (typeof type == "string") {
                if (typeof target != type) throw `invalid type ${target} : ${type}`;
            } else if (!(target instanceof type)) {
                throw `invalid type ${target} : ${type}`;
            }
            return target;
        }

        const ViewModelListener = class {
            viewmodelUpdated(updated) {
                throw 'override';
            }
        }

        const ViewModel = class extends ViewModelListener {
            static get = data => new ViewModel(data);
            static #subjects = new Set;
            static #inited = false;
            static notify(vm) {
                this.#subjects.add(vm);
                if (this.#inited) return
                this.#inited = true;
                const f = () => {
                    this.#subjects.forEach(vm => {
                        if (vm.#isUpdated.size) {
                            vm.notify();
                            vm.#isUpdated.clear();
                        }
                    })
                    requestAnimationFrame(f);
                }
                requestAnimationFrame(f);
            }
            static descriptor = (vm, category, k, v) => ({
                enumerable: true,
                get: () => v,
                set(newV) {
                    v = newV;
                    vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v))
                }
            })

            static define = (vm, category, obj) => (
                Object.defineProperties(
                    obj,
                    Object.entries(obj)
                    .reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {})
                )
            )

            subKey = '';
            parent = null;
            styles = {};
            attributes = {};
            properties = {};
            events = {};
            #isUpdated = new Set;
            #listeners = new Set;

            constructor(data, _ = type(data, 'object')) {
                super();
                Object.entries(data).forEach(([k, v]) => {
                    if ('styles,attributes,properties'.includes(k)) {
                        if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`
                        this[k] = ViewModel.define(this, k, v);
                    } else {
                        Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))
                        if (v instanceof ViewModel) {
                            v.parent = this;
                            v.subKey = k;
                            v.addListener(this);
                        }
                    }
                })
                ViewModel.notify(this);
                Object.seal(this);
            }

            viewmodelUpdated(updated) {
                updated.forEach(v => this.#isUpdated.add(v));
            }
            addListener(v, _ = type(v, ViewModelListener)) {
                this.#listeners.add(v);
            }
            removeListener(v, _ = type(v, ViewModelListener)) {
                this.#listeners.delete(v);
            }
            notify() {
                this.#listeners.forEach(v => v.viewmodelUpdated(this.#isUpdated));
            }
        }

        const ViewModelValue = class {
            subKey; category; k; v;
            constructor(subKey, category, k, v) {
                this.subKey = subKey; 
                this.category = category; 
                this.k = k; 
                this.v = v; 
                Object.freeze(this)
            }
        }

        const BinderItem = class {
            el;
            vmName;
            constructor(el, vmName, _0 = type(el, HTMLElement), _1 = type(vmName, 'string')) {
                this.el = el;
                this.vmName = vmName;
                Object.freeze(this);
            }
        }

        const Binder = class extends ViewModelListener {
            #items = new Set;
            #processors = {};
            viewmodelUpdated(updated) {
                const items = {};
                this.#items.forEach(({ vmName, el }) => {
                    items[vmName] = [type(rootViewModel[vmName], ViewModel), el];
                });
                updated.forEach(({ subKey, category, k, v }) => {
                    if (!items[subKey]) return;
                    const [vm, el] = items[subKey], processor = this.#processors[category];
                    if (!el || !processor) return;
                    processor.process(vm, el, k, v);
                })
            }

            add(v, _ = type(v, BinderItem)) { this.#items.add(v); }
            addProcessor(v, _ = type(v, Processor)) { this.#processors[v.category] = v; }
            render(viewmodel, _ = type(viewmodel, ViewModel)) {
                const processores = Object.entries(this.#processors)
                this.#items.forEach(({ vmName,el }) => {
                    const vm = type(viewmodel[vmName], ViewModel);
                    processores.forEach(([pk, processor]) => {
                        Object.entries(vm[pk]).forEach(([k, v]) => {
                            processor.process(vm, el, k, v)
                        })
                    })
                })
            }
            watch(viewmodel, _ = type(viewmodel, ViewModel)) {
                viewmodel.addListener(this);
                this.render(viewmodel);
            }
            unwatch(viewmodel, _ = type(viewmodel, ViewModel)) {
                viewmodel.removeListener(this);
            }
        }

        const Processor = class {
            category;
            constructor(category) {
                this.category = category;
                Object.freeze(this);
            }
            process(vm, el, k, v, _0 = type(vm, ViewModel),
                                    _1 = type(el, HTMLElement),
                                    _2 = type(k, "string")) {
                this._process(vm, el, k, v);
            }
            _process(vm, el, k, v) { throw 'override'; }
        }

        const Scanner = class {
            scan(el, _ = type(el, HTMLElement)) {
                const binder = new Binder();
                this.checkItem(binder, el);
                const stack = [el.firstElementChild];
                let target;
                while (target = stack.pop()) {
                    this.checkItem(binder, target);
                    if (target.firstElementChild) stack.push(target.firstElementChild);
                    if (target.nextElementSibling) stack.push(target.nextElementSibling);
                }
                return binder;
            }
            checkItem(binder, el) {
                const vmName = el.getAttribute('data-viewmodel');
                if (vmName) binder.add(new BinderItem(el, vmName));
            }
        }

        const scanner = new Scanner();
        const binder = scanner.scan(document.querySelector('#target'));
        binder.addProcessor(new class extends Processor {
            _process(vm, el, k, v) { el.style[k] = v; }
        }('styles'))
        binder.addProcessor(new class extends Processor {
            _process(vm, el, k, v) { el.setAttribute(k, v); }
        }('attributes'))
        binder.addProcessor(new class extends Processor {
            _process(vm, el, k, v) { el[k] = v; }
        }('properties'))
        binder.addProcessor(new class extends Processor {
            _process(vm, el, k, v) { el[`on${k}`] = e => v.call(el, e, vm); }
        }('events'))

        const getRandom = () => parseInt(Math.random() * 150) + 100
        const wrapper = ViewModel.get({
            styles: {
                width: '50%',
                background: '#ffa',
                cursor: 'pointer'
            },
            events: {
                click(e, vm) {
                    vm.parent.isStop = true
                }
            }
        })
        const title = ViewModel.get({
            properties: {
                innerHTML: 'Title'
            }
        })
        const contents = ViewModel.get({
            properties: {
                innerHTML: 'Contents'
            }
        })
        const rootViewModel = ViewModel.get({
            isStop: false,
            changeContents() {
                this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`
                this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '')
            },
            wrapper,
            title,
            contents
        })
        binder.watch(rootViewModel)
        const f = () => {
            rootViewModel.changeContents()
            if (!rootViewModel.isStop) requestAnimationFrame(f)
        }
        requestAnimationFrame(f)
    </script>
</body>

</html>
```
