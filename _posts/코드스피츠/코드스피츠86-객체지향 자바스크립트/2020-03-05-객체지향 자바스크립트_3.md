---
title: 객체지향 자바스크립트 3회차(MVVM pattern 개선)
date: 2020-03-05
tags:
  - 코드스피츠
  - 객제지향 자바스크립트
keywords:
  - 객체지향
  - MVVM
---

# 목표 
* call -> Observation
    - 전 강의에서 만은 MVVM에서 Binder가 Observation을 하고 있지 않았다.  
모델의 변화를 call을 통해서 view를 변경했다.  [전 강의 observe -> call로 대체](https://happyjy.github.io/객체지향%20자바스크립트_2/#observe---call로-대체)  
이제는 모델이 변하면 binder가 자동으로 view를변하게 해준는게 목표이다.   

* 전략적 패턴 적용
    - 기존 binder가 코드로 확정 되어 있다. 이 부분을 전략적으로 빼내는 방법을 살펴본다. 

* 배울 keyword 
    - Strategy Pattern, Dependency Injection, 
    - Observer Pattern
    - Template method Pattern
    - Composite Pattern


# Strategy Pattern

## 정의
* 어떤 문제를 해결하기 위한 지식적인 부분, 도메인, 알고리즘을 교체하면서 문제를 해결할 수 있다. 

## Binder class Strategy 적용
> 전략을 빼내는 방법을 설명합니다. 
> Binder class는 Structure&control, Strategy부분으로 나뉘어 있다. 아래르 확인해보자 
> 외제화 시키는 부분은 `strategy`부분이다.

* Binder의 구조부분 확인
![Structure & control](./3회/1.Strategy_Structure&Control.png) 

*  Binder class의 전략 부분 
    - 전략부분: 특정 도메인(알고리즘,지식)을 해결하기 위한 전략적인 부분 

    ![Strategy](./3회/2.Strategy_Strategy.png)

* code -> Object
![Code->Object](./3회/3.Strategy_CodeToObject.png)

    - composition 적용 
        * 객체 지향에서는 composition을 사용해서 해결한다.
        composition이란 **code를 object로 바꾸는것이다**.
        그런데 code를 고치면 의존하고 있는 부분을 테스트를 다시 해야한다.
        그래서 **code를 안바꾸고서 object로 바꾸고 싶다.(왜냐하면 변화가 있을때 마다 code를 변경해야 하기때문)**
        전략을 도출하는데 성공했으면 code에서 strategy부분이 structure와 어떻게 관계를 맺는지 잘 확인해보고 그리고나서 code부분을 object로 변경해야 한다.
        하지만 임의의 객체로 변경하면 변경하려는 code와 일반화 관계를 맺을 수 없다. 
        그래서 **우리는 객체를 도출할떄 interface나 class로 type으로 노출**해야 한다. 
        왜냐하면 type을 정해야지만 code가 어떤식의 객체인지를 알아야 변경했을때 적용할 수 있기 때문이다. 
        

    - Dependency가 생기는 이유 
        * 코드를 객체로 변경했기때문 
        * 코드 대신에 type을 정의해서 객체를 받아 들이면 기존코드에는 의존이 없었는데 객체를 알아야 Binder를 진행할 수 있다.  
        그래서 코드를 외부객체 composition으로 바꿀 것이다. 그러면 외부에서 공급되는 객체를 알아야 Binder가 작동할 수 있다.(그래서 Strategy 부분에 대해서 의존성이 생긴다 )
        * 객체지향에서 Dependency가 생기는 이유가 뭘까? 
            - 위임했기때문이 아니다! Strategy를 외부 객체에 의해서 해결하고 싶다. 이렇게 하고 싶은 이유는 변화가 있을때 마다 code를 변경해야 하기 때문이다. 그래서 code를 object로 바꿔주면 바꿔준 object에 대해서 의존성이 생기는 것 입니다. 이렇게 Binder는 Binder strategy와 의존광계가 생성이 된다.

    - DI(Dependency Injection)
        * 의존성이 생겼을때 내부에서 의존성이 있는 sub Type을 만들어 내는 경우가 있고 공급받는 경우가 있는데 내부에서 만들면 다시 하드코딩을 해야하기 때문에 **외부에서 공급**받는다. 그래야 내부에는 type에 대한 의존만 있고 특정 객체에대한 의존성을 없앨 수 있다. 

    - 결론
        * 코드를 객체로 빼내는 순간 `Dependency`,`Dependency Injection`이 생긴다.
        * `Dependency`가 생기는 이유는 코드를 객체로 변경했기 때문 
        * 객체에 대한 의존성을 내부에서 생성해버리면 dependency만 생긴다.  이러면 다시 코드를 건드려야 해서 외부에서 공급(`Dependency Injection`)받아야지면 객체를 뺀이유가 생긴다.  






* 참고 
(제로초 전략패턴)[https://www.zerocho.com/category/JavaScript/post/580f17ef77023c0015ee9688]

# Observation Pattern
## Listener
## ViewModel
## Composite
## Observer

# Client
# 전체코드


# 결과  