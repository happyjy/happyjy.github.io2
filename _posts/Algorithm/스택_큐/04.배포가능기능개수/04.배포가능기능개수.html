
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 
            각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.
            또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 
            이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

            먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 
            각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 
            각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

            ### 제한 사항
                작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
                작업 진도는 100 미만의 자연수입니다.
                작업 속도는 100 이하의 자연수입니다.
                배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.
            
            ### 입출력 예
                progresses	speeds	  return
                [93,30,55]	[1,30,5]	[2,1]
            ### 입출력 예 설명
                첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.
                두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다.
                                 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.
                세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.

                따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.
        */

        function solution(progresses, speeds) {
            //STPE1.  progresses, speeds를 이용해 각 progresses index의 인자가 몇일 뒤에 완료 되는지 days array에 넣는다.            
            //STEP2.1 leftDays 첫번째 남은 배포일을 기준보다 leftDays 배열을 순회 하면서 요소 값보다 크거나 같으면 같이 배포하는것이고 작으면 다음날 다로 배포하는 것

            let answer = [0];
            //STEP1
            let leftDays = progresses.map((progress, index) => Math.ceil((100 - progress) / speeds[index]))
            let compareTargetLeftDays = leftDays[0];

            //STEP2
            //STEP2.1
            for (let i = 0, j = 0; i < leftDays.length; i++) {
                if (leftDays[i] <= compareTargetLeftDays) {
                    answer[j] += 1; //
                } else {
                    answer[++j] = 1;
                    // STEP2.2 
                    compareTargetLeftDays = leftDays[i]; 
                }
            }

            return answer;
        }


        //STEP1. 완료되는 날짜를 Math.ceil을 사용하지 않은 예
        function solution2(progresses, speeds) {
            var answer = [];

            var daysToNeed = [];
            var spendDays, functionCnt = 0;
            //STEP1
            for (var i = 0; i < progresses.length; i++) {
                spendDays = 0;
                while (1) {
                    spendDays++;
                    progresses[i] += speeds[i];
                    if (progresses[i] >= 100) {
                        break;
                    }
                }
                daysToNeed.push(spendDays);
            }

            spendDays = daysToNeed[0];
            functionCnt = 1;
            for (var i = 1; i < daysToNeed.length; i++) {
                if (daysToNeed[i] <= spendDays) {
                    functionCnt++;
                } else {
                    spendDays = daysToNeed[i];
                    answer.push(functionCnt);
                    functionCnt = 1;
                }

                //index i가 daysToNeed array에 맨뒤로 갔을때 무조건 push
                if (i === daysToNeed.length - 1) {
                    answer.push(functionCnt);
                }
            }

            return answer;
        }

        console.log(solution([93,30,55,92], [1,30,5,1]));
    </script>

</body>

</html>
