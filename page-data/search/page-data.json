{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n```\n# 목차\n    * call() 정의\n    * call()을 생성자 연결에 사용\n    * call()을 익명함수와 함께 쓰기 \n    * call()호출시 this에 특정 값을 넣어 동작하기\n    * call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n    * call, apply함수의 비교(this에 특정 값 넣어 동작)\n    * bind()\n    * bind()함수 구현 해보기\n    * creating a bound function\n    * Partially applied functions\n    * with setTimeout()\n```\n\n# call() 정의\n> 주어진 this 값, 전달된 인수 와 함께 함수를 호출\n\n```js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\n\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n```\n\n# call()을 생성자 연결에 사용\n> function, method에 속해서 다른 객체를 호출한다.  \n> function, method에 this 값을 전해준다.  \n함수는 한번 쓰고 다른 객체에서 상속 받아 사용한다.(method를 다시 만들 필요 없이)\n``` js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price < 0) {\n    throw RangeError('Cannot create product ' +\n                      this.name + ' with a negative price');\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'food';\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'toy';\n}\n\nvar cheese = new Food('feta', 5);\nvar fun = new Toy('robot', 40);\n```\n\n\n# call()을 익명함수와 함께 쓰기 \n```js\nvar animals = [\n  { species: 'Lion', name: 'King' },\n  { species: 'Whale', name: 'Fail' }\n];\n\nfor (var i = 0; i < animals.length; i++) {\n  (function(i) {\n    this.print = function() {\n      console.log('#' + i + ' ' + this.species\n                  + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n//## 결과 \n//#0 Lion: Kinf\n//#1 Whale: Fail\n```\n\n# call()호출시 this에 특정 값을 넣어 동작하기\n> \n\n```js\nfunction greet() {\n  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n  console.log(reply);\n}\n\nvar obj = {\n  animal: 'cats', sleepDuration: '12 and 16 hours'\n};\n\ngreet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n# call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n> call로 호출될 function 안에 this의 bound는 global object이다  \n> 하지만 use stric을 사용 하용하면 undefined가 나온다. \n```js\nvar sData = 'Wisen';\n            \nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call();  // sData value is Wisen \n\n``` \n\n```js            \n'use strict';\n\nvar sData = 'Wisen';\n\nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call(); // Cannot read the property of 'sData' of undefined            \n```\n\n# call, apply함수의 비교(this에 특정 값 넣어 동작)\n```js\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.call(obj,\"Korea\",\"Seoul\"));\t\n//welcome to Korea in Seoul Jaeyoon\n\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.apply(obj,[\"Korea\",\"Seoul\"]));\t\t\n//welcome to Korea in Seoul Jaeyoon\n```\n\n\n\n\n\n\n# bind()\n> 함수와 객체를 서로 묶는 것이다.  \n> bind()함수는 새 함수를 반환한다.(call, apply는 바로 동작`)\n```js\nfunction f(y) { return this.x + y }    //바인드되어야 하는 함수\nvar o = {x:1};      //바인드될 객체\nvar g = f.bind(o);  //g(x)를 호출하면 o.f(x)가 호출된다.\ng(2)                //=>3\n```\n\n# bind()함수 구현 해보기 \n```js\nFunction.prototype.bind = function(obj){\n  //this와 인자 값을 변수에 저장함으로써 다음의 중첩 함수에서 사용할 수 있다.\n  var me = this, boundArgs = arguments;\n\n  //bind() 메서드의 반환 값은 함수다.\n  return function(){\n  //인자 목록을 작성하는데, 첫 번재 이후의 인자부터\n  //나머지 모든 인자를 이 함수에 전달 한다.\n  var args = [], i;\n  for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);\n  for(i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  \n  //인자들을 포함하여 obj의 메서드로 me를 호출한다.\n  return me.apply(obj, args);\n}\n```\n\n# creating a bound function\n\n```js\nthis.x = 9;    // this refers to global \"window\" object here in the browser\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nmodule.getX(); // return: 81 - The ufnction gets invoked at the module scope\nretrieveX();   // returns 9 - The function gets invoked at the global scope\n\n// Create a new function with 'this' bound to module\n// New programmers might confuse the global var x with module's property x\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n# Partially applied functions\n\n```js\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\nvar result1 = addArguments(1, 2); // 3\n\n// Create a function with a preset leading argument\nvar leadingThirtysevenList = list.bind(null, 37);\nvar list2 = leadingThirtysevenList(); // [37]\nvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n// Create a function with a preset first argument.\nvar addThirtySeven = addArguments.bind(null, 37); \nvar result2 = addThirtySeven(5); // 37 + 5 = 42 \nvar result3 = addThirtySeven(5, 10);// 37 + 5 = 42 , second argument is ignored\n\n```\n\n\n\n# with setTimeout()\n\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  // #POINT\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with '+ this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  \n// after 1 second, triggers the 'declare' method\n```\n","excerpt":"call() 정의 주어진 this 값, 전달된 인수 와 함께 함수를 호출 call()을 생성자 연결에 사용 function, method에 속해서 다른 객체를 호출한다. function, method에 this…","fields":{"slug":"/call(), apply(), bind()/"},"frontmatter":{"date":"Feb 02, 2020","title":"call(), apply(), bind()","tags":["javascript"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다\n\n# STEP\n* STEP1: 배열의 숫자형을 문자형으로 변환\n* STEP2: 문자형변환후 배열 요소를 자리를 바꿔가며 숫자 크기를 비교(문자열x)\n\n# code\n```js\nvar a = [3, 30, 34, 5, 9];\nvar b = [6, 10, 2];\n\nfunction solution(numbers) {\n    var answer = numbers.map(v => v + '')\n        .sort((a, b) => (b + a)* 1 - (a + b)*1)\n        .join('');\n\n    return answer[0] === '0' ? '0' : answer\n}\n```\n\n# 결과\n![](result.png)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다 STEP STEP…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 01, 2020","title":"배열로 조합할 수 있는 수중 가장 큰 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n상황에 따라서 달라지는 this를 정리해보려고 한다. \n```js\n03 this\n\t3-1 상황에 따라 달라지는 this\n\t\t3-1-1 전역 공간에서의 this\n\t\t3-1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n\t\t\t함수 vs 메서드\n\t\t\t메서드 내부에서의 this\n\t\t3-1-3 함수로서 호출할 때 그 함수 내부에서의 this\n\t\t\t함수 내부에서의 this\n\t\t\t메서드의 내부함수에서의 this\n\t\t\t메서드의 내부 함수에서의 this를 우회하는 방법\n\t\t\tthis를 바인딩하지 않는 함수\n\t\t3-1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n\t\t3-1-5 생성자 함수 내부에서의 this\n\t3-2 명시적으로 this를 바인딩하는 방법\n\t\t3-2-1 call 메서드\n\t\t3-2-2 apply 메서드\n\t\t3-2-3 call/apply 메서드의 활용\n\t\t\t유사배열객체에 배열 메서드를 적용\n\t\t\t생성자 내부에서 다른 생성자 호출\n\t\t\t여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n        3-2-4 bind 메서드\n            name 프로퍼티\n\t\t\t상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\t\t3-2-5 arrow function의 예외사항\n\t\t3-2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n```\n\n# this\n\n* 다른 객제지향 언어와 this의 차이점 \n    * 다른 대부분의 객체지향 언어의 this: 클래스로 생성한 인스턴스 객체\n        * 클래스에서만 사용할 수 있기 때문에 헷갈리지 않거나 많지 않음\n    * 자바스크립트 this: **어디에서나 쓸 수 있음**\n        * 상황에 따라 this가 바라보는 대상이 달라짐\n        * ***문제를 해결하려면 원인을 알아야 하는데, 정확한 작동방식을 이해하지 못하면 원인을 해결하기 어려움***\n\n* this 확인으로 '함수, 객체(메서드)'의 구분할 수 있는 거의 유일한 방법\n\n# 3-1 상황에 따라 달라지는 this\n> this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정(실행컨텍스트 설명할때 설명됨)  \n> 아래 상황별로 this가 5가지 다른 값을 보여주는 내용을 설명\n\n## 3-1-1 전역 공간에서의 this\n> 전역 공간에서 this는 전역객체를 가리킨다. \n\n* 전역 변수와 전역객체\n    ```js\n    var a = 1;\n    console.log(a);         //1\n    console.log(window.a);  //1\n    console.log(this.a);    //1\n    ```\n* 위 결과 값이 같은이유는? \n    * 전역변수 선언시 javascrip engine이 전역객체의 프로퍼티로 할당\n    * javascript 모든 변수는 특정 객체의 프로퍼티로 등록되고 동작\n        * 특정객체: 실행컨텍스트의 LexicalEnvironment\n        * 전역컨텍스트의 경우 LexicalEnvironment는 전역객체를 그대로 참조(실행컨텍스트 도식화 그림 참고\n* 전역 변수를 접근하는 과정은? -> scope chain\n    * a에 접근하고자 하면 스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 '전역 스코프'의 LexcialEnvironment(전역객체)에서 해당 프로퍼티를 a를 발견해서 그 값을 반환하기 때문\n\n\n---\n* 전역변수와 전역객체의 차이점\n    * 전역객체의 프로퍼티로 할당한 경우에서는 삭제 o\n    * 전역변수로 선언한 경우에는 삭제 x\n\n        ```js\n        var b = 2;\n        delete b;   //false\n        console.log(b, window.b, this.b) //2 2 2\n\n        window.c = 3;\n        delete window.c;    //true\n        console.log(c, window.c this.c); // Uncaught ReferenceError: c is not defined\n        \n        ```\n\n\n## 3-1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n### 함수 vs 메서드\n* 함수 호출시 this: 전역객체\n* 메서드로 호출시 this: 호출한 메서드\n    ```js\n    // 함수로서 호출\n    var obj = {\n    bar: function() {\n        var x = (function(){\n                    return this\n                })();\n        return x;\n    }\n    };\n\n    obj.bar() === window //true\n\n\n\n    // 메서드로서 호출\n    var obj = {\n    bar: function() {\n        var x = (() => this)(); // 주의: use arrow funciton\n        return x;\n    }\n    };\n\n    obj.bar() === obj\t//true\n\n    ```\n\n## 3-1-3 함수로서 호출할 때 그 함수 내부에서의 this\n### 함수 내부에서의 this\n* this에는 호출한 주체 정보가 담기는데 어떤 함수를 함수로서 호출시 this 지정 안됨\n* 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.\n* **실행 컨텍스트가 지정되지 않은 경우 this는 전역 객체를 바라본다 -> 따라서 함수에서 this는 전역객체를 가리킨다.** \n\n### 메서드의 내부함수에서의 this\n* 실행순서1,2,3의 return value\n    - 실행순서1: {outer: f, outer2: f} === obj1\n    - 실행순서2: window{...}\n    - 실행순서3: {obj2Property: \"obj2Property\", innerMethod: ƒ}\n\n* POINT\n    - innerFunc에 console.log는 B, C에 의해서 호출이 되는데  \n    - B처럼 innerFunc이 함수로 호출될때는 this는 전역 변수를 가르킨다.\n    - C처럼 innerfunc이 메서도로 호출될때는 this는 호출한 대상을 가르킨다.\n        ```js\n        var obj1 = {\n            outer: function() {\n                console.log(this);  //실행순서 1 by A\n                var innerFunc = function(){\n                    console.log(this);  //실행순서 2 by B, 3 by C\n                }\n                innerFunc(); // B\n\n                var obj2 = {\n                    innerMethod: innerFunc,\n                    obj2Property: 'obj2Property' \n                };\n                obj2.innerMethod(); // C\n            },\n\n            outer2: function(){\n\n            }\n        };\n\n        obj1.outer(); // A\n        ```\n\n### 메서드의 내부 함수에서의 this를 우회하는 방법\n### this를 바인딩하지 않는 함수\n> 아래 예제 주석 참고\n* log 결과값\n    * [1]: {outer: f}\n    * [2]: window {...}\n    * [3]: {outer: f}\n    * [4]: window {...}\n    * [5]: {outer: f}\n    ```js\n    var obj1 = {\n        outer: function() {\n            console.log(this);  // [1]\n            var innerFunc = function(){\n                console.log(this); // [2]\n            }\n            innerFunc(); \n\n            var me = this;\n            var innerFunc2 = function(){\n                console.log(me);    // [3] 메서드의 내부 함수에서의 this를 우회하는 방법\n                console.log(this);  // [4]\n            }\n            innerFunc2(); \n\n            var innerFunc3 = () => {\n                console.log(this);  // [5] this를 바인딩하지 않는 함수\n            }\n            innerFunc3();\n\n        }\n    };\n\n    obj1.outer(); \n    ```\n\n\n\n## 3-1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n* callback function의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정\n* 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.\n\n    ```js\n    setTimeout(function(){\n        console.log(this);\n    }, 3000);\n\n    [1,2,3].forEach(function(v){\n        console.log(this, v);\n    })\n\n    document.body.innerHTML += `<button id=\"a\"> 클릭 </button>`\n    document.body.querySelector('#a').addEventListener('click', function(e){\n        console.log(this, e);\n    })\n\n    ```\n* event Callback function 참고\n![](eventCallbackfunction.png)\n\n\n\n* addEventListner function 내부 추측 \n    - addEventListner function this가 'document.body.querySelector('#a')' 이기 때문에  \n    이 값을 callback function을 call메서드를 이용해 명시적으로 this바인딩 할 수 있겠다.\n\n        ```js\n            addEventListener: function(a, callbackFunc){\n                ...\n                callbackFunc.call(this, event);\n                ...\n            }\n        ```\n\n## 3-1-5 생성자 함수 내부에서의 this\n> 생성자 함수에서 this는 생성될 인스턴스를 참조\n\n```js\nvar Dog = function(name, age) {\n    this.bark = 'RRRR';\n    this.name = name;\n    this.age = age;\n};\n\nvar hs = new Dog('행성', 2);\nvar girl = new Dog('소녀', 3);\nvar universe = new Dog('우주', 1);\n\nconsole.log(hs, girl, universe);\n/*\nhs: Dog {bark: \"RRRR\", name: \"행성\", age: 2}\ngirl: Dog {bark: \"RRRR\", name: \"소녀\", age: 3}\nuniverse: Dog {bark: \"RRRR\", name: \"우주\", age: 1}\n*/\n```\n\n# 3-2 명시적으로 this를 바인딩하는 방법\n> 이 목차는 call(), apply(), bind()에서 따로 설명하도록한다.\n## 3-2-1 call 메서드\n## 3-2-2 apply 메서드\n## 3-2-3 call/apply 메서드의 활용\n### 유사배열객체에 배열 메서드를 적용\n### 생성자 내부에서 다른 생성자 호출\n### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n## 3-2-4 bind 메서드\n### name 프로퍼티\n### 상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\n```js\nvar obj ={\n    outer: function(){\n        console.log(this);               //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);           //{outer: ƒ, outer2: ƒ}\n        }\n        innerFunc.call(this);       //POINT\n    },\n\n    outer2: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          //{outer: ƒ, outer2: ƒ}\n        }.bind(this);               //POINT\n        innerFunc();\n    },\n\n    outer3: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          // window{...}\n        }                            //POINT\n        innerFunc();\n    }\n}\n\nobj.outer();\nobj.outer2();\nobj.outer3();\n\n```\n\n### 3-2-5 arrow function의 예외사항\n* this를 바인딩하지 않는 함수 목차 참고\n### 3-2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n``` js\nvar report = {\n    sum: 0,\n    count: 0,\n    add: function() {\n        var args = Array.prototype.slice.call(arguments);\n        args.forEach(function(entry){\n            this.sum += entry;\n            ++this.count;\n        }, this);       //POINT\n    },\n    average: function(){\n        return this.sum / this.count;\n    }\n}\n\nreport.add( 10, 20, 30 );\nconsole.log({sum: report.sum, count: report.count, average: report.average()});\n//{sum: 60, count: 3, average: 20}\n```\n\n* 콜백함수와 함께 thisArg를 인자로 받는 메서드 \n    ```js\n    Array.prototype.forEach(callback[, thisArg]);\n    Array.prototype.map(callback[, thisArg]);\n    Array.prototype.filter(callback[, thisArg]);\n    Array.prototype.some(callback[, thisArg]);\n    Array.prototype.every(callback[, thisArg]);\n    Array.prototype.find(callback[, thisArg]);\n    Array.prototype.findIndex(callback[, thisArg]);\n    Array.prototype.flatMap(callback[, thisArg]);\n    Array.prototype.from(callback[, thisArg]);\n    Set.prototype.forEach(callback[, thisArg]);\n    Map.prototype.forEach(callback[, thisArg]);\n    ```\n","excerpt":"상황에 따라서 달라지는 this를 정리해보려고 한다.  this 다른 객제지향 언어와 this의 차이점  다른 대부분의 객체지향 언어의 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Feb 01, 2020","title":"This","tags":["javascript"]}}},{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["javascript","event"]}}},{"node":{"rawMarkdownBody":"\n개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다.\n\n\n```js\n02 실행 컨텍스트 \n\t2-1 실행 컨텍스트란? \n\t2-2 VariableEnvironment\n\t2-3 LexicalEnvironment\n\t\t2-3-1 environmentRecord와 hoisting\n            호이스팅 규칙  \n            함수 선언문과 함수 표현식\n      \n\t\t2-3-2 scope, scope chain, outerEnvironmentReference\n            스코프 체인\n            전역변수와 지역변수\n\n\t2-4 this\n```\n\n\n\n# 02 실행 컨텍스트 \n> * 실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> * 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념  \n> * 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(=호이스팅), 외부환경정보를 구성, this값을 설정  하는 동작 수행    \n-> 이로인해 다른언어에서는 발견할 수 없는 특이한 현상들이 발생\n\n# 2-1 실행 컨텍스트란? \n> 실행할 코드에 제공할 환경 정보들을 모아놓은 객체\n\n* 코드 실행시 실행 컨텍스트\n    - '동일한 환경'에 있느 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 \n    - 이를 콜 스택에 쌓아올렸다가\n    - 가장 위에 쌓여있는 컨텍스트와 관련 잇는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장\n\n* '동일한 환경'(하나의 실행 컨텍스트)을 구성할 수 있는 방법\n    - 전역공간, evan()함수, 함수 등이 있음\n    - eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것\n\n* javascript engine 역할\n  - 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 '필요한 환경정보들'을 수집해서 실행 컨텍스트 객체에 저장\n  - 이 객체는 javascript engine이 활용할 목적으로 생성(개발자가 코드를 통해 확인할 수 x)  \n  - 담기는 정보 세가지  \n    : 목차 2-2, 2-3, 2-4에서 각각 더 자세하게 설명하도록 한다. \n  ```txt\n    VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. \n                            : 선언 시점의 LexicalEnvironment의 스냅샷 \n                            : 변경 사항은 반영되지 않음\n    LexicalEnvironment  : 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영\n    ThisBinding         : this 식별자가 바라봐야 할 객체\n  ```\n\n* 활성화된 실행 컨텍스트의 수집정보\n\n``` \n  * inner \n      Variableenvironment : environmentRecord(snapshot)/ outerEnvironmentReferenece(snapshot)\n      LexicalEnvironment  : environmentRecord/ outerenvironmentReferenece\n      ThisBindding\n  * outer\n  * 전역 컨텍스트\n```\n  \n# 2-2 VariableEnvironment\n* LexicalEnvironment와 같지만 최초 실행 시의 스탭 샷을 유지한다는점이 다름\n* 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음,  \n  이를 그대로 복사해서 Lexical environment를 만들어  LexicalEnvironment를 주로 활용하게 된다.\n* Variableenvironment, LexicalEnvironment의 내부는 **environmentRecord와 outerEnvironmentReference**로 구성\n  - 초기화 과정 중에는 사실상 완전히 동일, 이후 코드 진행에 따라 서로 달라짐\n  - 자세한 내용은 LexicalEnvironment를 통해 설명\n\n# 2-3 LexicalEnvironment\n* 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것 \n\n## 2-3-1 environmentRecord와 hoisting\n* js engine은 컨텍스트 내부 전체를 처음부터 쭉 훑어나가며 순서대로 수집 = \"호이스팅 개념\"  \n(= 식별자들을 최상단으로 끌어올려놓은 다음 실제코드를 실행-실제로 끌어 올리는 것이 아님, 편의상 끌어올린것으로 간주-)\n  - 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태\n  - 코드가 실행되기 전임에도 불구하고 js engine은 이미 해당 환경에 속한 코드의 변수명들으 모두 알고 있게 된다.\n                                                                \n### 호이스팅 규칙\n* environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다\n* 예시\n  * 함수 선언문으로 선언한 함수는 hoisting 대상\n  * 함수 표현식은 hosisting 대상 x\n\n  ```js\n  function a(){\n      console.log(b);   //ƒ b() {}\n      var b; \n      console.log(b);   //ƒ b() {}\n      function b() {};  //함수 선언문\n      console.log(b);   //ƒ b() {}\n\n      console.log(c);   //undefined\n      var c = function() {}\n  }\n  ```\n\n\n\n### 함수 선언문과 함수 표현식\n* 함수를 정의하는 세가지 방식\n  * 함수 선언문: 반드시 함수명이 정의 돼 있어야 함/ hoisiting이 됨\n  * 함수 표현식: 함수명이 없어도 됨           / hoisiting이 안 됨\n  * 기명 함수 표현식: 함수명을 정의한 함수 표현식\n\n```js\nfunction a() {} //함수 선언문\na();\n\n//상대적으로 긴 코드 속에서 함수 표현식이 안전한다.\nvar b = function() {} //(익명) 함수 표현식\nb();\n\nvar c = function d() {} // 기명 함수 표현식. 변수명: c, 함수명 d\nc(); // 실행\nd(); // error\n\n```\n\n## 2-3-2 scope, scope chain, outerEnvironmentReference\n* scope: 식별자에 대한 유표범위\n  * ES5까지의 자바스크립트는 특이하게도 전역 공간을 제외하면 오직 함수에 의해서만 스코프가 생성\n* scope chain: 이런 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것\n* outerEnvironmentReference: 스코프체인을 가능하게 하는 것이 바로 Lexicalenvironment의 두번째 수집자료인 outerEnvironmentReferenece\n\n### scope chain\n* outerEnvironmentReferenece는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조\n  - 아래 예시1 scopechain 도식화 참고\n* 과거 시점인 '선언될 당시'는 행위가 실제로 일어 날 수 있는 시점이란?  \n  - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐\n  - 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문\n\n* scope chain 예1\n  1. A함수 내부에 B함수 선언, B함수 내에 C함수 선언\n  2. 함수 C의 outerEnvironmentReferenece는 함수 B의 LexicalEnvironment를 참조 \n  3. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReferenece는 ***다시 함수 B가 선언되던 때*** A함수의 LexicalEnvironment를 참조 \n  4. 이처럼 outerEnvironmentReferenece는 연결리스트 형태를 띤다.\n  5. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것'  \n\n* 위 예시로본 특징 \n  - 예시 3번에서 본것 처럼 각 outerEnvironmentReferenece는 오직 자신이 선언된 시점의 LexicalEnvironment만 침조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능\n  - 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능** \n\n* scope chain 예1 코드\n```js\n/*01*/ var a = 1;\n/*02*/ var outer = function () {\n/*03*/   var inner = function () {\n/*04*/     console.log(a);\n/*05*/     var a = 3;\n/*06*/  };\n/*07*/   inner();\n/*08*/   console.log(a);\n/*09*/ };\n/*10*/ ouer();\n/*11*/ console.log(a);\n```\n* scope chaing 예1 코드 도식화\n    * 그림을 보면서 라인별로 어떤 동작을 하는지 생각해보자\n    ```\n      LE: Lexical Envinronment\n      e: environmentRecord\n      o: outerEnvironmentReference\n    ```\n    ![](context.jpeg)\n\n\n* **전역 컨텍스트 활성화**\n  * 0: LexicalEnvironment, VariableEnvironment, thisBinding\n\n* 전역 컨텍스트 생성/ outer 함수 호출\n  * 1,2: a에 1, outer에 함수 할당\n  * 10: outer 함수호출, 전역 컨텍스트 비활성화\n  * 2: outer실행 컨텍스트 활성화\n\n* outer 컨텍스트 생성/ inner 함수 호출\n  * 3: inner에 함수 할당\n  * 7: inner 함수 호출, outer 실행 컨텍스트 비활성화\n  * 3: inner 실행 컨텍스트 활성화 \n\n* inner 함수 수행\n  * 4: inner의 LE에서 a 탐색 -> undefined 출력\n  * 5: a에 3할당\n\n* inner 컨텍스트 종료 \n  * 6: inner 함수 종료, inner 실행 컨텍스트 제거\n  * 7: outer 실행 컨텍스트 재활성화\n  * 8: outer의 LE에서 a탐색 -> GLOBAL의 LE에서 a 탐색 -> 1출력\n\n* outer 컨텍스트 종료 \n  * 9: outer함수 종료, outer 실행 컨텍스트 제거 \n  * 10: 전역 컨텍스트 재활성화 \n  * 11: GLOBAL의 LE에서 a탐색 -> 1출력\n\n\n* outer컨텍스트 \n\n```js\n\"전역 컨텍스트\": {\n    environmentRecord: 'a, outer function',\n    outerEnvironmentReferenece: null,\n    this: window\n}\n\n\"outer컨텍스트\": {\n    environmentRecord: ['inner function'], \n    outerEnvironmentReferenece: 'GLOBAL LexicalEnvironment',\n    this: window\n}\n\n\"inner컨텍스트\": {\n    environmentRecord: ['a'], \n    outerEnvironmentReferenece: 'outer 컨텍스트',\n    this: window\n}\n```\n\n### 전역변수와 지역변수\n* 전역변수: 전역 공간에서 선언\n* 지역변수: 함수 내부에서 선언\n\n# 2-4 this\n* 실행컨텍스트의 thisBinding에 this로 지정된 객체가 저장\n* 실행컨텍스 활성 당시 this가 지정되지 않은경우 \"전역객체\" 저장\n* 함수 호출하는 방법에 따라 this가 달라진다.(this에 대해서만 내용을 다룰 예정)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n* 제로초 블로그\n","excerpt":"개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다. 02 실행 컨텍스트 실행컨텍스트(execution context…","fields":{"slug":"/Excute-context/"},"frontmatter":{"date":"Jan 24, 2020","title":"실행 컨텍스트","tags":["javascript"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6","set","filter","reduce"]}}},{"node":{"rawMarkdownBody":"\n# 계기\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 si 회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말 할 수 있는 아니였다..\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있었는데 저자의 연애인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴졌고 나는 떠먹기만 하면 되는 상황에서 정말 감사한 마음이 들었다. 그리고 정리된 내용을 보고 나서 업무를 하며 익혔던 내용을 다시 한번 생각해 보는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\nJavascript만의 특징을 알고 싶은 분이 있다면 추천해주고 싶은 책이다.\n\n\n","excerpt":"계기 이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 si 회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트/"},"frontmatter":{"date":"Jan 20, 2020","title":"코어자바스크립트 후기","tags":["javascript","독서후기"]}}}]}},"pageContext":{}}}