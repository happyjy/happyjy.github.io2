{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로\n\n```js\n\t1 콜백함수란?\n\t2 제어권\n\t\t2-1 호출시점\n\t\t2-2 인자\n\t\t2-3 this\n\t3 콜백 함수는 함수다\n\t4 콜백 함수 내부의 this에 다른 값 바인딩하기\n\t5 콜백 지옥과 비동기 제어\n```\n\n\n\n# 1 콜백함수란?\n> 다른 코드의 인자로 넘겨주는 함수(제어권도 함께 위임)\n> 콜백함수를 넘겨 받는 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행\n\n\n# 2 제어권\n> 호출시점, 인자, this 예제를 통해서 알아 보자\n## 2-1 호출시점\n> setInterval에 callback function은 '호출주체, 제어권'은 setInterval이다.\n```js\nvar count = 0;\nvar cbFunc = function() {\n    conosl.log(count);\n    if(++count > 3) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n```\n## 2-2 인자\n> 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.\n\n* callback function의 인자 값은 filter에 의해서 정해졌다.\n    ```js\n    var newArr = [1,2,3,4,5].filter(function(idx, val){\n        console.log({'this sceop': this, idx, val});\n        return val > 2;\n    }, {a:1, b:2});     // {a:1, b:2}코드에 대한 설명은 아래 2-3 this설명에서 알 수 있다.\n\n    console.log(newArr);    //[4,5]\n\n    /*\n        this sceop: {a: 1, b: 2}\n        idx: 1\n        val: 0\n        \n        this sceop: {a: 1, b: 2}\n        idx: 2\n        val: 1\n        \n        this sceop: {a: 1, b: 2}\n        idx: 3\n        val: 2\n        \n        this sceop: {a: 1, b: 2}\n        idx: 4\n        val: 3\n        \n        this sceop: {a: 1, b: 2}\n        idx: 5\n        val: 4\n    */\n    ```\n\n## 2-3 this\n\n* Array.prototype.map - 구현    \n    ```js\n    Array.prototype.filter = function(callback, thisArg){\n        var mappedArr = [];\n        for(var i=0; i < this.length; i++){\n            var mappedValue = callback.call(thisArg || window, this[i], i , this);  //POINT\n        }\n    }\n    ```\n    * 주석 POINT 설명\n        * thisArg || window  \n            : callback function에서 this의 scope을 명시적으로 바인딩\n            : 이 코드에 의해 filter의 두번째 param으로 callback의 this를 정해줄 수 있다.\n            : 2-2인자 챕터 코드 참고하기\n        * this  \n            : filter를 호출 한 array(이 내용은 prototype과 관련해서 더 설명할 수 있겠다.)  \n        * this[i]  \n            : 이 코드에 의해서 callback function의 첫번째 param array의 i번째 요소\n        * i  \n            : 이 코드에 의해서 callback function의 두번째 param array의 i번째\n    \n# 3 콜백 함수는 함수다\n* 메서드를 콜백함수로 전달한 경우\n    ```js\n    var obj = {\n        vals: [1,2,3],\n        logValues: function(v, i){\n            console.log(this, v, i);\n        }\n    }\n    \n    obj.logValues(10,20); //{vals: Array(3), logValues: f} 10 20\n\n    [10,20,30].forEach(obj.logValues);\n    /*\n        Window{...} 10 0\n        Window{...} 20 1\n        Window{...} 30 2    \n    */\n    ```\n    * forEach의 callback function은 코드에 의해서 호출된 logValues에서 this는 Window를 가르키고 있다.\n        - callback function으로 obj 객체에 의해서 this가 결정되지 않고 별도로 this를 명시하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 가르친다.\n        \n# 4 콜백 함수 내부의 this에 다른 값 바인딩하기\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (1/3)\n    ```js\n    var obj1 = {\n        name: 'obj1',\n        func: function() {\n            var me = this;             //POINT\n            return function(){\n                console.log(me.name);\n            };\n        }\n    };\n    var callback = obj1.func();\n    setTimeout(callback, 1000);\n    ```\n    * var me = this;는 closure scope에 등록\n    * setTimeout에 의해서 callback function이 호출 될때 me.name은 excute context에서 me.name 변수를 찾는다.\n    ![callback & scope & clousre](callback&scope&closure.png)\n\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (2/3)\n    * 예제1에서 만들었던 함수 재활용하는 방법 - cb2 확인해보자\n    ```js\n        var obj1 = {\n            name: 'obj1',\n            func: function() {\n                var me = this;              //POINT: closure\n                return function(){\n                    console.log(me.name);\n                };\n            }\n        };\n\n        var obj2 = {\n            name: 'obj2',\n            func: obj1.func\n        };\n\n        var cb1 = obj1.func().bind('cb1');\n        setTimeout(cb1, 1000);\n\n        var cb2 = obj2.func().bind('cb2');\n        setTimeout(cb2, 1500);\n\n        var obj3 = { name: 'obj3' }\n        var cb3 = obj1.func.call(obj3);        //POINT: obj1.func = function(){ var me this; return function(p1){ console.log() }} \n        setTimeout(cb3, 2000);\n\n        /*\n            # 결과\n                * cb1: undefined \"obj1\" \"callback1\"\n                * cb2: undefined \"obj2\" \"callback2\"\n                * cb3: obj3 obj1 callback3\n        */\n    ```\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (3/3)\n    * bind로 this를 명시한 function을 사용\n        ```js\n        var obj1 = {\n                name: 'obj1',\n                func: function() {\n                    console.log(this.name)\n                }\n        };\n        \n        setTimeout(obj1.func.bind(obj1), 1000);\n\n        var obj2 = {name:'obj2'};\n        setTimeout(obj1.func.bind(obj2), 1500);\n\n        /*\n            # 결과\n                * obj1\n                * obj2\n        */\n        ```\n\n\n\n# 5 콜백 지옥과 비동기 제어\n> 콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상\n> 주로 이벤트 처리, 서버통신과 같은 비동기적인 작업을 수행하기 위해서 이런 형태가 등장\n\n* 동기적인 코드\n    - 현재 실행중인 코드가 완료된 후에야 다음 코드를 실행하는 방식\n* 비동기적인 코드\n    - 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다.\n    - CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드 \n* 비동기적인 코드가 필요한 경우   \n    : 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아졌다.\n    - 실행대기(setTimeout)  \n        : 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류\n    - 실행대기(addEventListener)  \n        : 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기\n    - 보류(XMLhttpRequest)  \n        : 웹브라우저 자체가 아닌 별도의 대상에 무어가를 요청하고 그에 대한 응답이 왔을때 비로소 어떤 함수를 실행하도록 대기","excerpt":"업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로…","fields":{"slug":"/callback/"},"frontmatter":{"date":"Feb 02, 2020","title":"callback function","tags":["javascript Core","javascript","callback"]}}},{"node":{"rawMarkdownBody":"\n```\n# 목차\n    * call() 정의\n    * call()을 생성자 연결에 사용\n    * call()을 익명함수와 함께 쓰기 \n    * call()호출시 this에 특정 값을 넣어 동작하기\n    * call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n    * call, apply함수의 비교(this에 특정 값 넣어 동작)\n    * bind()\n    * bind()함수 구현 해보기\n    * creating a bound function\n    * Partially applied functions\n    * with setTimeout()\n```\n\n# call() 정의\n> 주어진 this 값, 전달된 인수 와 함께 함수를 호출\n\n```js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\n\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n```\n\n# call()을 생성자 연결에 사용\n> function, method에 속해서 다른 객체를 호출한다.  \n> function, method에 this 값을 전해준다.  \n함수는 한번 쓰고 다른 객체에서 상속 받아 사용한다.(method를 다시 만들 필요 없이)\n``` js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price < 0) {\n    throw RangeError('Cannot create product ' +\n                      this.name + ' with a negative price');\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'food';\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'toy';\n}\n\nvar cheese = new Food('feta', 5);\nvar fun = new Toy('robot', 40);\n```\n\n\n# call()을 익명함수와 함께 쓰기 \n```js\nvar animals = [\n  { species: 'Lion', name: 'King' },\n  { species: 'Whale', name: 'Fail' }\n];\n\nfor (var i = 0; i < animals.length; i++) {\n  (function(i) {\n    this.print = function() {\n      console.log('#' + i + ' ' + this.species\n                  + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n//## 결과 \n//#0 Lion: Kinf\n//#1 Whale: Fail\n```\n\n# call()호출시 this에 특정 값을 넣어 동작하기\n> \n\n```js\nfunction greet() {\n  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n  console.log(reply);\n}\n\nvar obj = {\n  animal: 'cats', sleepDuration: '12 and 16 hours'\n};\n\ngreet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n# call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n> call로 호출될 function 안에 this의 bound는 global object이다  \n> 하지만 use stric을 사용 하용하면 undefined가 나온다. \n```js\nvar sData = 'Wisen';\n            \nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call();  // sData value is Wisen \n\n``` \n\n```js            \n'use strict';\n\nvar sData = 'Wisen';\n\nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call(); // Cannot read the property of 'sData' of undefined            \n```\n\n# call, apply함수의 비교(this에 특정 값 넣어 동작)\n```js\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.call(obj,\"Korea\",\"Seoul\"));\t\n//welcome to Korea in Seoul Jaeyoon\n\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.apply(obj,[\"Korea\",\"Seoul\"]));\t\t\n//welcome to Korea in Seoul Jaeyoon\n```\n\n\n\n\n\n\n# bind()\n> 함수와 객체를 서로 묶는 것이다.  \n> bind()함수는 새 함수를 반환한다.(call, apply는 바로 동작`)\n```js\nfunction f(y) { return this.x + y }    //바인드되어야 하는 함수\nvar o = {x:1};      //바인드될 객체\nvar g = f.bind(o);  //g(x)를 호출하면 o.f(x)가 호출된다.\ng(2)                //=>3\n```\n\n# bind()함수 구현 해보기 \n```js\nFunction.prototype.bind = function(obj){\n  //this와 인자 값을 변수에 저장함으로써 다음의 중첩 함수에서 사용할 수 있다.\n  var me = this, boundArgs = arguments;\n\n  //bind() 메서드의 반환 값은 함수다.\n  return function(){\n  //인자 목록을 작성하는데, 첫 번재 이후의 인자부터\n  //나머지 모든 인자를 이 함수에 전달 한다.\n  var args = [], i;\n  for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);\n  for(i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  \n  //인자들을 포함하여 obj의 메서드로 me를 호출한다.\n  return me.apply(obj, args);\n}\n```\n\n# creating a bound function\n\n```js\nthis.x = 9;    // this refers to global \"window\" object here in the browser\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nmodule.getX(); // return: 81 - The ufnction gets invoked at the module scope\nretrieveX();   // returns 9 - The function gets invoked at the global scope\n\n// Create a new function with 'this' bound to module\n// New programmers might confuse the global var x with module's property x\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n# Partially applied functions\n\n```js\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\nvar result1 = addArguments(1, 2); // 3\n\n// Create a function with a preset leading argument\nvar leadingThirtysevenList = list.bind(null, 37);\nvar list2 = leadingThirtysevenList(); // [37]\nvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n// Create a function with a preset first argument.\nvar addThirtySeven = addArguments.bind(null, 37); \nvar result2 = addThirtySeven(5); // 37 + 5 = 42 \nvar result3 = addThirtySeven(5, 10);// 37 + 5 = 42 , second argument is ignored\n\n```\n\n\n\n# with setTimeout()\n\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  // #POINT\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with '+ this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  \n// after 1 second, triggers the 'declare' method\n```\n","excerpt":"call() 정의 주어진 this 값, 전달된 인수 와 함께 함수를 호출 call()을 생성자 연결에 사용 function, method에 속해서 다른 객체를 호출한다. function, method에 this…","fields":{"slug":"/call(), apply(), bind()/"},"frontmatter":{"date":"Feb 02, 2020","title":"call(), apply(), bind()","tags":["javascript Core","javascript","call","apply","bind"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다\n\n# STEP\n* STEP1: 배열의 숫자형을 문자형으로 변환\n* STEP2: 문자형변환후 배열 요소를 자리를 바꿔가며 숫자 크기를 비교(문자열x)\n\n# code\n```js\nvar a = [3, 30, 34, 5, 9];\nvar b = [6, 10, 2];\n\nfunction solution(numbers) {\n    var answer = numbers.map(v => v + '')\n        .sort((a, b) => (b + a)* 1 - (a + b)*1)\n        .join('');\n\n    return answer[0] === '0' ? '0' : answer\n}\n```\n\n# 결과\n![](result.png)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다 STEP STEP…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 01, 2020","title":"배열로 조합할 수 있는 수중 가장 큰 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n상황에 따라서 달라지는 this를 정리해보려고 한다. \n```js\n    0 javascripot에서 this\n    1 상황에 따라 달라지는 this\n        1-1 전역 공간에서의 this\n        1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n            함수 vs 메서드\n            메서드 내부에서의 this\n        1-3 함수로서 호출할 때 그 함수 내부에서의 this\n            함수 내부에서의 this\n            메서드의 내부함수에서의 this\n            메서드의 내부 함수에서의 this를 우회하는 방법\n            this를 바인딩하지 않는 함수\n        1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n        1-5 생성자 함수 내부에서의 this\n    2 명시적으로 this를 바인딩하는 방법\n        2-1 call 메서드\n        2-2 apply 메서드\n        2-3 call/apply 메서드의 활용\n            유사배열객체에 배열 메서드를 적용\n            생성자 내부에서 다른 생성자 호출\n            여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n        2-4 bind 메서드\n            name 프로퍼티\n            상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n        2-5 arrow function의 예외사항\n        2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n```\n\n# javascripot에서 this\n* 다른 객제지향 언어와 this의 차이점 \n    * 다른 대부분의 객체지향 언어의 this: 클래스로 생성한 인스턴스 객체\n        * 클래스에서만 사용할 수 있기 때문에 헷갈리지 않거나 많지 않음\n    * 자바스크립트 this: **어디에서나 쓸 수 있음**\n        * 상황에 따라 this가 바라보는 대상이 달라짐\n        * ***문제를 해결하려면 원인을 알아야 하는데, 정확한 작동방식을 이해하지 못하면 원인을 해결하기 어려움***\n\n* this 확인으로 '함수, 객체(메서드)'의 구분할 수 있는 거의 유일한 방법\n\n# 1 상황에 따라 달라지는 this\n> this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정(실행컨텍스트 설명할때 설명됨)  \n> 아래 상황별로 this가 5가지 다른 값을 보여주는 내용을 설명\n\n## 1-1 전역 공간에서의 this\n> 전역 공간에서 this는 전역객체를 가리킨다. \n\n* 전역 변수와 전역객체\n    ```js\n    var a = 1;\n    console.log(a);         //1\n    console.log(window.a);  //1\n    console.log(this.a);    //1\n    ```\n* 위 결과 값이 같은이유는? \n    * 전역변수 선언시 javascrip engine이 전역객체의 프로퍼티로 할당\n    * javascript 모든 변수는 특정 객체의 프로퍼티로 등록되고 동작\n        * 특정객체: 실행컨텍스트의 LexicalEnvironment\n        * 전역컨텍스트의 경우 LexicalEnvironment는 전역객체를 그대로 참조(실행컨텍스트 도식화 그림 참고\n* 전역 변수를 접근하는 과정은? -> scope chain\n    * a에 접근하고자 하면 스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 '전역 스코프'의 LexcialEnvironment(전역객체)에서 해당 프로퍼티를 a를 발견해서 그 값을 반환하기 때문\n\n\n---\n* 전역변수와 전역객체의 차이점\n    * 전역객체의 프로퍼티로 할당한 경우에서는 삭제 o\n    * 전역변수로 선언한 경우에는 삭제 x\n\n        ```js\n        var b = 2;\n        delete b;   //false\n        console.log(b, window.b, this.b) //2 2 2\n\n        window.c = 3;\n        delete window.c;    //true\n        console.log(c, window.c this.c); // Uncaught ReferenceError: c is not defined\n        \n        ```\n\n\n## 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n### 함수 vs 메서드\n* 함수 호출시 this: 전역객체\n* 메서드로 호출시 this: 호출한 메서드\n    ```js\n    // 함수로서 호출\n    var obj = {\n        bar: function() {\n            var x = (function(){\n                        return this\n                    })();\n            return x;\n        }\n    };\n\n    obj.bar() === window //true\n\n\n\n    // 메서드로서 호출\n    var obj = {\n        bar: function() {\n            var x = (() => this)(); // 주의: use arrow funciton\n            return x;\n        }\n    };\n\n    obj.bar() === obj\t//true\n\n    ```\n\n## 1-3 함수로서 호출할 때 그 함수 내부에서의 this\n### 함수 내부에서의 this\n* this에는 호출한 주체 정보가 담기는데 어떤 함수를 함수로서 호출시 this 지정 안됨\n* 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.\n* **실행 컨텍스트가 지정되지 않은 경우 this는 전역 객체를 바라본다 -> 따라서 함수에서 this는 전역객체를 가리킨다.** \n\n### 메서드의 내부함수에서의 this\n* 실행순서1,2,3의 return value\n    - 실행순서1: {outer: f, outer2: f} === obj1\n    - 실행순서2: window{...}\n    - 실행순서3: {obj2Property: \"obj2Property\", innerMethod: ƒ}\n\n* POINT\n    - innerFunc에 console.log는 B, C에 의해서 호출이 되는데  \n    - B처럼 innerFunc이 함수로 호출될때는 this는 전역 변수를 가르킨다.\n    - C처럼 innerfunc이 메서도로 호출될때는 this는 호출한 대상을 가르킨다.\n        ```js\n        var obj1 = {\n            outer: function() {\n                console.log(this);  //실행순서 1 by A\n                var innerFunc = function(){\n                    console.log(this);  //실행순서 2 by B, 3 by C\n                }\n                innerFunc(); // B\n\n                var obj2 = {\n                    innerMethod: innerFunc,\n                    obj2Property: 'obj2Property' \n                };\n                obj2.innerMethod(); // C\n            },\n\n            outer2: function(){\n\n            }\n        };\n\n        obj1.outer(); // A\n        ```\n\n### 메서드의 내부 함수에서의 this를 우회하는 방법\n### this를 바인딩하지 않는 함수\n> 아래 예제 주석 참고\n* log 결과값\n    * [1]: {outer: f}\n    * [2]: window {...}\n    * [3]: {outer: f}\n    * [4]: window {...}\n    * [5]: {outer: f}\n\n    ```js\n    var obj1 = {\n        outer: function() {\n            console.log(this);  // [1]\n            var innerFunc = function(){\n                console.log(this); // [2]\n            }\n            innerFunc(); \n\n            var me = this;\n            var innerFunc2 = function(){\n                console.log(me);    // [3] POINT 메서드의 내부 함수에서의 this를 우회하는 방법\n                console.log(this);  // [4]\n            }\n            innerFunc2(); \n\n            var innerFunc3 = () => {\n                console.log(this);  // [5] POINT: this를 바인딩하지 않는 함수\n            }\n            innerFunc3();\n\n        }\n    };\n\n    obj1.outer(); \n    ```\n\n\n\n## 1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n* callback function의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정\n* 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.\n\n    ```js\n    setTimeout(function(){\n        console.log(this);\n    }, 3000);\n\n    [1,2,3].forEach(function(v){\n        console.log(this, v);\n    })\n\n    //event Callback function 참고\n    document.body.innerHTML += `<button id=\"a\"> 클릭 </button>`\n    document.body.querySelector('#a').addEventListener('click', function(e){\n        console.log(this, e);\n    })\n\n    ```\n    * id='a' dom과 button click event Callback function의 this 비교\n    ![](eventCallbackfunction.png)\n\n\n\n* addEventListner function 내부 구현 추측 \n    - addEventListner function this가 'document.body.querySelector('#a')' 이기 때문에  \n    이 값을 callback function을 call메서드를 이용해 명시적으로 this바인딩 할 수 있겠다.\n\n        ```js\n            addEventListener: function(a, callbackFunc){\n                ...\n                callbackFunc.call(this, event);\n                ...\n            }\n        ```\n\n## 1-5 생성자 함수 내부에서의 this\n> 생성자 함수에서 this는 생성될 인스턴스를 참조\n\n```js\nvar Dog = function(name, age) {\n    this.bark = 'RRRR';\n    this.name = name;\n    this.age = age;\n};\n\nvar hs = new Dog('행성', 2);\nvar girl = new Dog('소녀', 3);\nvar universe = new Dog('우주', 1);\n\nconsole.log(hs, girl, universe);\n/*\nhs: Dog {bark: \"RRRR\", name: \"행성\", age: 2}\ngirl: Dog {bark: \"RRRR\", name: \"소녀\", age: 3}\nuniverse: Dog {bark: \"RRRR\", name: \"우주\", age: 1}\n*/\n```\n\n# 2 명시적으로 this를 바인딩하는 방법\n> 2 이 목차는 call(), apply(), bind()에서 따로 설명하도록한다.\n## 2-1 call 메서드\n## 2-2 apply 메서드\n## 2-3 call/apply 메서드의 활용\n### 유사배열객체에 배열 메서드를 적용\n### 생성자 내부에서 다른 생성자 호출\n### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n## 2-4 bind 메서드\n### name 프로퍼티\n### 상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\n```js\nvar obj ={\n    outer: function(){\n        console.log(this);               //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);           //{outer: ƒ, outer2: ƒ}\n        }\n        innerFunc.call(this);       //POINT\n    },\n\n    outer2: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          //{outer: ƒ, outer2: ƒ}\n        }.bind(this);               //POINT\n        innerFunc();\n    },\n\n    outer3: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          // window{...}\n        }                            //POINT\n        innerFunc();\n    }\n}\n\nobj.outer();\nobj.outer2();\nobj.outer3();\n\n```\n\n### 2-5 arrow function의 예외사항\n* this를 바인딩하지 않는 함수 목차 참고\n### 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n\n    ``` js\n    var report = {\n        sum: 0,\n        count: 0,\n        add: function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.forEach(function(entry){\n                this.sum += entry;\n                ++this.count;\n            }, this);       //POINT\n        },\n        average: function(){\n            return this.sum / this.count;\n        }\n    }\n\n    report.add( 10, 20, 30 );\n    console.log({sum: report.sum, count: report.count, average: report.average()});\n    //{sum: 60, count: 3, average: 20}\n    ```\n\n* 콜백함수와 함께 thisArg를 인자로 받는 메서드\n```js\n    Array.prototype.forEach(callback[, thisArg]);\n    Array.prototype.map(callback[, thisArg]);\n    Array.prototype.filter(callback[, thisArg]);\n    Array.prototype.some(callback[, thisArg]);\n    Array.prototype.every(callback[, thisArg]);\n    Array.prototype.find(callback[, thisArg]);\n    Array.prototype.findIndex(callback[, thisArg]);\n    Array.prototype.flatMap(callback[, thisArg]);\n    Array.prototype.from(callback[, thisArg]);\n    Set.prototype.forEach(callback[, thisArg]);\n    Map.prototype.forEach(callback[, thisArg]);\n```\n","excerpt":"상황에 따라서 달라지는 this를 정리해보려고 한다.  javascripot에서 this 다른 객제지향 언어와 this의 차이점  다른 대부분의 객체지향 언어의 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Feb 01, 2020","title":"this","tags":["javascript Core","javascript","this"]}}},{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["javascript","event"]}}},{"node":{"rawMarkdownBody":"\njavascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자. \n\n\n```js\n\t1 프로토타입의 개념 이해 \n\t\t1-1 constructor, prototype, instance\n\t\t1-2 constructor 프로퍼티\n\t2 프로토타입 체인\n\t\t2-1 메서드 오버라이드\n\t\t2-2 프로토타입 체인\n\t\t2-3 객체 전용 메서드의 예외사항\n\t\t2-4 다중 프로토타입 체인\n```\n\n# 1 프로토타입의 개념 이해 \n# 1-1 Constructor, prototype, instance\n\n* Constructor\n    - A function that initializes an object\n    - similar to normal javaconstuctor\n* prototype\n    - Constructor의 property\n    - instance의 property \\_\\_proto__과 메모리 공유  \n    : constructor.prototype === instance.\\_\\_proto__\n* instance\n    - Constructor를 new키워드로 호출로 생성한 객체\n\n* prototype 도식\n    ![](프로토타입도식.jpg)\n    * 왼쪽 꼭짓점: Constructor(생성자 함수)\n    * 오른쪽 꼭짓점: Constructor.prorotype 프로퍼티\n    * new를 통해 instance 생성\n    * instance.\\_\\_proto__\n\n* 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출하면\n    * Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성됩니다.\n    * 이때 instance에는 \\_\\_proto__라는 프포퍼티가 자동으로 부여\n    * 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조\n\n* prototype 개념의 핵심: prototype 프로퍼티, \\_\\_proto__라는 프로퍼티\n    * **prototype은 객체**\n    * **이를 참조하는 \\_\\_proto__도 객체**\n    * prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장\n    * 그러면 인스턴스에서도 숨겨진 프로퍼티인 \\_\\_proto__를 통해서 이 메서들을 접근할 수 있게 된다.\n\n    ```js\n    var Person = function(name) {\n        this._name = name;\n    }\n\n    Person.prototype.getName = function(){\n        debugger;\n        return this._name;\n    }\n\n    //---\n    typeof Person                   // function\n    typeof new Person('boa');       // object\n    new Person('boa');              // Person {_name: 'boa'}\n    new Person('boa').__proto__     // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    Person.prototype                // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    //---\n    \n    var boa = new Person('boa');\n    boa.__proto__.getName();    //undefined\n    boa.getName();              //boa\n    /*\n        boa.__proto__에 _name 프로퍼티가 없어 식별자(this._name)를 찾을 수 없다.\n        * boa.__proto__.getName();, boa.getName(); \n            - getName이 호출 돼 scope에 있는 this가 서로 다르다. 그래서 결과 값이 다르다.\n            - boa.__proto__ this -> {getName: f, constructor: f}\n            - boa this ->  Person {_name: 'boa'} \n\n    */\n\n    Person.prototype === boa.__proto__;\n    /*\n        Constructor function의 prototype으로 생성한 instnace 'boa'의 property '__proto__'객체는 Consytructor function의 객체는 메모리를 공유하고 있다.\n\n        이런 특징으로 \n        instance.__proto__ property를 변경하면 Constructor.prototype도 변경이 된다.\n        즉 instance.__proto__, Constructor.prototype 객체는 메모리를 공유하고 있따. \n    */\n\n    var boa = new Person('boa');\n    boa.__proto__._name = 'boa.__proto__';\n    boa.__proto__.getName() =               //Boa__proto__\n    /*\n        * boa.__proto__.getName() 에 의해서 호출된 getName의 this는 boa.__proto__\n        * \n    */\n\n    //---\n    \n    var iu = new Person('iu');\n    iu.getName(); // iu\n    \n    /*\n        iu.__proto__.getName \n        = iu(.__proto__).getName\n        = iu.getName\n    */\n\n\n    //---\n\n    var Constructor = function(name) {\n        this.name = name;\n        console.log(this);\n    }\n\n    Constructor.prototype.method = function(){};\n    Constructor.prototype.prototype1 = 'constructor Prototype property';\n\n    var instance = new Constructor('INSTANCE');\n    console.dir(Constructor);\n    console.dir(instance);\n    /*\n        Constructor.prototype === instance.__proto__\n    */\n\n\n    //--\n    var arr = [1,2];\n    console.dir(arr);\n    console.dir(Array);     //Array: 내장 생성자 함수\n\n    arr.forEach(function(){});  //\n    Array.isArray(arr);         //true\n    arr.isArray()               //TypeError: arr.isArray is not a function\n\n\n    ```\n\n# 1-2 constructor 프로퍼티\n\n```js\n    var arr = [1,2];\n    Array.prototype.constructor === Array;\n    arr.__proto__.constructor === Array;\n    arr.constructor === Array;\n\n    var arr2 = new arr.constructor(3,4);\n    console.log(arr2) //[3,4]\n```\n\n\n```js\nvar Person = function(name){\n    this.name = name;\n}\n\nvar p1 = new Person('인간1');                           //Person {name:\"인간1\"} true\nvar p1Proto = Object.getPrototypeOf(p1);\n\nvar p2 = new Person.prototype.constructor('인간2');     //Person {name:\"인간2\"} true\nvar p3 = new p1Proto.constructor('인간3');              //Person {name:\"인간3\"} true\nvar p4 = new p1.__proto__.constructor('인간4');         //Person {name:\"인간4\"} true\nvar p5 = new p1.constructor('인간5');                   //Person {name:\"인간5\"} true\n\n[p1, p2, p3, p4, p5].forEach(function(p){\n    console.log(p, p instanceof Person);\n})\n\n[constructor]\n[instance].__proto__.constructor\n[instance].constructor\nObject.getPrototypeOf([instance]).constructor\n[Contsructor].prototype.constructor\n\n[Constructor]\n[instance].__proto__\n[instance]\nObject.getPrototypeOf([instance])\n\n```\n\n# 2 프로토타입 체인\n\n# 2-1 메서드 오버라이드\n\n* 예제 \n    - 아래 메서드 오버라이드 전, 후 캡쳐 참고\n        ```js\n        var Person = function(name){\n            this.name = name;\n        }\n        Person.prototype.getName = function(){\n            return this.name;\n        }\n\n        var boa = new Person('보아');\n        boa.getName = function(){\n            return '이 사람은 ' + this.name;\n        };\n\n        console.log(boa);               // Person {name: \"보아\", getName: ƒ}\n        console.log(boa.getName());     // 이 사람은 보아\n\n        console.log(boa.__proto__.getNam());    // undefined\n        Person.prototype.name = '권보아';\n        console.log(boa.__proto__);             // {name: \"권보아\", getName: ƒ, constructor: ƒ}\n        console.log(boa.__proto__.getName());   // 이사람은 권보아\n        console.log(boa.__proto__.getName.call(boa));   // this를 명시적으로 선언\n        /*\n            메서드가 오버라이드된 경우에는 자신으로부터 가장 가까운 메서드에만 접근\n            그다음으로 가까운 __proto__의 메서드도 우회적인 방법을 통해서 접근 가능\n        */ \n        ```\n* 결과\n    - override 하기 전\n    ![](method_override.png)\n    \n                             \n    - override 후\n    \n    ![](method_override1.png)\n\n# 2-2 프로토타입 체인\n* Object의 내부 구조\n\n![](prototypeOfObject.png)\n\n* Array의 내부 구조\n![](prototypeOfArray.png)\n\n\n* Array 내부 도식화\n![](Array내부도식화.jpg)\n    - [1,2]는 Array.prototype, Object.prototype내부의 메서드를 자신의 것처럼 실행 할 수 있다. \n    - .\\_\\_proto__는 생략 가능하다\n    - 예시\n\n        ```js\n        var arr = [1,2];\n        arr(.__proto__).push(3);                            //3\n        arr(.__proto__)(.__proto__).hasOwnProperty(2);      //true\n        ```\n\n* 메서드 오버라이드와 프로토타입 체이닝\n\n```js\nvar arr = [1,2,3];\nArray.prototype.toString.call(arr);     //1,2,3\nObject.prototype.toString.call(arr);    //[object Array]\narr.toString();                         //1,2,3\n\narr.toString = function(){      //결과 아래 캡쳐 참고 \n    return this.join('_');\n};\narr.toString();                         //1_2_3\n```\n\n* arr 객체에 toString function 추가시 arr객체 내부\n\n    ![](Array객체에toString추가.png)\n\n\n# 2-3 객체 전용 메서드의 예외사항\n\n* Object.prototyp에 추가한 메서드의 접근\n    ```js\n    Object.prototype.getEntries = function(){\n        var res = [];\n        for (var prop in this){\n            if(this.hasOwnProperty(prop)){\n                res.push([prop, this[prop]]);\n            }\n        }\n        return res;\n    }\n\n    var data = [\n        ['object', {a: 1, b: 2, c:3}],\n        ['number', 345],\n        ['string', 'abc'], \n        ['boolean', false],\n        ['func', function(){}],\n        ['array', [1,2,3,4]]\n    ];\n\n    data.forEach(function(d){\n        console.log(d[1].getEntries());\n    })\n\n    ```\n    - 어떤 데이터 타입이건 거의 무조건 프로토타입 체이닝을 통해 getEntries 메서드에 접근 \n\n\n* 스태틱 메서드(객체한정메서드)\n    - 객체만을 대상으로 동작하는 객체 전용메서드들은 부득이 Object.prototype이 아닌 Object에 스태틱 메서드(static method)로 부여할 수 밖에 없다.\n    - 생성자 함수인 Object, 인스턴스 객체 리터럴 사이에는 this를 통한 연결이 불가능\n    - 전용 메서드 처럼 '메서드명 앞의 대상이 곧 this'가 되는 방식대신  \n    this의 사용을 포기하고 대상 **인스턴스를 인자로 직접 주입해야 하는 방식**으로 구현  \n    : 예시 Object.freeze({prop: 42})\n    - Object.prototype.consructor 하위 메서드 & Object.protptype 하위 메서드\n     ![](객체전용메서드&스태틱메서드.jpg)\n\n# 2-4 다중 프로토타입 체인\n* 새롭게 만드는 생성자 함수에 \\_\\_proto__를 연결해서 체인 관계를 만들수 있다.\n\n* Grade 생성자 함수와 인스턴스\n    ```js\n    var Grade = function(){\n        //arguments: 유사배열\n        var args = Array.prototype.slice.call(arguments);\n        for(var i=0; i<args.length; i++){\n            this[i] = args[i];\n        }\n        this.length = args.length;\n    }\n    var g = new Grade(100, 80);\n\n    Grade.prototype = [];   //POINT\n\n    var g1 = new Grade(10, 20);\n    g1.push(1);\n    console.log(g1);    //Grade(3) [10, 20, 1]\n    g1.shift()\n    console.log(g1);    //Grade(3) [20, 1]\n\n    ```\n    - 도식화 \n    ![](Grade생성자함수에배열proto.jpg)\n","excerpt":"javascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자.  1 프로토타입의 개념 이해 1-…","fields":{"slug":"/prototype/"},"frontmatter":{"date":"Jan 24, 2020","title":"closure","tags":["javascript Core","javascript","prototype"]}}},{"node":{"rawMarkdownBody":"\n업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다. \n\n\n```js\n\t1 클로저의 의미 및 원리 이해\n\t2 클로저와 메모리 관리\n\t3 클로저 활용사례\n\t\t3-1 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 \n\t\t3-2 접근 권한 제어(정보 은닉)\n\t\t3-3 부분 적용함수\n\t\t3-4 커링함수\n```\n\n\n# 1 클로저의 의미 및 원리 이해\n\n\n* 클로저란?  \n  : 함수형 프로그래밍 언어에서 등장하는 특징\n    > 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 **실행 컨텍스트가 종료된 이후에도 변수a가 사라지지 안는 현상**\n    > 내부함수를 외부로 전달하는 방법: 함수를 return하는 경우, callback으로 전달\n    - mdn 설명\n    > A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).  \n    > In other words, a closure gives you access to an outer function’s scope from an inner function. \n    > In JavaScript, closures are created every time a function is created, at function creation time.\n    \n\n* 외무 함수의 변수를 참조하는 내부 함수(1)\n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    outer();\n    ```\n    * inner함수 내부에서는 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 a를 찾는다. \n    * outer함수의 실행 컨텍스트가 종료되면 LexicalEnvironmentReference에 저장된 식별자들(c, inner)에 대한 참조를 지운다. \n        - 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 **컬렉터의 수집 대상**이된다.\n    * inner function안에서 closure 영역에 있는 변수는 'c' 하나 뿐이다. c1처럼 변수 선언만 하고 할당하지 않으면 메모리에 올라오지 않는다. \n\n* 외무 함수의 변수를 참조하는 내부 함수(2): outer 함수의 실행컨텍스트가 종료된 후 inner 함수를 호출하면?  \n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    var excuteInnerFunc = outer();\n    consl.log(excuteInnerFunc); // 2\n    consl.log(excuteInnerFunc); // 3\n    ```\n    * inner함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없습니다.\n    * outerEnvironmentReferenece에는 inner함수가 선언된 위치의 LexicalEnvironment가 참조복사\n    * inner함수는 outer함수 내부에서 선언됐으므로, outer함수의 Lexicalenvironment가 담김\n        - 위 단계로 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환\n        - inner함수의 실행 컨텍스트가 종료\n    * excuteInnerFunc를 두번째 호출하게 되면 위 단계를 걸쳐  2->3으로 증가한다.\n\n    * ***주의할점***\n        > inner함수의 실행시점에는 outer함수는 이미 실생 종료된 상태인데 outer함수의 Lexicalenvironment에 어떻게 접근할 수 있는걸까? \n        - 가비지 컬렉터의 동작 방식때문\n        - 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.\n        - 언젠가 inner함수의 실행컨텍스트가 활성화 되면 outerEnvironmentReferenece가 outer함수의 Lexicalenvironment를 필요로 할 것이므로 수집 대상에서 제외\n            - 그래서 inner함수 c 변수에 접근 가능\n\n* return 없이도 클로저가 발생하는 다양한 경우\n    ```js\n    (function(){\n        var a = 0 ;\n        var intervalId = null;\n        var inner = function() {\n            if (++a>9) {\n                clearInterval(intervalId);\n            }\n            console.log(a);\n        };\n        intervalId = setInterval(inner, 1000);\n    })()\n\n    // clouser&eventListener\n    (function(){\n        var count = 0;\n        var button = document.createElement('button');\n        button.innerText = 'click';\n        button.addEventListener('click', function(){\n            console.log(++count, 'times clicked');\n        });\n        document.body.appendChild(button);\n    })()\n    ```\n    ![clouser&eventListener](clouser&eventListener.png)\n\n# 2 클로저와 메모리 관리\n* 객체지향, 함수형 모두를 아우르는 중요한 개념\n* 클로저는 메모리 소모가가 있지만 이런 특성을 정확히 이해하고 잘 활용하도록 노력해야한다.     \n\n* closure를 GC가 수거하게 하는 방법\n    - 3장 예시에 POINT 주석 3개 참고   \n    ```js\n        //1번째 예시\n        var outer = function() {\n            var c = 1;\n            var c1\n            var inner = function() {\n                console.log(++c);\n            }\n            inner();\n        };\n        outer();\n        outer = null;   // POINT: outer실별자의 inner 함수 참조를 끊음\n        \n\n        //2번째 예시\n        (function(){\n            var a = 0 ;\n            var intervalId = null;\n            var inner = function() {\n                if (++a>9) {\n                    clearInterval(intervalId);\n                    inner = null;             // POINT: inner식별자의 함수 참조를 끊음  \n                }\n                console.log(a);\n            };\n            intervalId = setInterval(inner, 1000);\n        })();    \n\n        \n        //3번째 예시\n        // clouser&eventListener\n        (function(){\n            var count = 0;\n            var button = document.createElement('button');\n            button.innerText = 'click';\n\n            var clickHandler = function(){\n                //console.log(++count, 'times clicked');\n                if( ++count > 9 ){\n                    clickHandler = null;  //POINT: clickHandler 식별자 함수 참조를 끊음\n                }\n            };\n\n            button.addEventListener('click', clickHandler);\n            document.body.appendChild(button);\n        })()\n    ```\n\n# 3 클로저 활용사례\n\n## 3-1 Event Listener(콜백 함수 내부에서 외부 데이터를 사용하고자 할 때)\n\n* event Listener callback function\n    ``` js\n        var colorList = ['red', 'blue', 'white'];\n        var $ul = document.createElement('ul');\n\n        colorList.forEach(function(color){                  //(A)\n            var $li = document.createElement('li');\n            $li.innerText = color;\n            $li.addEventListener('click', function(){       //(B)\n                alert('your choice: ', color);\n            });\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n    ```\n    * (B)는 color라는 **클로저**가 있다. \n    * (A)는 colorList만큼의 **'실행 컨텍스트가 활성화 됨'**\n    * (B) outerEnvironmentReferenece가 (A)의 LexicalEnvironment참조  \n       -> **(B)함수가 참조할 예정인 변수 color에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능**\n\n\n* event Listener callback function에 bind 사용\n```js\n    var $ul = document.createElement('ul');\n    var colorList = ['red', 'blue', 'white'];\n    var consoleColor = function(color){\n        if(this === window){\n            //POINT3, POINT2\n            console.log('### this is window -> ' + this + \"/// callback function param: \" + color);\n            console.log(this);      //<li>blue</li>\n            console.log(color);     //MouseEvent\n            console.log('--------------------')\n        } else {\n            //POINT1\n            console.log('### this is HTMLElement -> this Value:' + this + \"/// callback function param: \" + color);\n            console.log(this);      //window\n            console.log(color);     //blue\n            console.log('====================')\n        }   \n    }            \n    \n    colorList.forEach(function(fruit){\n        var $li = document.createElement('li');\n        $li.innerText = fruit;\n        $li.addEventListener('click', consoleColor);                        //POINT 1: eventListener의 this, 첫번째 파라미터는 각각 '클릭한 dom', 'MouseEvent' 객체들이다.\n        $li.addEventListener('click', consoleColor.bind(this, fruit));      //POINT 2: forEach의 callback function에서 this는 windown!/ fruit는 clousre! \n        $ul.appendChild($li);\n    });\n    document.body.appendChild($ul);\n    \n    consoleColor(colorList[2]);                                             //POINT 3\n```\n    ![](callbackEg_EventListener.png)\n    \n    * POINT1,2,3의 consoleColor function의 console 확인 필요 \n    * POINT1,2의 this, 첫번째 param을 다시 상기 시켜보자.\n    * POINT2의 제약사항  \n        **- 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라지는 점은 감안해야한다.**\n\n        \n* event Listener에 고차 함수 사용\n    - 함수형 프로그램밍에서 자주 쓰이는 방식\n\n    ```js\n        var $ul = document.createElement('ul');\n        var colorList = ['red', 'blue', 'white'];\n        var consoleColor = function(color){\n            return function(){\n                console.log(color)\n            }\n        }            \n        \n        colorList.forEach(function(fruit){\n            var $li = document.createElement('li');\n            $li.innerText = fruit;\n            $li.addEventListener('click', consoleColor(fruit));\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n        \n    ```\n\n## 3-2 접근 권한 제어(정보 은닉)\n\n```js\n    var outer = function(){\n        var a = 1;                  //closure\n        var inner = function(){\n            return ++a;\n        }\n        return inner;\n    }\n    var outer2 = outer();\n\n    console.log(outer2());\n    console.log(outer2());\n```\n\n* outer함수는 외부(전역 스코프)로부터 철저하게 격리\n* 외부에서는 외부 공간에 노출돼 있는 outer라는 변수를 통해 outer함수를 실행할 수 있지만  \n, outer함수 내부에는 어떠한 개입도 할 수 없다.\n* **외부에서는 오직 outer함수가 return한 정보에만 접근할 수 있다.** (== return 값이 외부에 정보를 제공하는 유일한 수단)\n\n## 3-3 부분 적용함수\n\n```js\nvar add = function(){\n    var result = 0;\n    for(var i = 0; i < arguments.length; i++){\n        result += arguments[i];\n    }\n    return result;\n};\nvar addPartial = add.bind(null, 1,2,3,4,5);\nconsole.log(addPartical());             //15\nconsole.log(addPartial(6,7,8,9,10));    //55\nconsole.log(addPartical(10));           //25\n\n```\n## 3-4 커링함수\n* 여러 인자를 받은 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성\n\n* curring function eg\n    ```js\n\n    var curryFuncTest = function (func){\n        debugger;\n        return function(a){\n            debugger;\n            return function(b){ // getMaxWith10, getMinWith10 funciton\n                debugger;\n                return func(a,b);\n            };\n        };\n    };\n\n\n    var getMaxWith10 = curryFuncTest(Math.max)(10);\n    console.log(getMaxWith10(8));\n    console.log(getMaxWith10(25));\n\n    var getMinWith10 = curryFuncTest(Math.min)(10);;\n    console.log(getMinWith10(8));\n    console.log(getMinWith10(25));\n\n    ```\n![curryfunciton](curryfunction.png)\n\n* curring function with arrow function\n\n    ```js\n        var curryFuncTestWithArrowFunc = func => a => b => func(a,b);\n        var getMaxWith10WithArrowFunc = curryFuncTestWithArrowFunc(Math.max)(10);\n        console.log(getMaxWith10WithArrowFunc(8));\n        console.log(getMaxWith10WithArrowFunc(25));\n    ```\n\n* curring function 실제 사용 예\n\n    ```js\n    var getInfomation = function(baseUrl){                      // 서버에 요청할 주소의 기본 URL\n        return function (path) {                                // path값\n            return function (id) {                              // id    \n                return fetch(baseUrl + path + '/' + id);        // 실제 서버에 정보 요청\n            };\n        };\n    };\n\n    var getInformation = baseUrl => path => id => fetch(baseUrl + path + '/' + id);\n    var imageUrl = 'http://imgAddr.com/';\n\n    // 이미지 타입별 요청 함수 준비\n    var getImage = getInformation(imageUrl);    //http://imgAddr.com/\n    var getEmoticon = getImage('emoicon');      //http://imgAddr.com/emoticon\n    var getIcon = getImage('icon');             //http://imgAddr.com/icon\n\n    //실제 요청\n    var emoticon1 = getEmoticon(100);       //http://imgAddr.com/emoticon/100\n    var emoticon2 = getEmoticon(200);       //http://imgAddr.com/emoticon/200\n    var icon1 = getIcon(10);                //http://imgAddr.com/icon/10\n    var icon2 = getIcon(20);                //http://imgAddr.com/icon/20\n\n    ```\n\n    * 이런 이유로 최근 여러 프레임워크, 라이브러리 등에서 커링을 상당히 광범위하게 사용하고 있다.\n","excerpt":"업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다.…","fields":{"slug":"/closure/"},"frontmatter":{"date":"Jan 24, 2020","title":"closure","tags":["javascript Core","javascript","closure"]}}},{"node":{"rawMarkdownBody":"\n개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다.\n\n\n```js\n\t1 실행 컨텍스트란? \n\t2 VariableEnvironment\n\t3 LexicalEnvironment\n\t\t3-1 environmentRecord와 hoisting\n            호이스팅 규칙  \n            함수 선언문과 함수 표현식\n      \n\t\t3-2 scope, scope chain, outerEnvironmentReference\n            스코프 체인\n            전역변수와 지역변수\n\n\t4 this\n```\n\n\n# 1 실행 컨텍스트란? \n> * 실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> * 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념  \n> * 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(=호이스팅), 외부환경정보를 구성, this값을 설정  하는 동작 수행    \n-> 이로인해 다른언어에서는 발견할 수 없는 특이한 현상들이 발생\n\n* 코드 실행시 실행 컨텍스트\n    - '동일한 환경'에 있느 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 \n    - 이를 콜 스택에 쌓아올렸다가\n    - 가장 위에 쌓여있는 컨텍스트와 관련 잇는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장\n\n* '동일한 환경'(하나의 실행 컨텍스트)을 구성할 수 있는 방법\n    - 전역공간, evan()함수, 함수 등이 있음\n    - eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것\n\n* javascript engine 역할\n  - 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 '필요한 환경정보들'을 수집해서 실행 컨텍스트 객체에 저장\n  - 이 객체는 javascript engine이 활용할 목적으로 생성(개발자가 코드를 통해 확인할 수 x)  \n  - 담기는 정보 세가지  \n    : 목차 2, 3, 4에서 각각 더 자세하게 설명하도록 한다. \n  ```txt\n    VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. \n                            : 선언 시점의 LexicalEnvironment의 스냅샷 \n                            : 변경 사항은 반영되지 않음\n    LexicalEnvironment  : 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영\n    ThisBinding         : this 식별자가 바라봐야 할 객체\n  ```\n\n* 활성화된 실행 컨텍스트의 수집정보\n\n``` \n  * inner \n      Variableenvironment : environmentRecord(snapshot)/ outerEnvironmentReferenece(snapshot)\n      LexicalEnvironment  : environmentRecord/ outerenvironmentReferenece\n      ThisBindding\n  * outer\n  * 전역 컨텍스트\n```\n  \n# 2 VariableEnvironment\n* LexicalEnvironment와 같지만 최초 실행 시의 스탭 샷을 유지한다는점이 다름\n* 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음,  \n  이를 그대로 복사해서 Lexical environment를 만들어  LexicalEnvironment를 주로 활용하게 된다.\n* Variableenvironment, LexicalEnvironment의 내부는 **environmentRecord와 outerEnvironmentReference**로 구성\n  - 초기화 과정 중에는 사실상 완전히 동일, 이후 코드 진행에 따라 서로 달라짐\n  - 자세한 내용은 LexicalEnvironment를 통해 설명\n\n# 3 LexicalEnvironment\n* 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것 \n\n## 3-1 environmentRecord와 hoisting\n* js engine은 컨텍스트 내부 전체를 처음부터 쭉 훑어나가며 순서대로 수집 = \"호이스팅 개념\"  \n(= 식별자들을 최상단으로 끌어올려놓은 다음 실제코드를 실행-실제로 끌어 올리는 것이 아님, 편의상 끌어올린것으로 간주-)\n  - 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태\n  - 코드가 실행되기 전임에도 불구하고 js engine은 이미 해당 환경에 속한 코드의 변수명들으 모두 알고 있게 된다.\n                                                                \n### 호이스팅 규칙\n* environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다\n* 예시\n  * 함수 선언문으로 선언한 함수는 hoisting 대상\n  * 함수 표현식은 hosisting 대상 x\n\n  ```js\n  function a(){\n      console.log(b);   //ƒ b() {}\n      var b; \n      console.log(b);   //ƒ b() {}\n      function b() {};  //함수 선언문\n      console.log(b);   //ƒ b() {}\n\n      console.log(c);   //undefined\n      var c = function() {}\n  }\n  ```\n\n\n\n### 함수 선언문과 함수 표현식\n* 함수를 정의하는 세가지 방식\n  * 함수 선언문: 반드시 함수명이 정의 돼 있어야 함/ hoisiting이 됨\n  * 함수 표현식: 함수명이 없어도 됨           / hoisiting이 안 됨\n  * 기명 함수 표현식: 함수명을 정의한 함수 표현식\n\n```js\nfunction a() {} //함수 선언문\na();\n\n//상대적으로 긴 코드 속에서 함수 표현식이 안전한다.\nvar b = function() {} //(익명) 함수 표현식\nb();\n\nvar c = function d() {} // 기명 함수 표현식. 변수명: c, 함수명 d\nc(); // 실행\nd(); // error\n\n```\n\n## 3-2 scope, scope chain, outerEnvironmentReference\n* scope: 식별자에 대한 유표범위\n  * ES5까지의 자바스크립트는 특이하게도 전역 공간을 제외하면 오직 함수에 의해서만 스코프가 생성\n* scope chain: 이런 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것\n* outerEnvironmentReference: 스코프체인을 가능하게 하는 것이 바로 Lexicalenvironment의 두번째 수집자료인 outerEnvironmentReferenece\n\n### scope chain\n* outerEnvironmentReferenece는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조\n  - 아래 예시1 scopechain 도식화 참고\n* 과거 시점인 '선언될 당시'는 행위가 실제로 일어 날 수 있는 시점이란?  \n  - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐\n  - 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문\n\n* scope chain 예1\n  1. A함수 내부에 B함수 선언, B함수 내에 C함수 선언\n  2. 함수 C의 outerEnvironmentReferenece는 함수 B의 LexicalEnvironment를 참조 \n  3. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReferenece는 ***다시 함수 B가 선언되던 때*** A함수의 LexicalEnvironment를 참조 \n  4. 이처럼 outerEnvironmentReferenece는 연결리스트 형태를 띤다.\n  5. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것'  \n\n* 위 예시로본 특징 \n  - 예시 3번에서 본것 처럼 각 outerEnvironmentReferenece는 오직 자신이 선언된 시점의 LexicalEnvironment만 침조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능\n  - 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능** \n\n* scope chain 예1 코드\n```js\n/*01*/ var a = 1;\n/*02*/ var outer = function () {\n/*03*/   var inner = function () {\n/*04*/     console.log(a);\n/*05*/     var a = 3;\n/*06*/  };\n/*07*/   inner();\n/*08*/   console.log(a);\n/*09*/ };\n/*10*/ ouer();\n/*11*/ console.log(a);\n```\n* scope chaing 예1 코드 도식화\n    * 그림을 보면서 라인별로 어떤 동작을 하는지 생각해보자\n    ```\n      LE: Lexical Envinronment\n      e: environmentRecord\n      o: outerEnvironmentReference\n    ```\n    ![](context.jpeg)\n\n\n* **전역 컨텍스트 활성화**\n  * 0: LexicalEnvironment, VariableEnvironment, thisBinding\n\n* 전역 컨텍스트 생성/ outer 함수 호출\n  * 1,2: a에 1, outer에 함수 할당\n  * 10: outer 함수호출, 전역 컨텍스트 비활성화\n  * 2: outer실행 컨텍스트 활성화\n\n* outer 컨텍스트 생성/ inner 함수 호출\n  * 3: inner에 함수 할당\n  * 7: inner 함수 호출, outer 실행 컨텍스트 비활성화\n  * 3: inner 실행 컨텍스트 활성화 \n\n* inner 함수 수행\n  * 4: inner의 LE에서 a 탐색 -> undefined 출력\n  * 5: a에 3할당\n\n* inner 컨텍스트 종료 \n  * 6: inner 함수 종료, inner 실행 컨텍스트 제거\n  * 7: outer 실행 컨텍스트 재활성화\n  * 8: outer의 LE에서 a탐색 -> GLOBAL의 LE에서 a 탐색 -> 1출력\n\n* outer 컨텍스트 종료 \n  * 9: outer함수 종료, outer 실행 컨텍스트 제거 \n  * 10: 전역 컨텍스트 재활성화 \n  * 11: GLOBAL의 LE에서 a탐색 -> 1출력\n\n\n* outer컨텍스트 \n\n```js\n\"전역 컨텍스트\": {\n    environmentRecord: 'a, outer function',\n    outerEnvironmentReferenece: null,\n    this: window\n}\n\n\"outer컨텍스트\": {\n    environmentRecord: ['inner function'], \n    outerEnvironmentReferenece: 'GLOBAL LexicalEnvironment',\n    this: window\n}\n\n\"inner컨텍스트\": {\n    environmentRecord: ['a'], \n    outerEnvironmentReferenece: 'outer 컨텍스트',\n    this: window\n}\n```\n\n### 전역변수와 지역변수\n* 전역변수: 전역 공간에서 선언\n* 지역변수: 함수 내부에서 선언\n\n# 4 this\n* 실행컨텍스트의 thisBinding에 this로 지정된 객체가 저장\n* 실행컨텍스 활성 당시 this가 지정되지 않은경우 \"전역객체\" 저장\n* 함수 호출하는 방법에 따라 this가 달라진다.(this에 대해서만 내용을 다룰 예정)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n* 제로초 블로그\n","excerpt":"개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다. 1 실행 컨텍스트란? 실행컨텍스트(execution context…","fields":{"slug":"/Excute-context/"},"frontmatter":{"date":"Jan 24, 2020","title":"실행 컨텍스트","tags":["javascript Core","javascript","excute context"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6","set","filter","reduce"]}}},{"node":{"rawMarkdownBody":"\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말할 수 있는 아니었다.\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있어 연예인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴져 멋있었고 떠먹기만 하면 되는 상황에서 감사한 마음이 들었다. 그래서 한편으론 실제로 적용하는 생각 연습과 다른 사람에게 효과적으로 전달 할 수 있는 고민을 하고 싶었다. (그래서 블로그에 자바스크립트 내용을 정리하는 연습을 해보려고 한다. -현재(2020.01 시작) 진행 중-) 그리고 책을 보면서 업무를 하며 익혔던 자바스크립트 내용을 상기하는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\njavascript를 더 깊게 알고 싶은 분에게 추천해주고 싶은 책이다.\n\n\n","excerpt":"이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트후기/"},"frontmatter":{"date":"Jan 20, 2020","title":"코어자바스크립트 후기","tags":["javascript","독서후기"]}}}]}},"pageContext":{}}}