{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6","set","filter","reduce"]}}},{"node":{"rawMarkdownBody":"\n# CONDITION\n  * 서버는 최대 5개 요청을 처리 할 수 있다. \n  * topEl: 각 요소의 숫자 이하 중요도를 처리 할 수 있다. \n  * processTarget: 서버가 처리할 대상\n\n# STRATEGY\n  * STRATEGY 0. iterator STRATEGY 2, 2.1 till topEl ARRAY\n  * STRATEGY 1.0 FILTER procesTarget array is filtered by low number of each topEl array element number  \n  * STRATEGY 1.1 SLICE server can process reqeust number (5)\n  * STRATEGY 2.0 DELETE processTarget array elements from ARRAY element of STRATEGY 1.1(variable: filteredTS)  \n              ( [!] NOT ACCEPT dulicated delete => POINT3, 4 )\n  * STRATEGY 2.1 COUNT processed timstamp\n\n# POINT\n  > 아래 코드에 위치 주석 참고 \n\n  ## POINT1\n  * splice에 의해서 첫번째 outer for문에 돌아갔을 때 배열(filteredTS) 값이 바뀐다. \n\n  ## POINT2\n  * 아래 console에서 topEl요소별로 processTarget값이 나오는것이 아니라\n      topEl요소 배열이 모든 process처리 후의 값이 찍히게 되서 \"slice로 shallow clone\"을 이용\n\n  ## POINT3\n  * 위단계에서 splice로 삭제 했기 때문에 array 요소가 하나 줄어 들어 줄어든 요소 순서부터 시작하기 위해서 감소 연산자를 사용했다.(for동작에서 j++가 동작하기 때문에 )\n  * eg) 배열을 순회하는 j가 2번째 요소를 제거하면 배열 2번째 요소 뒤에 있는 요소들이 앞으로 당겨진다. == 3번째 요소가 2번재요소가 된다.  \n  이렇게 되면 j는 순회를 2번째 요소부터 해줘야 한다.\n\n  ## POINT4\n  * checkDupl flag variable  \n  : filteredTS요소를 processTarget 배열에서 제거할때 같은 요소 값을 지우지 않기 위한 flag성 variable  \n  : eg) filteredTS 요소 1을 제거할때 processTarget에 1이 1개 이상이더라도 1개만 제거\n\n\n# CODE\n``` js\n    var processTarget = [3,3,4,9,11,15,28,30];\n    // var processTarget = [3,3,3,3,3,3,3,4,9,11,15,28,30]; // 3*7\n    var topEl = [0,5,5,15];\n    \n    var originProcessTargetArray = processTarget.slice(0);\n    var filteredTS = [];\n    var processedNumber = 0;\n    //STRATEGY 0\n    topEl.forEach( v => {\n      //STRATEGY 1.0, 1.1\n      filteredTS = processTarget.filter( v2 => v2 < v ).sort((a, b) => b-a).slice(0, 5);\n      //count process number\n      processedNumber += filteredTS.length;\n      \n      //STRATEGY 2.0, 2.1\n      var afterDelProcessTargetArray = [];\n      for (var i=0; i < filteredTS.length; i++){\n        var checkDupl = false;\n        for (var j=0; j < processTarget.length; j++){\n          if(!checkDupl && filteredTS[i] === processTarget[j]){\n            //POINT1\n            processTarget.splice(j,1);\n\n            //POINT2\n            afterDelProcessTargetArray = processTarget.slice(0);            \n\n            //POINT3\n            j--;  \n            checkDupl = !checkDupl;\n          }\n        }\n      }\n\n      //* afterDelProcessTargetArray: topEl 요소 별로 processTarget Array\n      //* filteredTS: topEl 요소 별로 server가 처리할 value\n      console.log({originProcessTargetArray, afterDelProcessTargetArray, filteredTS, topEl: v, processedNumber});\n    });\n```\n\n# 결과\n![](serverProcessRequestByPriority_01.png)\n\n","excerpt":"CONDITION 서버는 최대 5개 요청을 처리 할 수 있다.  topEl: 각 요소의 숫자 이하 중요도를 처리 할 수 있다.  processTarget: 서버가 처리할 대상 STRATEGY STRATEGY 0. iterator STRATEGY…","fields":{"slug":"/serverProcessRequestByPriority/"},"frontmatter":{"date":"Jan 19, 2020","title":"server process request by priority","tags":["algorithm","javascript"]}}},{"node":{"rawMarkdownBody":"\n# Moving the mouse: mouseover/out, mouseenter/leave 에대해서 설명할 예정입니다.\n\n","excerpt":"Moving the mouse: mouseover/out, mouseenter/leave 에대해서 설명할 예정입니다.","fields":{"slug":"/Moving-the-mouse(mouseoverout-mouseenter-leave)/"},"frontmatter":{"date":"Jan 17, 2020","title":"first contents","tags":["undefined"]}}}]}},"pageContext":{}}}