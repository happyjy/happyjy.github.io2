{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n\nsetTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래 3개를 직접 그리며 개념을 정리했다.\n\n\n# 이벤트 루프 설명 시 주요 용어\n    - 호출스택\n    - 백그라운드\n    - 테스크큐\n    - 이벤트 루프\n\n# 이벤트 루프 설명 예시\n```js\n\nconsole.log('Hi');\n\nsetTimeout(function(){\n    console.log('CB');\n}, 3000)\n\nconsole.log('bye');\n\n```\n* 위 코드 결과는 Hi, bye, CB 순서로 로그가 남게 된다. 아래 설명을 참고\n* 만약 setTimeout이 0초로 설정하게 된다면 로그는 어떻게 출력이 될지 아래 설명을 보면서 생각해보자 \n\n## 이벤트 루프 예시 도식화/ 설명\n![](eventLoop1.jpg)\n* 상태 \n    - console.log('Hi')가 수행되어 콘솔에 찍히고 `호출스택`에서 빠진 상태\n* 설명\n    1. setTimeout이 수행되어 setTimeout callback function이 `백그라운드`로 이동된 상태\n    2. setTimeout callback function이 `백그라운드`로 이동\n    3. 3초후에 setTimeout callbakc function이 수행 되도록 설정 되어 있기 때문에 3초 이후 `태스크 큐`로 이동\n\n![](eventLoop2.jpg)\n\n* 설명\n    4. `호출 스택`실행이 끝나면 \n    5. `이벤트루프`는 태스크 큐의 callback function을 `호출 스택`으로 올린다.\n\n![](eventLoop3.jpg)\n* 설명  \n    6. run(setTimeout callback function)이 `호출 스택`에서 실행 되고 비워지게 된다.  \n    7. `이벤트루프`는 `태스크 큐`에 callback function이 들어올 때까지 대기\n\n\n# 추가 설명\n* setTimeout 0초는 4ms 지연 시간을 갖고 있어 hi, bye, CB 순서대로 로그가 남게 된다.\n* 백그라운드에서 3초를 설정했음에도 3초 후에 실행되지 않는경우 \n    - 호출 스택에서 많은 일을 하게 되면 이벤트루프가 태스크 큐에 쌓이 콜백함수들을 호출스택으로 끌어 올리지 못하기 때문\n* 백그라운드 사용하는 작업\n    - setTimeout, setInterval\n    - ajax 요청\n    - event Listener  \n        : 참고  http://latentflip.com/loupe/\n    - File Reader\n    - Javascript 기본제공 메소드 중 콜백 함수를 사용하는 메소드는 백그라운드를 사용하는 경우가 많다.\n\n# 참고 \n* 1. 제로초\n* 2. JSConf\n    - https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title","excerpt":"setTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래…","fields":{"slug":"/eventLoop/"},"frontmatter":{"date":"Feb 16, 2020","title":"eventLoop","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n* javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다.\n\n```\n목차 \n# excutor: promise\n# 소비자: then, catch, finally\n# 예시: loadScript\n```\n\n# excutor: promise\n\n* \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // executor (제작 코드, \"가수\")\n    });\n    ```\n    - excutor는 아래 콜백 중 하나를 반드시 호출해야 합니다. \n        - resolve(value): 성공적으로 끝난 경우 결과를 value param으로 전달하며 resolve 호출\n        - reject(error): 에러 발생시 에러 객체를 error param으로 전달하며 reject 호출\n\n* new Promise(executor)의 callback 'resolve(value)', 'reject(error)'의 state, result 상태 \n* new Promise 생성자가 반환하는 promise 객체는 다음과 같은 내부 프로퍼티를 갖습니다.\n    - state: 처음엔 \"pending\"(보류)이었다 resolve가 호출되면 \"fulfilled\", reject가 호출되면 \"rejected\"로 변합니다.\n    - result: 처음엔 undefined이었다, resolve(value)가 호출되면 value로, reject(error)가 호출되면 error로 변합니다.\n\n\n* 성공일때 예제(resolve) \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 프라미스가 만들어질 때 executor 함수는 자동으로 실행됩니다.\n\n        // 1초 뒤에 일이 성공적으로 끝났다는 신호와 함께, result가 'done'이 됩니다.\n        setTimeout(() => resolve(\"done\"), 1000);\n    });\n    ```\n\n* 실패일때 예제(reject)\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 1초 뒤에 에러와 함께 실행이 종료되었다는 신호를 보냅니다.\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    ```\n\n* resolve/reject 함수 호출 규칙\n    - excutor에 의해서 끝난일은 resolve, reject중 첫번째로 오는 것만 수행됩니다.\n    - 나머지는 무시\n    \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      resolve(\"done\");\n\n      reject(new Error(\"…\")); // 무시됨\n      setTimeout(() => resolve(\"…\")); // 무시됨\n    });\n    ```\n\n\n# 소비자: then, catch, finally\n> 프라미스 객체는 executor(‘제작 코드’ 혹은 ‘가수’)와 결과나 에러를 받을 소비 함수(‘팬’)를 이어주는 역할을 합니다. 소비함수는 .then, .catch, .finally 메서드를 사용해 등록(구독)됩니다.\n\n\n## then\n> excutor가 성공, 실패 한경우를 모두 handling 할 수 있다. \n> then parameter에 두개를 전달해줄 수 있는데 첫번째는 param에 성공 handling function, 두번째는 param에 실패 hanlding function을 전달할 수 있다.\n\n* excutor가 성공적으로 수행한 경우\n    - POINT 주석 참고\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      setTimeout(() => resolve(\"done!\"), 1000);\n    });\n\n    // POINT: resolve 함수는 .then의 첫 번째 함수(인수)를 실행합니다.\n    promise.then(\n        result => alert(result), // 1초 후 \"done!\"을 출력      \n        error => alert(error) // 실행되지 않음\n    );\n    ```\n    - 아래 와 같이 성공했을때는 작성 가능하다 \n        - then function에 parameter 한개만 전달해주면 된다.\n        ```js\n        var promise = new Promise(resolve => {\n            setTimeout(() => resolve(\"done!\"), 1000);\n        });\n\n        promise.then(alert); // 1초 뒤 \"done!\" 출력\n        ```\n\n* excutor가 에러로 필해한 경우\n    - POINT 주석 참고 \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    // POINT: reject 함수는 .then의 두 번째 함수를 실행합니다.\n    promise.then(\n        result => alert(result), // 실행되지 않음\n        error => alert(error) // 1초 후 \"Error: 에러 발생!\"를 출력\n    );\n    ```\n\n\n## catch\n> excutor 수행 결과 중 error만 다루고 싶을 때 사용\n\n* 예시\n    - POINT 주석 참고\n    - .catch(f)는 문법이 간결하다는 점만 빼고 .then(null,f)과 완벽하게 동일\n    \n    ```js\n    var promise = new Promise((resolve, reject) => {\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    // POINT\n    // .catch(f)는 promise.then(null, f)과 동일하게 작동합니다\n    promise.catch(alert); // 1초 뒤 \"Error: 에러 발생!\" 출력\n    ```\n\n## finally\n> try... catch에 finally가 있는 것 처럼 promise에도 finally가 있다.\n\n\n* finally 예1  \n    : finally 이후 then을 통해 resolve 결과를 then으로 전달\n    ```js\n    new Promise((resolve, reject) => {\n        setTimeout(() => resolve(\"result\"), 2000)\n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .then(result => alert(result)); // <-- .then에서 result를 다룸\n    ```\n\n* finally 예2  \n    : finally 이후 cath를 통해 \n    ```js\n    new Promise((resolve, reject) => {\n        throw new Error(\"에러 발생!\");\n        // setTimeout(()=>{ reject(new Error('error'))}, 1000); // excutor 처리 시점만 조금 다르고 같은 결과 \n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .catch(err => alert(err)); // <-- .catch에서 에러 객체를 다룸\n    ```\n\n# 예시: loadScript\n* callback에서 loadScript 설명에서 callback hell을 해결 할 수 있는 방법이 promise라고 했는데 그 방법을 소개하겠다.\n\n* promise로 구현한 loadScript\n    ```js\n    function loadScript(src) {\n        return new Promise(function(resolve, reject) {\n            var script = document.createElement('script');\n            script.src = src;\n\n            script.onload = () => resolve(script);\n            script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));\n\n            document.head.append(script);\n        });\n    }\n    ```\n\n* 사용 방법\n    ```js\n    var promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\n    promise.then(\n        script => alert(`${script.src}을 불러왔습니다!`),\n        error => alert(`Error: ${error.message}`)\n    );\n\n    promise.then(script => alert('또다른 핸들러...'));\n    ```    \n    - 설명\n        - loadScript(script)로 스크립트를 읽고, 결과에 따라 그다음(.then)에 무엇을 할지에 대한 코드를 작성하면 되죠.\n    - 비교 \n        - 콜백으로 구현시에 loadScript(script, callback)를 호출할 때, 함께 호출할 callback 함수가 준비되어 있어야 합니다.  \n          loadScript를 호출하기 이전에 호출 결과로 무엇을 할지 미리 알고 있어야 했다.\n    \n\n# 참고 \n- javascript.info  \nhttps://javascript.info/promise-basics\n","excerpt":"javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다. excutor…","fields":{"slug":"/callback,Promise,async&await_2/"},"frontmatter":{"date":"Feb 16, 2020","title":"promise","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n\n예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source를 사용하려면 당연히 사용 할수 없습니다.  \n(**스크립트 읽기가 지금 당장 시작되더라도 실행은 함수가 종료되고 난 후에야 실행되므로 스크립트는 ‘비동기적으로’ 실행되었다고 할 수 있습니다.**)\n\n이렇게 비동기 적으로 실행되고 있는 문제를 해결하기위해서 callback기반 비동기 프로그램 방법으로 해결 할 수 있습니다.  \n(**무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공** -> script load를 보장 하는 loadScript function capter)\n\n하지만 callback기반 비동기 프로그램은 callback hell이라는 단점이 있고 이런 문제를 해결 할 수 있는 방법이 'promise, Async, awiat'fksms 개념이 있습니다. -> callback hell capter\n\n\n\n# callback function \n## script load를 보장 할 수 없는 loadScript function\n* document객체에 생성한 script객체를 추가해주면 추가한 script 주소를 통해서 원하는 파일을 받을 수 있다.\n* `loadScript` 구현\n    ```js\n    function loadScript(src) {\n        // creates a <script> tag and append it to the page\n        // this causes the script with given src to start loading and run when complete\n        var script = document.createElement('script');\n        script.src = src;\n        document.head.append(script);\n    }\n    ```\n\n    ```js\n    loadScript('/my/script.js'); // the script has \"function newFunction() {…}\n    newFunction(); // no such function!\n    ````\n* sciprt.js에 newFunction() 이 있다고 하자 loadScript를 통해서 받은 script.js파일에 선언한 newFunction()을 호출 하면 호출하지 못 한다.\n* 이유는 브라우저가 script.js 파일을 받기 전에 newFunction을 호출 했기 때문이다.\n* 그래서 **파일을 받고 function을 호출 시키는 보장해주는 코드를 추가 해야한다.**\n\n## script load를 보장 하는 loadScript function\n* 위 load를 보장하지 못하는 코드와 달라진점은 `callback` function 을 parameter로 전달해주고 loadScript는 전달 받은 param을 script onload property에 추가해줬다.\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(script);   // 기능 개선한 부분\n\n        document.head.append(script);\n    }\n    ```\n\n### script laod를 보장하는 예제\n* load를 보장하는 기능이 개선 된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n        script.onload = () => callback(script);       //POINT\n        document.head.append(script);\n    }\n\n    loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n        console.log(`Cool, the script ${script.src} is loaded`);\n        console.log( _ ); // function declared in the loaded script\n    });\n    ```\n* 결과 \n    - loadScript callback function을 확인해보면 콘솔 로그가 두개 있는데. script.src에 추가한 loadScript 첫번째 param loadash cdn 주소를 포함한 문자열과 load한 lodash lib의 _ 객체를 확인 할 수 있다.\n    - **callback function은 받고 싶은 파일을 로드한뒤 사용할 수 있는 공간이다.**(loadScript callback callback function으로 넘어 갔기 때문)\n\n* 정리 \n    - **이런 방식을 `콜백 기반(callback-based)` 비동기 프로그래밍이라고 합니다. 무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공해야 합니다.**\n\n# callback in callback \n* 위 예제 처럼 callback으로 하나의 파일만 로드할 뿐만 아니라 여러개도 load하고 싶을 것이다. \n* 아래 예제와 같이 구현 할 수 있을 것이다.\n    ```js\n    loadScript('/my/script.js', function(script) {\n\n        loadScript('/my/script2.js', function(script) {\n\n            loadScript('/my/script3.js', function(script) {\n            // ...continue after all scripts are loaded\n            });\n\n        })\n\n    });\n    ```\n\n# Handling errors \n* error 처리를 할 수 있는 기능이 개선된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(null, script);\n        script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n        document.head.append(script);\n    }\n    ```\n* 에러 처리 기능이 개선된 laodScript 를 사용하는 방법\n    - callback function에 2개의 param을 설정한다.\n        - 첫번째 parameter: error 객체\n        - 두번째 parameter: loadScript로 받고 싶은 script src string 객체\n    ```js\n    loadScript('/my/script.js', function(error, script) {\n                if (error) {\n                    // handle error\n                } else {\n                    // script loaded successfully\n                }\n    });\n    ```\n\n# callback hell\n* callback을 사용해서 비동기 처리가 유용해보인다. 하지만 callback in callback capter에서 확인해볼 떄 callback 안에 callback을 사용함으로 아래 코드와 같이 가독성이 떨어지는 결과를 가지고 옵니다.\n\n* callback hell 예제\n    ```js\n    loadScript('1.js', function(error, script) {        // 첫번째 callback\n\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', function(error, script) {    // 두번째 callback\n                if (error) {\n                    handleError(error);\n                } else {\n                    // ...\n                    loadScript('3.js', function(error, script) {    // 세번째 callback\n                        if (error) {\n                            handleError(error);\n                        } else {\n                            // ...continue after all scripts are loaded (*)\n                        }\n                    });\n\n                }\n            })\n        }\n    });\n    ```\n\n* 이를 해결하기 위해서 아래와 같이 **중첩하는 callback function**으로 callback hell을 만들지 않고 function을 top-level로 나눠 조금더 가독성이 쉽게 구현 할 수 있습니다. \n    ```js\n    loadScript('1.js', step1);\n\n    function step1(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', step2);\n        }\n    }\n\n    function step2(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('3.js', step3);\n        }\n    }\n\n    function step3(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...continue after all scripts are loaded (*)\n        }\n    };\n    ```\n* 하지만 step1, 2, 3과 같은 function은 연쇄 작용하는 코드 밖에서 사용할 수 없는 단점이 있습니다. 그래서 이런 점과 callback hell을 피할 수 있는 \"promise, Asynch/await\" 개념을 정리해보겠습니다.\n\n\n# 참고 \n- javascript.info  \nhttps://javascript.info/callbacks#callback-in-callback","excerpt":"예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source…","fields":{"slug":"/callback,Promise,async&await_1/"},"frontmatter":{"date":"Feb 16, 2020","title":"callback","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\npromise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다.\n\n# promise chaing 방법 두가지 \n## promise chaining 첫번째 방법(1/2)\n\n* promise객체의 하나에 then을 여러개 연속으로 연결해서 사용하는 방법으로 사슬고리처럼 연결되어 있어 다음 then에 value를 넘겨 줄 수 있습니다.\n    ```js\n        new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000); // (*)\n        }).then(function(result) { // (**)\n            alert(result); // 1\n            return result * 2;\n        }).then(function(result) { // (***)\n            alert(result); // 2\n            return result * 2;\n        }).then(function(result) {\n            alert(result); // 4\n            return result * 2;\n        });\n    ```\n\n\n## promise chaining 두번째 방법(1/2)\n* then을 선언할때마다 promise를 사용해서 선언하게 되면 모든 선언한 then에 pomise의 결과가 전달이 됩니다.\n    ```js\n        var promise = new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000);\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n    ```\n\n# 프로미스 반환하기 \n* 아래 예제 설명 \n    - 예시에서 첫 번째 .then은 1을 출력하고 new Promise(…)를 반환((*))합니다.  \n    - 1초 후 이 프라미스가 이행되고 그 결과(resolve의 인수인 result * 2)는 두 번째 .then으로 전달됩니다. \n    - 두 번째 핸들러((**))는 2를 출력하고 동일한 과정을 반복합니다.\n* **프라미스를 반환하는 것도 비동기 작업 체인을 만들 수 있다.**\n\n    ```js\n    new Promise(function(resolve, reject) {\n        setTimeout(() => resolve(1), 1000);\n    }).then(function(result) {\n        alert(result); // 1\n        return new Promise((resolve, reject) => { // (*)\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) { // (**)\n        alert(result); // 2\n        return new Promise((resolve, reject) => {\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) {\n        alert(result); // 4\n    });\n    ```\n\n# 예제: loadScript callback function 해결하기 \n\n    ```js\n    loadScript(\"/article/promise-chaining/one.js\")\n        .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n        .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n        .then(script => {\n            // 스크립트를 정상적으로 불러왔기 때문에, 스크립트 내의 함수를 호출할 수 있습니다.\n            one();      //...one.js에 있는 function \n            two();      //...two.js에 있는 function \n            three();    //...three.js에 있는 function\n        });\n    ```\n\n# fetch와 함께 체이닝 함께 응용하기 \n\n* 프론트 단에선, 네트워크 요청 시 프라미스를 자주 사용합니다. \n* 예시에선 메서드 fetch를 사용해 원격 서버에서 사용자 정보를 가져오겠습니다. \n* fetch는 promise객체를 반환 하기 때문에 fetch로 원하는 정보를 가지고 오고 promise에서 설명한 것 처럼 then을 통해서 후처리를 할 수 있습니다.\n\n    ```js\n    fetch('/article/promise-chaining/user.json')\n        // 원격 서버가 응답하면 .then 아래 코드가 실행됩니다.\n        .then(function(response) {\n            // response.text()는 응답 텍스트 전체가 다운로드되면\n            // 응답 텍스트를 새로운 이행 프라미스를 만들고, 이를 반환합니다.\n            return response.text();\n        })\n        .then(function(text) {\n            // 원격에서 받아온 파일의 내용\n            alert(text); // {\"name\": \"iliakan\", isAdmin: true}\n        });\n    ````\n\n# 참고 \n- javascript.info  \nhttps://javascript.info/promise-chaining","excerpt":"promise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다. promise chaing 방법 두가지 promise chaining 첫번째 방법(1/2) promise객체의 하나에 then…","fields":{"slug":"/callback,Promise,async&await_3/"},"frontmatter":{"date":"Feb 16, 2020","title":"Promise chaning","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# 개발자로 어떻게 살 것인가? \n > 2020년 2월 4년 3개월차 개발자의 고민 작성 \n\n* 개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년 8개월이 지났다. 늦게 시작한 만큼 효율적으로 **목적을 정해두고 목표를 세워 시간을 만회하고 싶어** 작성하기 시작했다.\n\n\n\n# 목적 \n> fw/lib 익혀 비즈니스 개발에만 그치지 않고 CTO 성향을 가진 개발자  \n> 인문학도 공부하며 커뮤니케이션에 원활한 사람  \n> 사회/정치에도 관심을 두면서 개발자로서 그사이에 내가 해야 할 일을 고민하기  \n\n* FW/LIB 익혀 비즈니스 개발에 그치지 않고 원리를 알고 개발하며 나아가 **'설계, 성능, 보안, 설계에 관심을 두고, product level로 만들 수 있는 능력, 문제가 있을때 어디가 통찰력 있게 해결할 수 있는 능력, 지식 습득을 교양을 쌓는다고 여기며 꾸준하게** 할 수 있는 개발자가 되고 싶다. \n\n* 위 능력을 갖추면서 \"이슈\"가 생겼을 때 **먼저 나서서** 처리 할 수 있는 능력을 갖추고 싶다.\n\n\n# 목표 \n> 지속적으로 작성 계획\n\n## javascript개념을 정리하게된 계기\n* 그동안 공부해온 것을 정리하고 그다음으로 넘어가고 싶었다. \n    한 언어를 깊게 공부하고 싶었다. \n    - 이유는   \n    : 다른 언어를 배우더라도 내가 아는 개념과 뭐가 다르고 같은지 비교/생각해가며 공부하면 더 재밌고 수월할 것 같다고 생각했기 때문이다.  \n    : react, node를 사용해 toy project를 진행하며 Javascript를 느낄 수 있을 정도로 알고 싶었다.  \n    : 이슈 해결을 수월하고 더 재미있는 개발, 더 좋은 퍼포먼스를 낼 수 있을 거라고 느꼈다.\n    : Javascript를 정리해야 그다음 단계(설계, lib, fw)로 넘어갈 수 있는 자격이 주어지는 거라고 스스로 생각해서 꼭 해야겠다고 생각했다.\n\n## 그래서 그다음단계는? \n* 코드스피츠에서 front-end 관련해서 design pattern과 view Pattern을 정리/ project 완료하기  \n* react, node로 toy project 한 것 정리/ 확장\n    - 사용한 기술 정리를 통해서 공식 라이브러리 확인하기\n    - 스스로 개발지식을 습득하고 적용하는 연습\n* 알고리즘 문제를 풀면서 생각하는 연습을 지속해서 연습\n\n","excerpt":"개발자로 어떻게 살 것인가? 2020년 2월 4년 3개월차 개발자의 고민 작성  개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년…","fields":{"slug":"/개발자로 어떻게 살 것 인가/"},"frontmatter":{"date":"Feb 12, 2020","title":"개발자로 어떻게 살 것 인가?","tags":["생각정리"]}}},{"node":{"rawMarkdownBody":"\n자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.\n\n\n```js\n\t1 클래스와 인스턴스의 개념 이해\n\t2 자바스크립트의 클래스\n\t3 클래스 상속\n\t\t3-1 기본 구현\n\t\t3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n\t\t3-3 constructor 복구 하기 \n\t\t3-4 상위 클래스에 접근 수단 제공\n\t4 ES6의 클래스 및 클래스 상속\n\n```\n# 1 클래스와 인스턴스의 개념 이해\n* 클래스\n    - **공통 속성, 기능 정의한 추상적 개념**\n    - 클래스를 바탕으로 인스턴스를 만들 때 비로소 어떤 객체가 클래스의 속성을 지닌다.\n    - 어떤 인스턴스가 다양한 클래스에 속할 수는 있지만 이 클래스들은 모두 인스턴스 입장에서는 '직계존속'\n    - 다중상속을 지원하는 언어이든 그렇지 않은 언어이든 결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐일 수 밖에 없기 때문\n\n* 인스턴스\n    - 클래스에 속한 객체 \n\n* static member(static method, static properties)\n    - 클래스 자체에서만 동작\n* prorotype method\n    - 인스턴스에서 활용 가능\n\n# 2 자바스크립트의 클래스\n\n* 생성자 함수 Array를 new연선자와 함께 호출하면 인스턴스 생성 하는 과정을 통한 설명\n    - Array를 일종의 클래스라고 하면, **Array의 prototype 객체 내부 요소들이 인스턴스에 '상속'**된다고 볼 수 있다. \n        - **엄밀하게 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으로 동일하게 동작**\n    - ***한편 Array 내부 프로퍼티들 중 prorotype 프로퍼티를 제외한 나머지 인스턴스에 상속되지 않는다.***  \n    (=== static member: static method, static properties)\n\n    - 인스턴스에 상속되는지(인스턴스가 참조하는지) 여부에 따라 **\"static member\"(상속불가능)**와 **\"instance member\"(상속가능)**로 나뉜다.\n        - 이 분류는 다른 언어의 클래스 구성요소에 대한 정의를 차용한것으로 클래스 입장에서 사용대상에 따라 구분한것 \n        - 하지만 **자바스크립트는 다른 언어와 달리 인스턴스에서도 직접 메서드를 정의할 수 있다.**\n        - 그래서 '인스턴스 메서드'라는 명칭은 프로토타입에 정의한 메서드를 지칭하는 것인지 인스턴스에 정의한 메서드를 지칭하는것인지 혼란이 올 수 있다.  \n        따라서 **프로토타입에 정의한 메서드를 프로토타입 메서드라고 부른다.**\n\n\n    - 도식화 - Array constructor function\n    ![](class&instance.jpg)\n\n    - 도식화 - prorotype, \\_\\_proto__, instance\n    ![](class&instance2.jpg)\n\n*  실제 예제\n```js\n    function Person(name, age){\n        this._name = name;\n        this._age = age;\n    }\n\n    Person.getInformations = function(inst){    //Static emthod\n        return{\n            name: inst._name,\n            age: inst._age\n        };\n    }\n    Person.prototype.getName = function(){      //(prototype) method\n        return this._name;\n    }\n    Person.prototype.getAge = function(){       //(prototype) method\n        return this._age;\n    }\n\n\n    var yoon = new Person(\"happyjy\", 30);\n    console.log(yoon.getName());    //happyjy\n    console.log(yoon.getAge());     //30\n\n    console.log(yoon.getInformations(yoon));    \n    //에러! yoon.getInformations is not a function\n    //생성자 함수 property(getInformations)에는 인스턴스가 직접 접근하지 못한다.\n    //생성자 함수 property는 인스턴스로 상속할 수 있는 프로퍼티로 만들지 않는다.\n    console.log(Person.getInformations(yoon)); //{name: \"happyjy\", age: \"30\"}\n    //생성자 함수 property는 생성자 함수로만 접근이 가능하다.\n```\n\n\n# 3 클래스 상속\n## 3-1 기본 구현\n* 구현 point\n    1. 프로토타입 설정\n    2. contsructor 복구\n\n    ```js\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.name = name || '홍길동(setting by Employee function)';\n        this.age = age || 0;\n        this.position = position || '미정';\n    };\n\n    //1.prorotype 설정\n    Employee.prototype = new Person();      // 이 코드에 의해서 new Employee에 의해서 생성된 인스턴스.__proto__에 Person 인스턴가 세팅된다.\n    //2. constructor 복구\n    Employee.prototype.constructor = Employee;  // prototype에서 다뤘던 내용\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    };\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n- mac의 결과 값\n    - ***문제: mac.\\_\\_proto__에 추상적이어야할 클래스 prorotype 담겨 있는 것***\n    - 만약 delete mac.name이후 mac.getName을 하면 undefined가 return 되어야 하는데 prototype chain에 의해서 홍길동(mac.__proto__ property)이 반환된다.\n    - 그래서 아래 예제 \"prototype\"로 상속 구현하기에 extendClass에 의해서 문제를 해결할 수 있다. \n        - 문제 해결 방법 요약: 상속할때 parent, child class 사이에서 extend해주는 개념이 필요하다  \n        : 아래 3-2, 3-3, 3-4 capter에서 다루도록 하겠다.\n\n    ![](Employee상속.png)\n\n\n\n## 3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **1,2번** 참고 \n\n## 3-3 constructor 복구 하기 \n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **3번** 참고 \n\n## 3-4 상위 클래스에 접근 수단 제공\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **4번** 참고 \n\n* extend Class 구현 개념\n    - 아래 구현 예제 주석 1,2,3,4번 코드 참고\n![](extendClass.jpg)\n\n* extendClass구현으로 prototype상속 구현\n\n    ```js\n    //* es5에서 많이 사용해서 아래와 같이 클래스 상속을 구현 \n    //* 클로저를 생성해서 'Bridge'를 단한번만 사용할 수 있게 함 \n    var extendClass = (function(){\n        function Bridge(){}\n        return function(Parent, Child){\n            Bridge.prototype = Parent.prorotype;  //1번\n            Child.prototype = new Bridge();       //2번\n            Child.prototype.constructor = Child;  //3번\n            Child.prototype.superClass = Parent;  //4번\n        }\n    })();\n\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.superClass(name, age); //4번: 하위 클래스에서 이런 호출로 상위 클래스가 설정한 프로퍼티 세팅 가능\n        this.position = position || '미정'\n    }\n\n    \n    extendClass(Person, Employee);\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    }\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n* 결과 \n![](extendClass적용.png)\n\n* 짚고 넘어가자! - this.superClass에 대해서 \n    - this.superClass는 Parent object이기 때문에 Person constructor function에서 name, age설정\n    - Person constructor function에서 this.name, this.age에 설정 시 this scope은 \"Employee instance object\"라서 위 결과 처럼 name, age가 Employee instance property에 설정 된다.\n\n\n# 4 ES6의 클래스 및 클래스 상속\n* class로 상속 구현하기\n```js\n    class Person {\n        constructor (name, age) {\n            this.name = name || '아무개';\n            this.age = age || '0';\n        }\n\n        getName(){\n            return this.name;\n        }\n\n        getAge(){\n            return this.age;\n        }\n    }\n\n    class Employee extends Person {\n        constructor (name, age, position){\n            super(name, age);\n            this.position = position || '미정';\n        }\n        getPosition(){\n            return this.position;\n        }\n\n    }\n```\n\n\n# 참고 \n* 코어 자바스크립트","excerpt":"자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.…","fields":{"slug":"/class/"},"frontmatter":{"date":"Feb 11, 2020","title":"class","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\njavascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자. \n\n\n```js\n\t1 프로토타입의 개념 이해 \n\t\t1-1 constructor, prototype, instance\n\t\t1-2 constructor 프로퍼티\n\t2 프로토타입 체인\n\t\t2-1 메서드 오버라이드\n\t\t2-2 프로토타입 체인\n\t\t2-3 객체 전용 메서드의 예외사항\n\t\t2-4 다중 프로토타입 체인\n```\n\n# 1 프로토타입의 개념 이해 \n# 1-1 Constructor, prototype, instance\n\n* Constructor\n    - A function that initializes an object\n    - similar to normal javaconstuctor\n* prototype\n    - Constructor의 property\n    - instance의 property \\_\\_proto__과 메모리 공유  \n    : constructor.prototype === instance.\\_\\_proto__\n* instance\n    - Constructor를 new키워드로 호출로 생성한 객체\n\n* prototype 도식\n    ![](프로토타입도식.jpg)\n    * 왼쪽 꼭짓점: Constructor(생성자 함수)\n    * 오른쪽 꼭짓점: Constructor.prorotype 프로퍼티\n    * new를 통해 instance 생성\n    * instance.\\_\\_proto__\n\n* 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출하면\n    * Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성됩니다.\n    * 이때 instance에는 \\_\\_proto__라는 프포퍼티가 자동으로 부여\n    * 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조\n\n* prototype 개념의 핵심: prototype 프로퍼티, \\_\\_proto__라는 프로퍼티\n    * **prototype은 객체**\n    * **이를 참조하는 \\_\\_proto__도 객체**\n    * prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장\n    * 그러면 인스턴스에서도 숨겨진 프로퍼티인 \\_\\_proto__를 통해서 이 메서들을 접근할 수 있게 된다.\n\n    ```js\n    var Person = function(name) {\n        this._name = name;\n    }\n\n    Person.prototype.getName = function(){\n        debugger;\n        return this._name;\n    }\n\n    //---\n    typeof Person                   // function\n    typeof new Person('boa');       // object\n    new Person('boa');              // Person {_name: 'boa'}\n    new Person('boa').__proto__     // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    Person.prototype                // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    //---\n    \n    var boa = new Person('boa');\n    boa.__proto__.getName();    //undefined\n    boa.getName();              //boa\n    /*\n        boa.__proto__에 _name 프로퍼티가 없어 식별자(this._name)를 찾을 수 없다.\n        * boa.__proto__.getName();, boa.getName(); \n            - getName이 호출 돼 scope에 있는 this가 서로 다르다. 그래서 결과 값이 다르다.\n            - boa.__proto__ this -> {getName: f, constructor: f}\n            - boa this ->  Person {_name: 'boa'} \n\n    */\n\n    Person.prototype === boa.__proto__;\n    /*\n        Constructor function의 prototype으로 생성한 instnace 'boa'의 property '__proto__'객체는 Consytructor function의 객체는 메모리를 공유하고 있다.\n\n        이런 특징으로 \n        instance.__proto__ property를 변경하면 Constructor.prototype도 변경이 된다.\n        즉 instance.__proto__, Constructor.prototype 객체는 메모리를 공유하고 있따. \n    */\n\n    var boa = new Person('boa');\n    boa.__proto__._name = 'boa.__proto__';\n    boa.__proto__.getName() =               //Boa__proto__\n    /*\n        * boa.__proto__.getName() 에 의해서 호출된 getName의 this는 boa.__proto__\n        * \n    */\n\n    //---\n    \n    var iu = new Person('iu');\n    iu.getName(); // iu\n    \n    /*\n        iu.__proto__.getName \n        = iu(.__proto__).getName\n        = iu.getName\n    */\n\n\n    //---\n\n    var Constructor = function(name) {\n        this.name = name;\n        console.log(this);\n    }\n\n    Constructor.prototype.method = function(){};\n    Constructor.prototype.prototype1 = 'constructor Prototype property';\n\n    var instance = new Constructor('INSTANCE');\n    console.dir(Constructor);\n    console.dir(instance);\n    /*\n        Constructor.prototype === instance.__proto__\n    */\n\n\n    //--\n    var arr = [1,2];\n    console.dir(arr);\n    console.dir(Array);     //Array: 내장 생성자 함수\n\n    arr.forEach(function(){});  //\n    Array.isArray(arr);         //true\n    arr.isArray()               //TypeError: arr.isArray is not a function\n\n\n    ```\n\n# 1-2 constructor 프로퍼티\n\n```js\n    var arr = [1,2];\n    Array.prototype.constructor === Array;\n    arr.__proto__.constructor === Array;\n    arr.constructor === Array;\n\n    var arr2 = new arr.constructor(3,4);\n    console.log(arr2) //[3,4]\n```\n\n\n```js\nvar Person = function(name){\n    this.name = name;\n}\n\nvar p1 = new Person('인간1');                           //Person {name:\"인간1\"} true\nvar p1Proto = Object.getPrototypeOf(p1);\n\nvar p2 = new Person.prototype.constructor('인간2');     //Person {name:\"인간2\"} true\nvar p3 = new p1Proto.constructor('인간3');              //Person {name:\"인간3\"} true\nvar p4 = new p1.__proto__.constructor('인간4');         //Person {name:\"인간4\"} true\nvar p5 = new p1.constructor('인간5');                   //Person {name:\"인간5\"} true\n\n[p1, p2, p3, p4, p5].forEach(function(p){\n    console.log(p, p instanceof Person);\n})\n\n[constructor]\n[instance].__proto__.constructor\n[instance].constructor\nObject.getPrototypeOf([instance]).constructor\n[Contsructor].prototype.constructor\n\n[Constructor]\n[instance].__proto__\n[instance]\nObject.getPrototypeOf([instance])\n\n```\n\n# 2 프로토타입 체인\n\n# 2-1 메서드 오버라이드\n\n* 예제 \n    - 아래 메서드 오버라이드 전, 후 캡쳐 참고\n        ```js\n        var Person = function(name){\n            this.name = name;\n        }\n        Person.prototype.getName = function(){\n            return this.name;\n        }\n\n        var boa = new Person('보아');\n        boa.getName = function(){\n            return '이 사람은 ' + this.name;\n        };\n\n        console.log(boa);               // Person {name: \"보아\", getName: ƒ}\n        console.log(boa.getName());     // 이 사람은 보아\n\n        console.log(boa.__proto__.getNam());    // undefined\n        Person.prototype.name = '권보아';\n        console.log(boa.__proto__);             // {name: \"권보아\", getName: ƒ, constructor: ƒ}\n        console.log(boa.__proto__.getName());   // 이사람은 권보아\n        console.log(boa.__proto__.getName.call(boa));   // this를 명시적으로 선언\n        /*\n            메서드가 오버라이드된 경우에는 자신으로부터 가장 가까운 메서드에만 접근\n            그다음으로 가까운 __proto__의 메서드도 우회적인 방법을 통해서 접근 가능\n        */ \n        ```\n* 결과\n    - override 하기 전\n    ![](method_override.png)\n    \n                             \n    - override 후\n    \n    ![](method_override1.png)\n\n# 2-2 프로토타입 체인\n* Object의 내부 구조\n\n![](prototypeOfObject.png)\n\n* Array의 내부 구조\n![](prototypeOfArray.png)\n\n\n* Array 내부 도식화\n![](Array내부도식화.jpg)\n    - [1,2]는 Array.prototype, Object.prototype내부의 메서드를 자신의 것처럼 실행 할 수 있다. \n    - .\\_\\_proto__는 생략 가능하다\n    - 예시\n\n        ```js\n        var arr = [1,2];\n        arr(.__proto__).push(3);                            //3\n        arr(.__proto__)(.__proto__).hasOwnProperty(2);      //true\n        ```\n\n* 메서드 오버라이드와 프로토타입 체이닝\n\n```js\nvar arr = [1,2,3];\nArray.prototype.toString.call(arr);     //1,2,3\nObject.prototype.toString.call(arr);    //[object Array]\narr.toString();                         //1,2,3\n\narr.toString = function(){      //결과 아래 캡쳐 참고 \n    return this.join('_');\n};\narr.toString();                         //1_2_3\n```\n\n* arr 객체에 toString function 추가시 arr객체 내부\n\n    ![](Array객체에toString추가.png)\n\n\n# 2-3 객체 전용 메서드의 예외사항\n\n* Object.prototyp에 추가한 메서드의 접근\n    ```js\n    Object.prototype.getEntries = function(){\n        var res = [];\n        for (var prop in this){\n            if(this.hasOwnProperty(prop)){\n                res.push([prop, this[prop]]);\n            }\n        }\n        return res;\n    }\n\n    var data = [\n        ['object', {a: 1, b: 2, c:3}],\n        ['number', 345],\n        ['string', 'abc'], \n        ['boolean', false],\n        ['func', function(){}],\n        ['array', [1,2,3,4]]\n    ];\n\n    data.forEach(function(d){\n        console.log(d[1].getEntries());\n    })\n\n    ```\n    - 어떤 데이터 타입이건 거의 무조건 프로토타입 체이닝을 통해 getEntries 메서드에 접근 \n\n\n* 스태틱 메서드(객체한정메서드)\n    - 객체만을 대상으로 동작하는 객체 전용메서드들은 부득이 Object.prototype이 아닌 Object에 스태틱 메서드(static method)로 부여할 수 밖에 없다.\n    - 생성자 함수인 Object, 인스턴스 객체 리터럴 사이에는 this를 통한 연결이 불가능\n    - 전용 메서드 처럼 '메서드명 앞의 대상이 곧 this'가 되는 방식대신  \n    this의 사용을 포기하고 대상 **인스턴스를 인자로 직접 주입해야 하는 방식**으로 구현  \n    : 예시 Object.freeze({prop: 42})\n    - Object.prototype.consructor 하위 메서드 & Object.protptype 하위 메서드\n     ![](객체전용메서드&스태틱메서드.jpg)\n\n# 2-4 다중 프로토타입 체인\n* 새롭게 만드는 생성자 함수에 \\_\\_proto__를 연결해서 체인 관계를 만들수 있다.\n\n* Grade 생성자 함수와 인스턴스\n    ```js\n    var Grade = function(){\n        //arguments: 유사배열\n        var args = Array.prototype.slice.call(arguments);\n        for(var i=0; i<args.length; i++){\n            this[i] = args[i];\n        }\n        this.length = args.length;\n    }\n    var g = new Grade(100, 80);\n\n    Grade.prototype = [];   //POINT\n\n    var g1 = new Grade(10, 20);\n    g1.push(1);\n    console.log(g1);    //Grade(3) [10, 20, 1]\n    g1.shift()\n    console.log(g1);    //Grade(3) [20, 1]\n\n    ```\n    - 도식화 \n    ![](Grade생성자함수에배열proto.jpg)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"javascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자.  1 프로토타입의 개념 이해 1-…","fields":{"slug":"/prototype/"},"frontmatter":{"date":"Feb 08, 2020","title":"prototype","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다. \n\n\n```js\n\t1 클로저의 의미 및 원리 이해\n\t2 클로저와 메모리 관리\n\t3 클로저 활용사례\n\t\t3-1 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 \n\t\t3-2 접근 권한 제어(정보 은닉)\n\t\t3-3 부분 적용함수\n\t\t3-4 커링함수\n```\n\n\n# 1 클로저의 의미 및 원리 이해\n\n\n* 클로저란?  \n  : 함수형 프로그래밍 언어에서 등장하는 특징\n    > 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 **실행 컨텍스트가 종료된 이후에도 변수a가 사라지지 안는 현상**\n    > 내부함수를 외부로 전달하는 방법: 함수를 return하는 경우, callback으로 전달\n    - mdn 설명\n    > A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).  \n    > In other words, a closure gives you access to an outer function’s scope from an inner function. \n    > In JavaScript, closures are created every time a function is created, at function creation time.\n    \n\n* 외무 함수의 변수를 참조하는 내부 함수(1)\n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    outer();\n    ```\n    * inner함수 내부에서는 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 a를 찾는다. \n    * outer함수의 실행 컨텍스트가 종료되면 LexicalEnvironmentReference에 저장된 식별자들(c, inner)에 대한 참조를 지운다. \n        - 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 **컬렉터의 수집 대상**이된다.\n    * inner function안에서 closure 영역에 있는 변수는 'c' 하나 뿐이다. c1처럼 변수 선언만 하고 할당하지 않으면 메모리에 올라오지 않는다. \n\n* 외무 함수의 변수를 참조하는 내부 함수(2): outer 함수의 실행컨텍스트가 종료된 후 inner 함수를 호출하면?  \n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    var excuteInnerFunc = outer();\n    consl.log(excuteInnerFunc); // 2\n    consl.log(excuteInnerFunc); // 3\n    ```\n    * inner함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없습니다.\n    * outerEnvironmentReferenece에는 inner함수가 선언된 위치의 LexicalEnvironment가 참조복사\n    * inner함수는 outer함수 내부에서 선언됐으므로, outer함수의 Lexicalenvironment가 담김\n        - 위 단계로 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환\n        - inner함수의 실행 컨텍스트가 종료\n    * excuteInnerFunc를 두번째 호출하게 되면 위 단계를 걸쳐  2->3으로 증가한다.\n\n    * ***주의할점***\n        > inner함수의 실행시점에는 outer함수는 이미 실생 종료된 상태인데 outer함수의 Lexicalenvironment에 어떻게 접근할 수 있는걸까? \n        - 가비지 컬렉터의 동작 방식때문\n        - 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.\n        - 언젠가 inner함수의 실행컨텍스트가 활성화 되면 outerEnvironmentReferenece가 outer함수의 Lexicalenvironment를 필요로 할 것이므로 수집 대상에서 제외\n            - 그래서 inner함수 c 변수에 접근 가능\n\n* return 없이도 클로저가 발생하는 다양한 경우\n    ```js\n    (function(){\n        var a = 0 ;\n        var intervalId = null;\n        var inner = function() {\n            if (++a>9) {\n                clearInterval(intervalId);\n            }\n            console.log(a);\n        };\n        intervalId = setInterval(inner, 1000);\n    })()\n\n    // clouser&eventListener\n    (function(){\n        var count = 0;\n        var button = document.createElement('button');\n        button.innerText = 'click';\n        button.addEventListener('click', function(){\n            console.log(++count, 'times clicked');\n        });\n        document.body.appendChild(button);\n    })()\n    ```\n    ![clouser&eventListener](clouser&eventListener.png)\n\n# 2 클로저와 메모리 관리\n* 객체지향, 함수형 모두를 아우르는 중요한 개념\n* 클로저는 메모리 소모가가 있지만 이런 특성을 정확히 이해하고 잘 활용하도록 노력해야한다.     \n\n* closure를 GC가 수거하게 하는 방법\n    - 3장 예시에 POINT 주석 3개 참고   \n    ```js\n        //1번째 예시\n        var outer = function() {\n            var c = 1;\n            var c1\n            var inner = function() {\n                console.log(++c);\n            }\n            inner();\n        };\n        outer();\n        outer = null;   // POINT: outer실별자의 inner 함수 참조를 끊음\n        \n\n        //2번째 예시\n        (function(){\n            var a = 0 ;\n            var intervalId = null;\n            var inner = function() {\n                if (++a>9) {\n                    clearInterval(intervalId);\n                    inner = null;             // POINT: inner식별자의 함수 참조를 끊음  \n                }\n                console.log(a);\n            };\n            intervalId = setInterval(inner, 1000);\n        })();    \n\n        \n        //3번째 예시\n        // clouser&eventListener\n        (function(){\n            var count = 0;\n            var button = document.createElement('button');\n            button.innerText = 'click';\n\n            var clickHandler = function(){\n                //console.log(++count, 'times clicked');\n                if( ++count > 9 ){\n                    clickHandler = null;  //POINT: clickHandler 식별자 함수 참조를 끊음\n                }\n            };\n\n            button.addEventListener('click', clickHandler);\n            document.body.appendChild(button);\n        })()\n    ```\n\n# 3 클로저 활용사례\n\n## 3-1 Event Listener(콜백 함수 내부에서 외부 데이터를 사용하고자 할 때)\n\n* event Listener callback function\n    ``` js\n        var colorList = ['red', 'blue', 'white'];\n        var $ul = document.createElement('ul');\n\n        colorList.forEach(function(color){                  //(A)\n            var $li = document.createElement('li');\n            $li.innerText = color;\n            $li.addEventListener('click', function(){       //(B)\n                alert('your choice: ', color);\n            });\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n    ```\n    * (B)는 color라는 **클로저**가 있다. \n    * (A)는 colorList만큼의 **'실행 컨텍스트가 활성화 됨'**\n    * (B) outerEnvironmentReferenece가 (A)의 LexicalEnvironment참조  \n       -> **(B)함수가 참조할 예정인 변수 color에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능**\n\n\n* event Listener callback function에 bind 사용\n```js\n    var $ul = document.createElement('ul');\n    var colorList = ['red', 'blue', 'white'];\n    var consoleColor = function(color){\n        if(this === window){\n            //POINT3, POINT2\n            console.log('### this is window -> ' + this + \"/// callback function param: \" + color);\n            console.log(this);      //<li>blue</li>\n            console.log(color);     //MouseEvent\n            console.log('--------------------')\n        } else {\n            //POINT1\n            console.log('### this is HTMLElement -> this Value:' + this + \"/// callback function param: \" + color);\n            console.log(this);      //window\n            console.log(color);     //blue\n            console.log('====================')\n        }   \n    }            \n    \n    colorList.forEach(function(fruit){\n        var $li = document.createElement('li');\n        $li.innerText = fruit;\n        $li.addEventListener('click', consoleColor);                        //POINT 1: eventListener의 this, 첫번째 파라미터는 각각 '클릭한 dom', 'MouseEvent' 객체들이다.\n        $li.addEventListener('click', consoleColor.bind(this, fruit));      //POINT 2: forEach의 callback function에서 this는 windown!/ fruit는 clousre! \n        $ul.appendChild($li);\n    });\n    document.body.appendChild($ul);\n    \n    consoleColor(colorList[2]);                                             //POINT 3\n```\n    ![](callbackEg_EventListener.png)\n    \n    * POINT1,2,3의 consoleColor function의 console 확인 필요 \n    * POINT1,2의 this, 첫번째 param을 다시 상기 시켜보자.\n    * POINT2의 제약사항  \n        **- 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라지는 점은 감안해야한다.**\n\n        \n* event Listener에 고차 함수 사용\n    - 함수형 프로그램밍에서 자주 쓰이는 방식\n\n    ```js\n        var $ul = document.createElement('ul');\n        var colorList = ['red', 'blue', 'white'];\n        var consoleColor = function(color){\n            return function(){\n                console.log(color)\n            }\n        }            \n        \n        colorList.forEach(function(fruit){\n            var $li = document.createElement('li');\n            $li.innerText = fruit;\n            $li.addEventListener('click', consoleColor(fruit));\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n        \n    ```\n\n## 3-2 접근 권한 제어(정보 은닉)\n\n```js\n    var outer = function(){\n        var a = 1;                  //closure\n        var inner = function(){\n            return ++a;\n        }\n        return inner;\n    }\n    var outer2 = outer();\n\n    console.log(outer2());\n    console.log(outer2());\n```\n\n* outer함수는 외부(전역 스코프)로부터 철저하게 격리\n* 외부에서는 외부 공간에 노출돼 있는 outer라는 변수를 통해 outer함수를 실행할 수 있지만  \n, outer함수 내부에는 어떠한 개입도 할 수 없다.\n* **외부에서는 오직 outer함수가 return한 정보에만 접근할 수 있다.** (== return 값이 외부에 정보를 제공하는 유일한 수단)\n\n## 3-3 부분 적용함수\n\n```js\nvar add = function(){\n    var result = 0;\n    for(var i = 0; i < arguments.length; i++){\n        result += arguments[i];\n    }\n    return result;\n};\nvar addPartial = add.bind(null, 1,2,3,4,5);\nconsole.log(addPartical());             //15\nconsole.log(addPartial(6,7,8,9,10));    //55\nconsole.log(addPartical(10));           //25\n\n```\n## 3-4 커링함수\n* 여러 인자를 받은 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성\n\n* curring function eg\n    ```js\n\n    var curryFuncTest = function (func){\n        debugger;\n        return function(a){\n            debugger;\n            return function(b){ // getMaxWith10, getMinWith10 funciton\n                debugger;\n                return func(a,b);\n            };\n        };\n    };\n\n\n    var getMaxWith10 = curryFuncTest(Math.max)(10);\n    console.log(getMaxWith10(8));\n    console.log(getMaxWith10(25));\n\n    var getMinWith10 = curryFuncTest(Math.min)(10);;\n    console.log(getMinWith10(8));\n    console.log(getMinWith10(25));\n\n    ```\n![curryfunciton](curryfunction.png)\n\n* curring function with arrow function\n\n    ```js\n        var curryFuncTestWithArrowFunc = func => a => b => func(a,b);\n        var getMaxWith10WithArrowFunc = curryFuncTestWithArrowFunc(Math.max)(10);\n        console.log(getMaxWith10WithArrowFunc(8));\n        console.log(getMaxWith10WithArrowFunc(25));\n    ```\n\n* curring function 실제 사용 예\n\n    ```js\n    var getInfomation = function(baseUrl){                      // 서버에 요청할 주소의 기본 URL\n        return function (path) {                                // path값\n            return function (id) {                              // id    \n                return fetch(baseUrl + path + '/' + id);        // 실제 서버에 정보 요청\n            };\n        };\n    };\n\n    var getInformation = baseUrl => path => id => fetch(baseUrl + path + '/' + id);\n    var imageUrl = 'http://imgAddr.com/';\n\n    // 이미지 타입별 요청 함수 준비\n    var getImage = getInformation(imageUrl);    //http://imgAddr.com/\n    var getEmoticon = getImage('emoicon');      //http://imgAddr.com/emoticon\n    var getIcon = getImage('icon');             //http://imgAddr.com/icon\n\n    //실제 요청\n    var emoticon1 = getEmoticon(100);       //http://imgAddr.com/emoticon/100\n    var emoticon2 = getEmoticon(200);       //http://imgAddr.com/emoticon/200\n    var icon1 = getIcon(10);                //http://imgAddr.com/icon/10\n    var icon2 = getIcon(20);                //http://imgAddr.com/icon/20\n\n    ```\n\n    * 이런 이유로 최근 여러 프레임워크, 라이브러리 등에서 커링을 상당히 광범위하게 사용하고 있다.\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다.…","fields":{"slug":"/closure/"},"frontmatter":{"date":"Feb 05, 2020","title":"closure","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n```\n# 목차\n    * call() 정의\n    * call()을 생성자 연결에 사용\n    * call()을 익명함수와 함께 쓰기 \n    * call()호출시 this에 특정 값을 넣어 동작하기\n    * call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n    * call, apply함수의 비교(this에 특정 값 넣어 동작)\n    * bind()\n    * bind()함수 구현 해보기\n    * creating a bound function\n    * Partially applied functions\n    * with setTimeout()\n```\n\n# call() 정의\n> 주어진 this 값, 전달된 인수 와 함께 함수를 호출\n\n```js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\n\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n```\n\n# call()을 생성자 연결에 사용\n> function, method에 속해서 다른 객체를 호출한다.  \n> function, method에 this 값을 전해준다.  \n함수는 한번 쓰고 다른 객체에서 상속 받아 사용한다.(method를 다시 만들 필요 없이)\n``` js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price < 0) {\n    throw RangeError('Cannot create product ' +\n                      this.name + ' with a negative price');\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'food';\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'toy';\n}\n\nvar cheese = new Food('feta', 5);\nvar fun = new Toy('robot', 40);\n```\n\n\n# call()을 익명함수와 함께 쓰기 \n```js\nvar animals = [\n  { species: 'Lion', name: 'King' },\n  { species: 'Whale', name: 'Fail' }\n];\n\nfor (var i = 0; i < animals.length; i++) {\n  (function(i) {\n    this.print = function() {\n      console.log('#' + i + ' ' + this.species\n                  + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n//## 결과 \n//#0 Lion: Kinf\n//#1 Whale: Fail\n```\n\n# call()호출시 this에 특정 값을 넣어 동작하기\n> \n\n```js\nfunction greet() {\n  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n  console.log(reply);\n}\n\nvar obj = {\n  animal: 'cats', sleepDuration: '12 and 16 hours'\n};\n\ngreet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n# call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n> call로 호출될 function 안에 this의 bound는 global object이다  \n> 하지만 use stric을 사용 하용하면 undefined가 나온다. \n```js\nvar sData = 'Wisen';\n            \nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call();  // sData value is Wisen \n\n``` \n\n```js            \n'use strict';\n\nvar sData = 'Wisen';\n\nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call(); // Cannot read the property of 'sData' of undefined            \n```\n\n# call, apply함수의 비교(this에 특정 값 넣어 동작)\n```js\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.call(obj,\"Korea\",\"Seoul\"));\t\n//welcome to Korea in Seoul Jaeyoon\n\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.apply(obj,[\"Korea\",\"Seoul\"]));\t\t\n//welcome to Korea in Seoul Jaeyoon\n```\n\n\n\n\n\n\n# bind()\n> 함수와 객체를 서로 묶는 것이다.  \n> bind()함수는 새 함수를 반환한다.(call, apply는 바로 동작`)\n```js\nfunction f(y) { return this.x + y }    //바인드되어야 하는 함수\nvar o = {x:1};      //바인드될 객체\nvar g = f.bind(o);  //g(x)를 호출하면 o.f(x)가 호출된다.\ng(2)                //=>3\n```\n\n# bind()함수 구현 해보기 \n```js\nFunction.prototype.bind = function(obj){\n  //this와 인자 값을 변수에 저장함으로써 다음의 중첩 함수에서 사용할 수 있다.\n  var me = this, boundArgs = arguments;\n\n  //bind() 메서드의 반환 값은 함수다.\n  return function(){\n  //인자 목록을 작성하는데, 첫 번재 이후의 인자부터\n  //나머지 모든 인자를 이 함수에 전달 한다.\n  var args = [], i;\n  for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);\n  for(i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  \n  //인자들을 포함하여 obj의 메서드로 me를 호출한다.\n  return me.apply(obj, args);\n}\n```\n\n# creating a bound function\n\n```js\nthis.x = 9;    // this refers to global \"window\" object here in the browser\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nmodule.getX(); // return: 81 - The ufnction gets invoked at the module scope\nretrieveX();   // returns 9 - The function gets invoked at the global scope\n\n// Create a new function with 'this' bound to module\n// New programmers might confuse the global var x with module's property x\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n# Partially applied functions\n\n```js\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\nvar result1 = addArguments(1, 2); // 3\n\n// Create a function with a preset leading argument\nvar leadingThirtysevenList = list.bind(null, 37);\nvar list2 = leadingThirtysevenList(); // [37]\nvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n// Create a function with a preset first argument.\nvar addThirtySeven = addArguments.bind(null, 37); \nvar result2 = addThirtySeven(5); // 37 + 5 = 42 \nvar result3 = addThirtySeven(5, 10);// 37 + 5 = 42 , second argument is ignored\n\n```\n\n\n\n# with setTimeout()\n\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  // #POINT\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with '+ this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  \n// after 1 second, triggers the 'declare' method\n```\n","excerpt":"call() 정의 주어진 this 값, 전달된 인수 와 함께 함수를 호출 call()을 생성자 연결에 사용 function, method에 속해서 다른 객체를 호출한다. function, method에 this…","fields":{"slug":"/call(), apply(), bind()/"},"frontmatter":{"date":"Feb 02, 2020","title":"call(), apply(), bind()","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로\n\n```js\n\t1 콜백함수란?\n\t2 제어권\n\t\t2-1 호출시점\n\t\t2-2 인자\n\t\t2-3 this\n\t3 콜백 함수는 함수다\n\t4 콜백 함수 내부의 this에 다른 값 바인딩하기\n\t5 콜백 지옥과 비동기 제어\n```\n\n\n\n# 1 콜백함수란?\n> 다른 코드의 인자로 넘겨주는 함수(제어권도 함께 위임)\n> 콜백함수를 넘겨 받는 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행\n\n\n# 2 제어권\n> 호출시점, 인자, this 예제를 통해서 알아 보자\n## 2-1 호출시점\n> setInterval에 callback function은 '호출주체, 제어권'은 setInterval이다.\n```js\nvar count = 0;\nvar cbFunc = function() {\n    conosl.log(count);\n    if(++count > 3) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n```\n## 2-2 인자\n> 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.\n\n* callback function의 인자 값은 filter에 의해서 정해졌다.\n    ```js\n    var newArr = [1,2,3,4,5].filter(function(idx, val){\n        console.log({'this sceop': this, idx, val});\n        return val > 2;\n    }, {a:1, b:2});     // {a:1, b:2}코드에 대한 설명은 아래 2-3 this설명에서 알 수 있다.\n\n    console.log(newArr);    //[4,5]\n\n    /*\n        this sceop: {a: 1, b: 2}\n        idx: 1\n        val: 0\n        \n        this sceop: {a: 1, b: 2}\n        idx: 2\n        val: 1\n        \n        this sceop: {a: 1, b: 2}\n        idx: 3\n        val: 2\n        \n        this sceop: {a: 1, b: 2}\n        idx: 4\n        val: 3\n        \n        this sceop: {a: 1, b: 2}\n        idx: 5\n        val: 4\n    */\n    ```\n\n## 2-3 this\n\n* Array.prototype.map - 구현    \n    ```js\n    Array.prototype.filter = function(callback, thisArg){\n        var mappedArr = [];\n        for(var i=0; i < this.length; i++){\n            var mappedValue = callback.call(thisArg || window, this[i], i , this);  //POINT\n        }\n    }\n    ```\n    * 주석 POINT 설명\n        * thisArg || window  \n            : callback function에서 this의 scope을 명시적으로 바인딩\n            : 이 코드에 의해 filter의 두번째 param으로 callback의 this를 정해줄 수 있다.\n            : 2-2인자 챕터 코드 참고하기\n        * this  \n            : filter를 호출 한 array(이 내용은 prototype과 관련해서 더 설명할 수 있겠다.)  \n        * this[i]  \n            : 이 코드에 의해서 callback function의 첫번째 param array의 i번째 요소\n        * i  \n            : 이 코드에 의해서 callback function의 두번째 param array의 i번째\n    \n# 3 콜백 함수는 함수다\n* 메서드를 콜백함수로 전달한 경우\n    ```js\n    var obj = {\n        vals: [1,2,3],\n        logValues: function(v, i){\n            console.log(this, v, i);\n        }\n    }\n    \n    obj.logValues(10,20); //{vals: Array(3), logValues: f} 10 20\n\n    [10,20,30].forEach(obj.logValues);\n    /*\n        Window{...} 10 0\n        Window{...} 20 1\n        Window{...} 30 2    \n    */\n    ```\n    * forEach의 callback function은 코드에 의해서 호출된 logValues에서 this는 Window를 가르키고 있다.\n        - callback function으로 obj 객체에 의해서 this가 결정되지 않고 별도로 this를 명시하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 가르친다.\n        \n# 4 콜백 함수 내부의 this에 다른 값 바인딩하기\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (1/3)\n    ```js\n    var obj1 = {\n        name: 'obj1',\n        func: function() {\n            var me = this;             //POINT\n            return function(){\n                console.log(me.name);\n            };\n        }\n    };\n    var callback = obj1.func();\n    setTimeout(callback, 1000);\n    ```\n    * var me = this;는 closure scope에 등록\n    * setTimeout에 의해서 callback function이 호출 될때 me.name은 excute context에서 me.name 변수를 찾는다.\n    ![callback & scope & clousre](callback&scope&closure.png)\n\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (2/3)\n    * 예제1에서 만들었던 함수 재활용하는 방법 - cb2 확인해보자\n    ```js\n        var obj1 = {\n            name: 'obj1',\n            func: function() {\n                var me = this;              //POINT: closure\n                return function(){\n                    console.log(me.name);\n                };\n            }\n        };\n\n        var obj2 = {\n            name: 'obj2',\n            func: obj1.func\n        };\n\n        var cb1 = obj1.func().bind('cb1');\n        setTimeout(cb1, 1000);\n\n        var cb2 = obj2.func().bind('cb2');\n        setTimeout(cb2, 1500);\n\n        var obj3 = { name: 'obj3' }\n        var cb3 = obj1.func.call(obj3);        //POINT: obj1.func = function(){ var me this; return function(p1){ console.log() }} \n        setTimeout(cb3, 2000);\n\n        /*\n            # 결과\n                * cb1: undefined \"obj1\" \"callback1\"\n                * cb2: undefined \"obj2\" \"callback2\"\n                * cb3: obj3 obj1 callback3\n        */\n    ```\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (3/3)\n    * bind로 this를 명시한 function을 사용\n        ```js\n        var obj1 = {\n                name: 'obj1',\n                func: function() {\n                    console.log(this.name)\n                }\n        };\n        \n        setTimeout(obj1.func.bind(obj1), 1000);\n\n        var obj2 = {name:'obj2'};\n        setTimeout(obj1.func.bind(obj2), 1500);\n\n        /*\n            # 결과\n                * obj1\n                * obj2\n        */\n        ```\n\n\n\n# 5 콜백 지옥과 비동기 제어\n> 콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상\n> 주로 이벤트 처리, 서버통신과 같은 비동기적인 작업을 수행하기 위해서 이런 형태가 등장\n\n* 동기적인 코드\n    - 현재 실행중인 코드가 완료된 후에야 다음 코드를 실행하는 방식\n* 비동기적인 코드\n    - 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다.\n    - CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드 \n* 비동기적인 코드가 필요한 경우   \n    : 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아졌다.\n    - 실행대기(setTimeout)  \n        : 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류\n    - 실행대기(addEventListener)  \n        : 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기\n    - 보류(XMLhttpRequest)  \n        : 웹브라우저 자체가 아닌 별도의 대상에 무어가를 요청하고 그에 대한 응답이 왔을때 비로소 어떤 함수를 실행하도록 대기\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로…","fields":{"slug":"/callback/"},"frontmatter":{"date":"Feb 02, 2020","title":"callback function","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다\n\n# STEP\n* STEP1: 배열의 숫자형을 문자형으로 변환\n* STEP2: 문자형변환후 배열 요소를 자리를 바꿔가며 숫자 크기를 비교(문자열x)\n\n# code\n```js\nvar a = [3, 30, 34, 5, 9];\nvar b = [6, 10, 2];\n\nfunction solution(numbers) {\n    var answer = numbers.map(v => v + '')\n        .sort((a, b) => (b + a)* 1 - (a + b)*1)\n        .join('');\n\n    return answer[0] === '0' ? '0' : answer\n}\n```\n\n# 결과\n![](result.png)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다 STEP STEP…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 01, 2020","title":"배열로 조합할 수 있는 수중 가장 큰 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n상황에 따라서 달라지는 this를 정리해보려고 한다. \n```js\n    0 javascripot에서 this\n    1 상황에 따라 달라지는 this\n        1-1 전역 공간에서의 this\n        1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n            함수 vs 메서드\n            메서드 내부에서의 this\n        1-3 함수로서 호출할 때 그 함수 내부에서의 this\n            함수 내부에서의 this\n            메서드의 내부함수에서의 this\n            메서드의 내부 함수에서의 this를 우회하는 방법\n            this를 바인딩하지 않는 함수\n        1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n        1-5 생성자 함수 내부에서의 this\n    2 명시적으로 this를 바인딩하는 방법\n        2-1 call 메서드\n        2-2 apply 메서드\n        2-3 call/apply 메서드의 활용\n            유사배열객체에 배열 메서드를 적용\n            생성자 내부에서 다른 생성자 호출\n            여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n        2-4 bind 메서드\n            name 프로퍼티\n            상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n        2-5 arrow function의 예외사항\n        2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n```\n\n# javascripot에서 this\n* 다른 객제지향 언어와 this의 차이점 \n    * 다른 대부분의 객체지향 언어의 this: 클래스로 생성한 인스턴스 객체\n        * 클래스에서만 사용할 수 있기 때문에 헷갈리지 않거나 많지 않음\n    * 자바스크립트 this: **어디에서나 쓸 수 있음**\n        * 상황에 따라 this가 바라보는 대상이 달라짐\n        * ***문제를 해결하려면 원인을 알아야 하는데, 정확한 작동방식을 이해하지 못하면 원인을 해결하기 어려움***\n\n* this 확인으로 '함수, 객체(메서드)'의 구분할 수 있는 거의 유일한 방법\n\n# 1 상황에 따라 달라지는 this\n> this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정(실행컨텍스트 설명할때 설명됨)  \n> 아래 상황별로 this가 5가지 다른 값을 보여주는 내용을 설명\n\n## 1-1 전역 공간에서의 this\n> 전역 공간에서 this는 전역객체를 가리킨다. \n\n* 전역 변수와 전역객체\n    ```js\n    var a = 1;\n    console.log(a);         //1\n    console.log(window.a);  //1\n    console.log(this.a);    //1\n    ```\n* 위 결과 값이 같은이유는? \n    * 전역변수 선언시 javascrip engine이 전역객체의 프로퍼티로 할당\n    * javascript 모든 변수는 특정 객체의 프로퍼티로 등록되고 동작\n        * 특정객체: 실행컨텍스트의 LexicalEnvironment\n        * 전역컨텍스트의 경우 LexicalEnvironment는 전역객체를 그대로 참조(실행컨텍스트 도식화 그림 참고\n* 전역 변수를 접근하는 과정은? -> scope chain\n    * a에 접근하고자 하면 스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 '전역 스코프'의 LexcialEnvironment(전역객체)에서 해당 프로퍼티를 a를 발견해서 그 값을 반환하기 때문\n\n\n---\n* 전역변수와 전역객체의 차이점\n    * 전역객체의 프로퍼티로 할당한 경우에서는 삭제 o\n    * 전역변수로 선언한 경우에는 삭제 x\n\n        ```js\n        var b = 2;\n        delete b;   //false\n        console.log(b, window.b, this.b) //2 2 2\n\n        window.c = 3;\n        delete window.c;    //true\n        console.log(c, window.c this.c); // Uncaught ReferenceError: c is not defined\n        \n        ```\n\n\n## 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n### 함수 vs 메서드\n* 함수 호출시 this: 전역객체\n* 메서드로 호출시 this: 호출한 메서드\n    ```js\n    // 함수로서 호출\n    var obj = {\n        bar: function() {\n            var x = (function(){\n                        return this\n                    })();\n            return x;\n        }\n    };\n\n    obj.bar() === window //true\n\n\n\n    // 메서드로서 호출\n    var obj = {\n        bar: function() {\n            var x = (() => this)(); // 주의: use arrow funciton\n            return x;\n        }\n    };\n\n    obj.bar() === obj\t//true\n\n    ```\n\n## 1-3 함수로서 호출할 때 그 함수 내부에서의 this\n### 함수 내부에서의 this\n* this에는 호출한 주체 정보가 담기는데 어떤 함수를 함수로서 호출시 this 지정 안됨\n* 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.\n* **실행 컨텍스트가 지정되지 않은 경우 this는 전역 객체를 바라본다 -> 따라서 함수에서 this는 전역객체를 가리킨다.** \n\n### 메서드의 내부함수에서의 this\n* 실행순서1,2,3의 return value\n    - 실행순서1: {outer: f, outer2: f} === obj1\n    - 실행순서2: window{...}\n    - 실행순서3: {obj2Property: \"obj2Property\", innerMethod: ƒ}\n\n* POINT\n    - innerFunc에 console.log는 B, C에 의해서 호출이 되는데  \n    - B처럼 innerFunc이 함수로 호출될때는 this는 전역 변수를 가르킨다.\n    - C처럼 innerfunc이 메서도로 호출될때는 this는 호출한 대상을 가르킨다.\n        ```js\n        var obj1 = {\n            outer: function() {\n                console.log(this);  //실행순서 1 by A\n                var innerFunc = function(){\n                    console.log(this);  //실행순서 2 by B, 3 by C\n                }\n                innerFunc(); // B\n\n                var obj2 = {\n                    innerMethod: innerFunc,\n                    obj2Property: 'obj2Property' \n                };\n                obj2.innerMethod(); // C\n            },\n\n            outer2: function(){\n\n            }\n        };\n\n        obj1.outer(); // A\n        ```\n\n### 메서드의 내부 함수에서의 this를 우회하는 방법\n### this를 바인딩하지 않는 함수\n> 아래 예제 주석 참고\n* log 결과값\n    * [1]: {outer: f}\n    * [2]: window {...}\n    * [3]: {outer: f}\n    * [4]: window {...}\n    * [5]: {outer: f}\n\n    ```js\n    var obj1 = {\n        outer: function() {\n            console.log(this);  // [1]\n            var innerFunc = function(){\n                console.log(this); // [2]\n            }\n            innerFunc(); \n\n            var me = this;\n            var innerFunc2 = function(){\n                console.log(me);    // [3] POINT 메서드의 내부 함수에서의 this를 우회하는 방법\n                console.log(this);  // [4]\n            }\n            innerFunc2(); \n\n            var innerFunc3 = () => {\n                console.log(this);  // [5] POINT: this를 바인딩하지 않는 함수\n            }\n            innerFunc3();\n\n        }\n    };\n\n    obj1.outer(); \n    ```\n\n\n\n## 1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n> callback function의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정  \n> **특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.**  \n> 콜백 함수에 bind를 사용하여 2-4 bind](https://happyjy.github.io/this/#상위-컨텍스트의-this를-내부함수나-콜백함수에-전달하기)\n\n\n    ```js\n    setTimeout(function(){\n        console.log(this);      //window 객체 \n    }, 3000);\n\n    [1,2,3].forEach(function(v){\n        console.log(this, v);   //window 객체 \n    })\n\n    //event Callback function 참고\n    document.body.innerHTML += `<button id=\"a\"> 클릭 </button>`\n    document.body.querySelector('#a').addEventListener('click', function(e){\n        console.log(this, e);\n    })\n\n    ```\n    * \"button click event Callback function this\"과 \"id='a' dom\" 객체 비교 => **같다.**\n\n    ![](eventCallbackfunction.png)\n\n\n\n* addEventListner function 내부 구현 추측 \n    - addEventListner function this가 'document.body.querySelector('#a')' 이기 때문에  \n    이 값을 callback function을 call메서드를 이용해 명시적으로 this바인딩 할 수 있겠다.\n\n        ```js\n            addEventListener: function(a, callbackFunc){\n                ...\n                callbackFunc.call(this, event);\n                ...\n            }\n        ```\n\n## 1-5 생성자 함수 내부에서의 this\n> 생성자 함수에서 this는 생성될 인스턴스를 참조\n\n```js\nvar Dog = function(name, age) {\n    this.bark = 'RRRR';\n    this.name = name;\n    this.age = age;\n};\n\nvar hs = new Dog('행성', 2);\nvar girl = new Dog('소녀', 3);\nvar universe = new Dog('우주', 1);\n\nconsole.log(hs, girl, universe);\n/*\n    hs: Dog {bark: \"RRRR\", name: \"행성\", age: 2}\n    girl: Dog {bark: \"RRRR\", name: \"소녀\", age: 3}\n    universe: Dog {bark: \"RRRR\", name: \"우주\", age: 1}\n*/\n\nconsole.log({bark: hs.bark, name: hs.name, age:hs.age})\n/*    \n    {bark: \"RRRR\", name: \"행성\", age: 2}\n*/\n\n```\n\n* 위 두 console.log를 확인했을때 Dog에의해서 생성된 instance가 this가 된것을확인 할 수 있다.\n\n# 2 명시적으로 this를 바인딩하는 방법\n> 2 이 목차는 call(), apply(), bind()에 대해서 자세하게 다루도록 위해서 다른 포스트에서 설명하도록한다.\n[call(), apply(), bind()](https://happyjy.github.io/call(),%20apply(),%20bind())\n\n\n## 2-1 call 메서드\n## 2-2 apply 메서드\n## 2-3 call/apply 메서드의 활용\n### 유사배열객체에 배열 메서드를 적용\n### 생성자 내부에서 다른 생성자 호출\n### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n## 2-4 bind 메서드\n### name 프로퍼티\n### 상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\n```js\nvar obj ={\n    outer: function(){\n        console.log(this);               //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);           //{outer: ƒ, outer2: ƒ}\n        }\n        innerFunc.call(this);       //POINT\n    },\n\n    outer2: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          //{outer: ƒ, outer2: ƒ}\n        }.bind(this);               //POINT\n        innerFunc();\n    },\n\n    outer3: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          // window{...}\n        }                            //POINT\n        innerFunc();\n    }\n}\n\nobj.outer();\nobj.outer2();\nobj.outer3();\n\n```\n\n## 2-5 arrow function의 예외사항\n* [this를 바인딩하지 않는 함수 목차 참고](https://happyjy.github.io/this/#this를-바인딩하지-않는-함수)\n\n\n\n## 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n``` js\n    var report = {\n        sum: 0,\n        count: 0,\n        add: function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.forEach(function(arg, idx){\n                debugger;   //idx가 0일때 this -> {sum: 0, count: 0, add: ƒ, average: ƒ}    :report 객체\n                this.sum += arg;\n                ++this.count;\n            }, this);       //POINT\n        },\n        average: function(){\n            return this.sum / this.count;\n        }\n    }\n\n    report.add( 10, 20, 30 );\n    console.log({sum: report.sum, count: report.count, average: report.average()});\n    //{sum: 60, count: 3, average: 20}\n```\n* 만약 위 코드에서 POINT 부분 forEach function에 두번째 parameter \"thisArg\"가 없었다면\nthis.sum += entry;에서 this는 window객체를 가르키기 때문에 console.log 결과는 아래와 같다.\n>{sum: 0, count: 0, average: NaN}\n\n* 콜백함수와 함께 thisArg를 인자로 받는 메서드  \n```js\n    Array.prototype.forEach(callback[, thisArg]);\n    Array.prototype.map(callback[, thisArg]);\n    Array.prototype.filter(callback[, thisArg]);\n    Array.prototype.some(callback[, thisArg]);\n    Array.prototype.every(callback[, thisArg]);\n    Array.prototype.find(callback[, thisArg]);\n    Array.prototype.findIndex(callback[, thisArg]);\n    Array.prototype.flatMap(callback[, thisArg]);\n    Array.prototype.from(callback[, thisArg]);\n    Set.prototype.forEach(callback[, thisArg]);\n    Map.prototype.forEach(callback[, thisArg]);\n```\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"상황에 따라서 달라지는 this를 정리해보려고 한다.  javascripot에서 this 다른 객제지향 언어와 this의 차이점  다른 대부분의 객체지향 언어의 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Feb 01, 2020","title":"this","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["javascript"]}}},{"node":{"rawMarkdownBody":"\n개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다.\n\n\n```js\n\t1 실행 컨텍스트란? \n\t2 VariableEnvironment\n\t3 LexicalEnvironment\n\t\t3-1 environmentRecord와 hoisting\n            호이스팅 규칙  \n            함수 선언문과 함수 표현식\n      \n\t\t3-2 scope, scope chain, outerEnvironmentReference\n            스코프 체인\n            전역변수와 지역변수\n\n\t4 this\n```\n\n\n# 1 실행 컨텍스트란? \n> * 실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> * 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념  \n> * 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(=호이스팅), 외부환경정보를 구성, this값을 설정  하는 동작 수행    \n-> 이로인해 다른언어에서는 발견할 수 없는 특이한 현상들이 발생\n\n* 코드 실행시 실행 컨텍스트\n    - '동일한 환경'에 있느 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 \n    - 이를 콜 스택에 쌓아올렸다가\n    - 가장 위에 쌓여있는 컨텍스트와 관련 잇는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장\n\n* '동일한 환경'(하나의 실행 컨텍스트)을 구성할 수 있는 방법\n    - 전역공간, evan()함수, 함수 등이 있음\n    - eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것\n\n* javascript engine 역할\n  - 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 '필요한 환경정보들'을 수집해서 실행 컨텍스트 객체에 저장\n  - 이 객체는 javascript engine이 활용할 목적으로 생성(개발자가 코드를 통해 확인할 수 x)  \n  - 담기는 정보 세가지  \n    : 목차 2, 3, 4에서 각각 더 자세하게 설명하도록 한다. \n  ```txt\n    VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. \n                            : 선언 시점의 LexicalEnvironment의 스냅샷 \n                            : 변경 사항은 반영되지 않음\n    LexicalEnvironment  : 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영\n    ThisBinding         : this 식별자가 바라봐야 할 객체\n  ```\n\n* 활성화된 실행 컨텍스트의 수집정보\n\n``` \n  * inner \n      Variableenvironment : environmentRecord(snapshot)/ outerEnvironmentReferenece(snapshot)\n      LexicalEnvironment  : environmentRecord/ outerenvironmentReferenece\n      ThisBindding\n  * outer\n  * 전역 컨텍스트\n```\n  \n# 2 VariableEnvironment\n* LexicalEnvironment와 같지만 최초 실행 시의 스탭 샷을 유지한다는점이 다름\n* 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음,  \n  이를 그대로 복사해서 Lexical environment를 만들어  LexicalEnvironment를 주로 활용하게 된다.\n* Variableenvironment, LexicalEnvironment의 내부는 **environmentRecord와 outerEnvironmentReference**로 구성\n  - 초기화 과정 중에는 사실상 완전히 동일, 이후 코드 진행에 따라 서로 달라짐\n  - 자세한 내용은 LexicalEnvironment를 통해 설명\n\n# 3 LexicalEnvironment\n* 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것 \n\n## 3-1 environmentRecord와 hoisting\n* js engine은 컨텍스트 내부 전체를 처음부터 쭉 훑어나가며 순서대로 수집 = \"호이스팅 개념\"  \n(= 식별자들을 최상단으로 끌어올려놓은 다음 실제코드를 실행-실제로 끌어 올리는 것이 아님, 편의상 끌어올린것으로 간주-)\n  - 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태\n  - 코드가 실행되기 전임에도 불구하고 js engine은 이미 해당 환경에 속한 코드의 변수명들으 모두 알고 있게 된다.\n                                                                \n### 호이스팅 규칙\n* environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다\n* 예시\n  * 함수 선언문으로 선언한 함수는 hoisting 대상\n  * 함수 표현식은 hosisting 대상 x\n\n  ```js\n  function a(){\n      console.log(b);   //ƒ b() {}\n      var b; \n      console.log(b);   //ƒ b() {}\n      function b() {};  //함수 선언문\n      console.log(b);   //ƒ b() {}\n\n      console.log(c);   //undefined\n      var c = function() {}\n  }\n  ```\n\n\n\n### 함수 선언문과 함수 표현식\n* 함수를 정의하는 세가지 방식\n  * 함수 선언문: 반드시 함수명이 정의 돼 있어야 함/ hoisiting이 됨\n  * 함수 표현식: 함수명이 없어도 됨           / hoisiting이 안 됨\n  * 기명 함수 표현식: 함수명을 정의한 함수 표현식\n\n```js\nfunction a() {} //함수 선언문\na();\n\n//상대적으로 긴 코드 속에서 함수 표현식이 안전한다.\nvar b = function() {} //(익명) 함수 표현식\nb();\n\nvar c = function d() {} // 기명 함수 표현식. 변수명: c, 함수명 d\nc(); // 실행\nd(); // error\n\n```\n\n## 3-2 scope, scope chain, outerEnvironmentReference\n* scope: 식별자에 대한 유표범위\n  * ES5까지의 자바스크립트는 특이하게도 전역 공간을 제외하면 오직 함수에 의해서만 스코프가 생성\n* scope chain: 이런 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것\n* outerEnvironmentReference: 스코프체인을 가능하게 하는 것이 바로 Lexicalenvironment의 두번째 수집자료인 outerEnvironmentReferenece\n\n### scope chain\n* outerEnvironmentReferenece는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조\n  - 아래 예시1 scopechain 도식화 참고\n* 과거 시점인 '선언될 당시'는 행위가 실제로 일어 날 수 있는 시점이란?  \n  - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐\n  - 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문\n\n* scope chain 예1\n  1. A함수 내부에 B함수 선언, B함수 내에 C함수 선언\n  2. 함수 C의 outerEnvironmentReferenece는 함수 B의 LexicalEnvironment를 참조 \n  3. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReferenece는 ***다시 함수 B가 선언되던 때*** A함수의 LexicalEnvironment를 참조 \n  4. 이처럼 outerEnvironmentReferenece는 연결리스트 형태를 띤다.\n  5. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것'  \n\n* 위 예시로본 특징 \n  - 예시 3번에서 본것 처럼 각 outerEnvironmentReferenece는 오직 자신이 선언된 시점의 LexicalEnvironment만 침조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능\n  - 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능** \n\n* scope chain 예1 코드\n```js\n/*01*/ var a = 1;\n/*02*/ var outer = function () {\n/*03*/   var inner = function () {\n/*04*/     console.log(a);\n/*05*/     var a = 3;\n/*06*/  };\n/*07*/   inner();\n/*08*/   console.log(a);\n/*09*/ };\n/*10*/ ouer();\n/*11*/ console.log(a);\n```\n* scope chaing 예1 코드 도식화\n    * 그림을 보면서 라인별로 어떤 동작을 하는지 생각해보자\n    ```\n      LE: Lexical Envinronment\n      e: environmentRecord\n      o: outerEnvironmentReference\n    ```\n    ![](context.jpeg)\n\n\n* **전역 컨텍스트 활성화**\n  * 0: LexicalEnvironment, VariableEnvironment, thisBinding\n\n* 전역 컨텍스트 생성/ outer 함수 호출\n  * 1,2: a에 1, outer에 함수 할당\n  * 10: outer 함수호출, 전역 컨텍스트 비활성화\n  * 2: outer실행 컨텍스트 활성화\n\n* outer 컨텍스트 생성/ inner 함수 호출\n  * 3: inner에 함수 할당\n  * 7: inner 함수 호출, outer 실행 컨텍스트 비활성화\n  * 3: inner 실행 컨텍스트 활성화 \n\n* inner 함수 수행\n  * 4: inner의 LE에서 a 탐색 -> undefined 출력\n  * 5: a에 3할당\n\n* inner 컨텍스트 종료 \n  * 6: inner 함수 종료, inner 실행 컨텍스트 제거\n  * 7: outer 실행 컨텍스트 재활성화\n  * 8: outer의 LE에서 a탐색 -> GLOBAL의 LE에서 a 탐색 -> 1출력\n\n* outer 컨텍스트 종료 \n  * 9: outer함수 종료, outer 실행 컨텍스트 제거 \n  * 10: 전역 컨텍스트 재활성화 \n  * 11: GLOBAL의 LE에서 a탐색 -> 1출력\n\n\n* outer컨텍스트 \n\n```js\n\"전역 컨텍스트\": {\n    environmentRecord: 'a, outer function',\n    outerEnvironmentReferenece: null,\n    this: window\n}\n\n\"outer컨텍스트\": {\n    environmentRecord: ['inner function'], \n    outerEnvironmentReferenece: 'GLOBAL LexicalEnvironment',\n    this: window\n}\n\n\"inner컨텍스트\": {\n    environmentRecord: ['a'], \n    outerEnvironmentReferenece: 'outer 컨텍스트',\n    this: window\n}\n```\n\n### 전역변수와 지역변수\n* 전역변수: 전역 공간에서 선언\n* 지역변수: 함수 내부에서 선언\n\n# 4 this\n* 실행컨텍스트의 thisBinding에 this로 지정된 객체가 저장\n* 실행컨텍스 활성 당시 this가 지정되지 않은경우 \"전역객체\" 저장\n* 함수 호출하는 방법에 따라 this가 달라진다.(this에 대해서만 내용을 다룰 예정)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n* 제로초 블로그\n","excerpt":"개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다. 1 실행 컨텍스트란? 실행컨텍스트(execution context…","fields":{"slug":"/Excute-context/"},"frontmatter":{"date":"Jan 24, 2020","title":"실행 컨텍스트","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6"]}}},{"node":{"rawMarkdownBody":"\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말할 수 있는 아니었다.\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있어 연예인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴져 멋있었고 떠먹기만 하면 되는 상황에서 감사한 마음이 들었다. 그래서 한편으론 실제로 적용하는 생각 연습과 다른 사람에게 효과적으로 전달 할 수 있는 고민을 하고 싶었다. (그래서 블로그에 자바스크립트 내용을 정리하는 연습을 해보려고 한다. -현재(2020.01 시작) 진행 중-) 그리고 책을 보면서 업무를 하며 익혔던 자바스크립트 내용을 상기하는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\njavascript를 더 깊게 알고 싶은 분에게 추천해주고 싶은 책이다.\n\n\n","excerpt":"이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트후기/"},"frontmatter":{"date":"Jan 20, 2020","title":"코어자바스크립트 후기","tags":["javascript","독서후기"]}}}]}},"pageContext":{}}}