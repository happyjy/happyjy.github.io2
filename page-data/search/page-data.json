{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"# 문제 설명\n트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. \n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. \n트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.  \n※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.\n\n예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.\n\n```\n경과 시간\t    다리를 지난 트럭\t    다리를 건너는 트럭\t     대기 트럭\n0\t          []\t              []\t                [7,4,5,6]\n1~2\t        []\t              [7]\t                [4,5,6]\n3\t          [7]\t              [4]\t                [5,6]\n4\t          [7]\t              [4,5]\t              [6]\n5\t          [7,4]\t            [5]\t                [6]\n6~7\t        [7,4,5]\t          [6]\t                []\n8\t          [7,4,5,6]\t        []\t                []\n```\n따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.\n\nsolution 함수의 매개변수로 다리 길이 bridgelength, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truckweights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.\n\n# 제한 조건\n* bridge_length는 1 이상 10,000 이하입니다.\n* weight는 1 이상 10,000 이하입니다.\n* truck_weights의 길이는 1 이상 10,000 이하입니다.\n* 모든 트럭의 무게는 1 이상 weight 이하입니다.\n\n# 입출력 예\n```\nbridge_length\tweight\ttruck_weights\t                    return\n2\t            10\t    [7,4,5,6]\t                        8\n100\t          100\t    [10]\t                            101\n100\t          100\t    [10,10,10,10,10,10,10,10,10,10]\t  110\n```\n\n# 해결 방법 \nSTEP1,2에서는 다리 위로 트럭이 지나갈 수 있는지 조건 사전 확인 단계, STEP3은 트럭이 다리위로 올릴 수 있는지 확인, STEP4는 트럭 이동, STEP5는 while문의 종단점(트럭이 다리를 다지나간 경우)\n\n* STEP1.\n    - filter: 다리에서 트럭움직인 거리가 다리 길이보다 작은 것\n* STEP2.\n    - 다리위에 있는 트럭 무게 계산\n* STEP3.\n    - 트럭을 하나 더 다리위로 올릴 수 있을지 판단\n    - <u>**핵심**: 다리 상태(올라가있는 트럭부게, 이동거리)를 확인할 수 있는 dictionary Object를 statusBridge배열에 push한다.</u>\n* STEP4.\n    - 트럭을 1만큼 움직인다.\n* STEP5.\n    - 다리상태, 트럭을 담은 배열이 0이라면 while문을 벗어난다. \n\n# 추가 정보: dictionary Object\n* \"forEach, map\"에서 배열 요소가 dictionary object가 인자인 배열은 dictionary Object property를 변경할 수 있다.\n하지만 숫자만 있는 배열은 변하지 않는다. \n* dictionary object가 배열 요소로 있을 경우 map사용으로 새로운 배열을 만들어 내는것이 좋겠다. \n    - map으로 순회할 대상 배열도 변경이 된다. 아래 map 예제에 확인 부분을 확인해보자\n\n* forEach에서 \n```js\n    var a = [1,2,3];\n    a.forEach(v => ++v);\n    //a => [1,2,3]\n\n    var b = [{dist:1}, {dist:2}, {dist:3}];\n    var bb = b.forEach(v => ++v.dist);\n    //b  => [{dist:2}, {dist:3}, {dist:4}]\n    //bb => [{dist:2}, {dist:3}, {dist:4}]\n```\n\n* map에서 \n```js\n    map에서 확인\n    var a = [1,2,3];\n    var aa = a.map( v => ++v );\n    //a  : [1,2,3]\n    //aa : [2,3,4]\n\n    var b = [{dist:1}, {dist:2}, {dist:3}];\n    var bb = b.map( v => (++v.dist, v));\n    //b  : [{dist:2}, {dist:3}, {dist:4}]   <- 확인!\n    //bb : [{dist:2}, {dist:3}, {dist:4}]\n```\n\n# CODE\n```js\n    function solution(bridge_length, weight, truck_weights) {\n        var answer = 0;\n        var statusBridge = [];\n\n        while(true) {\n            answer++;\n\n            //1. filter: 다리에서 트럭움직인 거리가 다리 길이보다 작은 것\n            statusBridge = statusBridge.filter(o => o.dist < bridge_length);\n\n            //2. 다리위에 있는 트럭 무게 계산\n            let currentWeight = statusBridge.map(v => v.weight).reduce((p, c) => p + c, 0);\n\n            //3. 트럭을 하나 더 다리위로 올릴 수 있을지 판단\n            if(weight - currentWeight >= truck_weights[0]) {\n                let truck = {\n                    weight: truck_weights.shift(),\n                    dist: 0\n                }\n                statusBridge.push(truck);\n            }\n\n            //4. 트럭을 1만큼 움직인다.\n            statusBridge.map(o => (++o.dist, o));\n\n            //5. 다리상태, 트럭을 담은 배열이 0이라면 while문을 벗어난다. \n            if(!statusBridge.length && !truck_weights.length)\n                break;\n        }\n\n        return answer;\n    }\n```\n","excerpt":"문제 설명 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. \n모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. \n트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length…","fields":{"slug":"/다리위로트럭지나가기/"},"frontmatter":{"date":"Mar 21, 2020","title":"스택,큐_다리위로 트럭지나가기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 설명\n프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.\n또, <u>각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</u>\n\n먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 \n각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.\n\n# 제한 사항\n작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.\n작업 진도는 100 미만의 자연수입니다.\n작업 속도는 100 이하의 자연수입니다.\n배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.\n\n# 입출력 예\n```\nprogresses\tspeeds\t    return\n[93,30,55]\t[1,30,5]\t[2,1]\n```\n# 입출력 예 설명\n\n* 첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\n* 두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다.\n하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.\n* 세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.\n* 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.\n\n\n# 해결 방법 - solutino1\n* STEP1.\n    - 프로세스 별로 며칠 뒤 배포 가능한지 새로운 배열을 만들어 낸다.\n* STEP2. [!중요]\n    - STEP1에서 구한 배포가능한 날짜의 배열 요소를 순회하면서 배열 순차적으로 배포가 가능한데 배포하는 날짜에 이후에 배포할 기능이 이미 완료 되어 있으면 같이 배포 할 수 있기 때문에 배포할때 몇개의 기능을 배포 할 수 있는지 확인하는 알고리즘이 들어 있다.\n* STEP2.1 [!중요]\n    - j의 역할: solution의 return 배열의 요소 \n* STEP2.2 [!중요]\n    - compareTargetLeftDays가 days에 있는 배포 하는 날짜보다 작으면 비교했던 days배열에 있던 요소를 compareTargetLeftDays로 바꿔주고 계속 days 배열을 순회한다.\n\n# 추가 정보: dictionary Object\nforEach에서 배열 요소가 dictionary object가 인자인 배열은 dictionary Object property를 변경할 수 있다.\n하지만 숫자만 있는 배열은 변하지 않는다. \n\n하지만 dictionary object가 배열 요소로 있을 경우 map사용으로 새로운 배열을 만들어 내는것이 좋겠다. \n\n```js\nvar a = [1,2,3];\na.forEach(v => console.log(++v));\n//[1,2,3]\n\nvar a = [{dist:1}, {dist:2}, {dist:3}];\na.forEach(v => v.dist++);\n//0: {dist: 2} 1: {dist: 3} 2: {dist: 4}\n```\n\n# solution1\n```js\n  function solution(progresses, speeds) {\n      //STPE1.  progresses, speeds를 이용해 각 progresses index의 인자가 몇일 뒤에 완료 되는지 days array에 넣는다.            \n      //STEP2.1 leftDays 첫번째 남은 배포일을 기준보다 leftDays 배열을 순회 하면서 요소 값보다 크거나 같으면 같이 배포하는것이고 작으면 다음날 다로 배포하는 것\n\n      let answer = [0];\n      //STEP1\n      let leftDays = progresses.map((progress, index) => Math.ceil((100 - progress) / speeds[index]))\n      let compareTargetLeftDays = leftDays[0];\n\n      //STEP2\n      //STEP2.1\n      for (let i = 0, j = 0; i < leftDays.length; i++) {\n          if (leftDays[i] <= compareTargetLeftDays) {\n              answer[j] += 1; //\n          } else {\n              answer[++j] = 1;\n              // STEP2.2 \n              compareTargetLeftDays = leftDays[i]; \n          }\n      }\n\n      return answer;\n  }\n```\n\n# solution2\n```js\n  //STEP1. 완료되는 날짜를 Math.ceil을 사용하지 않은 예\n  function solution2(progresses, speeds) {\n      var answer = [];\n\n      var leftDaysToDeploy = [];\n      var spendDays, functionCnt = 0;\n      //STEP1\n      for (var i = 0; i < progresses.length; i++) {\n          spendDays = 0;\n          while (1) {\n              spendDays++;\n              progresses[i] += speeds[i];\n              if (progresses[i] >= 100) {\n                  break;\n              }\n          }\n          leftDaysToDeploy.push(spendDays);\n      }\n\n      spendDays = leftDaysToDeploy[0];\n      functionCnt = 1;\n      for (var i = 1; i < leftDaysToDeploy.length; i++) {\n          if (leftDaysToDeploy[i] <= spendDays) {\n              functionCnt++;\n          } else {\n              spendDays = leftDaysToDeploy[i];\n              answer.push(functionCnt);\n              functionCnt = 1;\n          }\n\n          //index i가 leftDaysToDeploy array에 맨뒤로 갔을때 무조건 push\n          if (i === leftDaysToDeploy.length - 1) {\n              answer.push(functionCnt);\n          }\n      }\n\n      return answer;\n  }\n```\n","excerpt":"문제 설명 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 10…","fields":{"slug":"/배포가능기능개수/"},"frontmatter":{"date":"Mar 21, 2020","title":"스택,큐_배포시 배포 가능한 기능 개수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. \n이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다.\n이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.\n\n1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.\n2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.\n3. 그렇지 않으면 J를 인쇄합니다.\n\n예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.\n\n내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.\n\n현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, \n<u>내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록</u> solution 함수를 작성해주세요.\n\n# 제한사항\n* 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.\n* 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.\n* location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.\n\n# 해결 방법 \n* POINT1: dictionaryPriorities 생성(dictionary Object가 인자인 배열)\n* POINT2: 우선순위 규칙에 따라 재정렬 \n* POINT3: 결과값 filter(POINT1, POINT2에서 설정한 target, idx 정보로 filter)\n\n# STEP\n* POINT1: dictionaryPriorities 생성(dictionary Object가 인자인 배열)\n    - Priority에 언제 출력되지 알고 싶은 location 위치 정보를 추가한 dictionaryPriorities를 추가합니다.\n\n* POINT2: 우선순위 규칙에 따라 재정렬 \n* POINT2.1\n    - 배열 첫번째 인자 priority가 나머지 배열 인자들과 비교\n* POINT2.2\n    - 나머지 배열 인자에 더 큰수가 있다면 배열 맨뒤에 push\n* POINT2.3\n    - 배열 첫번째 요소에 priority가 나머지 인자보다 크면 배열 제일 앞에 위치한다.\n* POINT2.4\n    - 정렬이 완료된 배열에 결과로 얻을 index값을 추가 합니다.\n\n* POINT3: 결과값 filter\n    - POINT1 에서 설정한 target이 true일때 POINT2.4에서 설정한 idx값을 결과 값으로 반환합니다.\n\n# CODE\n```js\n    function solution(priorities, location) {\n        let answer = 0;\n\n        //POINT1\n        let newPriorities = priorities.map((priority, idx) => {\n            return {\n                target: idx === location,\n                priority: priority\n            }\n        })\n\n        //POINT2\n        let flag = true;\n        while (flag) {\n            let firstOne = newPriorities.shift();\n            // let firstOne = newPriorities.splice(0, 1)[0];//배열 첫번째 인자 빼내기\n            if (newPriorities.some(item => item.priority > firstOne.priority)) { //POINT2.1\n                newPriorities.push(firstOne); //POINT2.2\n            } else {\n                newPriorities.unshift(firstOne); //POINT2.3\n                newPriorities.map((v,i) => v.idx = ++i); //POINT2.4\n                flag = false;\n            }                 \n        }\n\n        return newPriorities.filter( v => v.target)[0].idx; //POINT3\n    }\n\n    console.log(solution([1, 2, 3, 2], 0 )); // 답:3 3,2,1,2 \n    console.log(solution([1, 2, 3, 2], 4 )); // 답:3 3,2,1,2 \n    console.log(solution([2, 1, 3, 2], 2));  // 답:1 3,1,2,2\n```\n\n# 추가 설명\n## some, filter의 차이점 \n* return value가 다르다. some은 배열에 조건에 해당하면 boolean value를 반환하고 filter는 조건에 해당하는 배열을 반환한다.","excerpt":"…","fields":{"slug":"/우선순위알고리즘프린터/"},"frontmatter":{"date":"Mar 21, 2020","title":"스택,큐_우선순위 알고리즘이 있는 프린터","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"# 문제 설명\n수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.\n\n예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. \n높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고,\n높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이,\n높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. \n높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다.\n```\n송신 탑(높이)\t수신 탑(높이)\n    5(4)\t    4(7)\n    4(7)\t    2(9)\n    3(5)\t    2(9)\n    2(9)\t    -\n    1(6)\t    -\n```\n맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요.\n    \n    \n# 제한 사항\nheights는 길이 2 이상 100 이하인 정수 배열입니다.\n모든 탑의 높이는 1 이상 100 이하입니다.\n신호를 수신하는 탑이 없으면 0으로 표시합니다.\n    \n# 입출력 예\n\n```\nheights\t            return\n[6,9,5,7,4]\t        [0,0,2,2,4]\n[3,9,9,3,5,7,2]\t    [0,0,0,3,3,3,6]\n[1,5,3,6,7,6,5]\t    [0,0,2,0,0,5,6]\n```\n# 입출력 예 설명\n* 입출력 예 #1\n     - 앞서 설명한 예와 같습니다.\n\n* 입출력 예 #2\n```\n[1,2,3] 번째 탑이 쏜 신호는 아무도 수신하지 않습니다.\n[4,5,6] 번째 탑이 쏜 신호는 3번째 탑이 수신합니다.\n[7] 번째 탑이 쏜 신호는 6번째 탑이 수신합니다.\n```\n* 입출력 예 #3\n```\n[1,2,4,5] 번째 탑이 쏜 신호는 아무도 수신하지 않습니다.\n[3] 번째 탑이 쏜 신호는 2번째 탑이 수신합니다.\n[6] 번째 탑이 쏜 신호는 5번째 탑이 수신합니다.\n[7] 번째 탑이 쏜 신호는 6번째 탑이 수신합니다.\n```\n# 해결 방법 \n* 반복문을 두번 돌면서 원하는 값을 구하기 위해서 runningFlag, retunValue를 설정하면 된다. \n* 비교하는게 마치 정렬에 반복문이 두번 반복하는 시간복잡도 O(n^2) 정렬알고리즘이 생각이 났다\n\n\n# CODE\n3가지 방법을 생각해 봤다. 아래 차례로 코드/설명을 주석으로 달았다.\n1. map을 사용해서 검사하는 방법\n2. 배열 왼쪽부터 검사하는 방법\n3. 배열 오른쪽부터 검사하는 방법 \n\n# CODE1: map을 사용해서 검사하는 방법\n```js\n    function solution2(heights) {\n        // POINT1: map callback function 3번째 param이 array(The array map was called upon)이라는 것을 이용\n        return heights.map((v, i, arr) => {\n            for (i--; i > -1; i--) { // 주의해서 봐야할 라인\n                if (arr[i] > v) break;\n            }\n            return ++i; //map의 return Value는 arr배열 i번째 요소에 return 값이 setting된다.\n        });\n    }   \n```\n\n# CODE2: 배열 왼쪽부터 검사하는 방법\n```js\n    function solution1(heights) {\n        var answer = [];\n        // POINT2: 배열 왼쪽부터 검사하는 방법\n        for (let i = 1; i < heights.length; i++) {\n            answer.push(0); \n            for (let j = i - 1; j >= 0; j--) {\n                if (heights[j] > heights[i]) {\n                    answer[i] = j + 1;\n                    break; // break 덕분에 안쪽 for iterator가 안돌아서 더이상 왼쪽에 있는 idx를 돌지 않는다.\n                }\n            }\n        }\n        return answer;\n    }\n```\n\n# CODE3: 배열 오른쪽부터 검사하는 방법 \n```js\n    function solution(heights) {\n        var answer = [];\n        // POINT3: 배열 오른쪽부터 검사하는 방법\n        for (var i = heights.length - 1; i >= 1; i--) { //오른쪽 부터 시작하는 for문\n            var continueFlag = true;    //역할: 수신받을 수신탑이 하나도 없으면 inner for문에 flag를 여부를 확인 후 0(수신 받을 탑 x)을 추가해준다.\n            for (var j = i - 1; j >= 0; j--) { //i 변수 보다 idx 1왼쪽 것과 비교\n                if (continueFlag && heights[i] < heights[j]) {\n                    answer.unshift(j + 1);\n                    continueFlag = false;\n                }\n            }\n            if (continueFlag) {\n                answer.unshift(0);\n            }\n        }\n        answer.unshift(0); //첫번째 탑은 보낼곳 x\n\n        return answer;\n    }\n```\n","excerpt":"문제 설명 수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가…","fields":{"slug":"/송수신탑/"},"frontmatter":{"date":"Mar 21, 2020","title":"스택,큐_송수신탑","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 주어진 10진수를 2진수로 바꾸고 1과 1사이에 0이 가장 많을때 0의 개수를 구하는 문제\n        \n# 해결 방법 \n1. 10진수 2진수로 만들기  \n    * 나누기, 나머지 연산자: %, /연산자\n    * Math.floor: 소수점 버리기 \n2. 2진수 순회하면서 1과 1사이 0이 제일 많은 숫자 구하기\n    * 반복문 -> for, reduce\n    * 변수 하나 추가해서 0 숫자 카운트 \n        기존에 저장한 숫자보다 크면 제일 큰 숫자 변환하기\n    2.1 없으면 0\n\n# 추가 시도할 항목\n* reduce 사용해보기! 현재 for문으로 순회하고 있다.  \n    - 코드스피츠 객체지향 자바스크립트에서 3회차에서 observer pattern 적용시 Object.setProperty에서 reduce를 사용해서 \n    - [!] reduce를 사용해서 reutrn 값으로 BinaryGap중 가장 큰것을 구할 수 있을 것이라고 생각했으나 1과 1사이에 있는 0의 개수를 reduce callback function 로직으로만 해결 할 수 없었다.  \n    가장큰 BinaryGap을 비교할 수 있느 변수 하나, countFlag(0 카운트 여부)를 확인하는 변수 하나 두개가 더 필요했다.\n    이럴거면 일반 반복문으로 순회하면서 원하는 값을 구하는데 추가 변수(가장큰 BinaryGap, countingFlag)를 사용해서 구하는게 더 좋을 것같다.\n    - reduce는 일반 배열을 사용해서 안에 로직을 만들때 개발자가 실수할까봐 만든 함수라고 알고 있다. \n\n# CODE1 - 가장 큰 BinaryGap 찾을 때 \"일반 배열\" 사용\n```js\n    function getLargestBinaryGap(n){\n        \n        var binaryNum=[];\n        while(n >= 1){\n            binaryNum.push(n%2);\n            n = Math.floor(n/2);\n        }\n        \n        binaryNum = binaryNum.reverse();\n        var largestBinaryGap = 0;\n        var countingBinaryGap = 0;\n        for(var i=0; i<binaryNum.length; i++){\n            var num = binaryNum[i];\n                if(num === 0){\n                countingBinaryGap++;\n            } else if(num === 1){\n                if(countingBinaryGap > largestBinaryGap) largestBinaryGap = countingBinaryGap; \n                countingBinaryGap = 0;\n            }\n        }\n        return largestBinaryGap;\n    }\n\n    //10 -> 1010(2)\n    //5  -> 0101(2)\n    console.log(getLargestBinaryGap(10));   //1\n    console.log(getLargestBinaryGap(5));    //1\n```\n\n# CODE2 - 가장 큰 BinaryGap 찾을 \"reduce\" 사용\n```js\n    function getLargestBinaryGapByReduce(n){\n        let binaryNum=[];\n        while(n >= 1){\n            binaryNum.push(n%2);\n            n = Math.floor(n/2);\n        }\n        \n        //100110001\n        binaryNum = binaryNum.reverse();\n        let largestBinaryGap = 0;\n        let countFlag = false;\n        binaryNum.reduce((p, c) => {\n            console.log(p,c)\n            if (c === 1 && !countFlag){\n                countFlag = true;\n                return p;\n            } else if (c === 0 && countFlag){\n                return ++p;\n            } else if (c === 1 && countFlag){\n                largestBinaryGap = p > largestBinaryGap ? p : largestBinaryGap;\n                return 0;\n            }\n        }, 0);\n\n        return largestBinaryGap;\n    }\n    //10 -> 1010(2)\n    //5  -> 0101(2)\n    console.log(getLargestBinaryGapByReduce(10));    //1\n    console.log(getLargestBinaryGapByReduce(5));    //1\n```\n\n# 코드스피츠 ViewModel class에서 생성자 함수에서 reduce 예제\n```js\n\nvar obj = {\n    \"width\": \"50%\",\n    \"background\": \"#ffa\",\n    \"cursor\": \"pointer\"\n}\n\nconsole.log(Object.entries(obj));\n/*\n[\n  [\"width\",\"50%\"],\n  [\"background\",\"#ffa\"],\n  [\"cursor\",\"pointer\"]\n]\n*/\n\nvar result = Object.entries(obj).reduce(r, [k,v] => {\n                console.log({r, k, v});\n                r[k] = v;\n                return r;\n            }, {});\n/*\n    # console.log\n        {} \"width\" \"50%\"\n        {width: \"50%\"} \"background\" \"#ffa\"\n        {width: \"50%\", background: \"#ffa\"} \"cursor\" \"pointer\"\n\n    # result\n        {width: \"50%\", background: \"#ffa\", cursor: \"pointer\"}\n*/\n\nObject.defineProperties(\n    obj, \n    Object.entries(obj).reduce((r, [k,v]) => {\n        console.log({r, k, v});\n        r[k] = {    \n                enumerable: true,\n                get: () => v,\n                set(newV) {\n                    v = newV;\n                }\n        }\n        return r;\n    }, {})\n)\n/*\n    r: {}\n    k: \"width\"\n    v: \"50%\"\n\n    r: {width: {…}}\n    k: \"background\"\n    v: \"#ffa\"\n\n    r: {width: {…}, background: {…}}\n    k: \"cursor\"\n    v: \"pointer\"\n\n    # 최종결과 \n    obj = {width: {…}, background: {…}, cursor: {…}}\n    > {width: {…}, background: {…}, cursor: {…}} 이 값을 펼치면 아래와 같다.\n    width: \"50%\"\n    background: \"#ffa\"\n    cursor: \"pointer\"\n    get width: () => v\n    set width: ƒ set(newV)\n    get background: () => v\n    set background: ƒ set(newV)\n    get cursor: () => v\n    set cursor: ƒ set(newV)\n    __proto__: Object\n*/\n\n```\n","excerpt":"문제 주어진 10진수를 2진수로 바꾸고 1과 1사이에 0이 가장 많을때 0의 개수를 구하는 문제\n     해결 방법 10진수 2진수로 만들기   나누기, 나머지 연산자: %, /연산자 Math.floor: 소수점 버리기  2진수 순회하면서 1과…","fields":{"slug":"/BinaryGap/"},"frontmatter":{"date":"Mar 20, 2020","title":"BinaryGap","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 동적 프로그래밍이란?\n* 동적 프로그래밍은 복잡한 문제를 작은 하위 문제들로 나누어 푸는 최적화기법 DFS 알고리즘은 동적프로그밍 기법으로 문제를 해결할 수 있다. \n\n* 동적 프로그래밍은(병합/퀵 정렬 알고리즘에서 사용했던) 분할/정복과는 전혀 다른 접근 방식이다. \n    * **분할/정복**\n        - <u>문제를 독립적인(independent) 하위 문제들로 분할하고 다시 합치는 해결 방식</u>\n    * **동적 프로그래밍**\n        - <u>종속적인(dependent)하위 문제들로 나눠 해결한다.</u>\n        - <u>이 얘기는 재귀호출로 스택을 쌓아서 각 스택별로 process를 처리하면서 각 스택의 return 값을 다음 스택(호출한 함수 프로세스)으로 넘겨서 문제를 해결하는 형식 같다.</u>\n\n# 동적 프로그래밍을 사용해 문제를 해결할 때 중요한 세단계\n1. 하위 문제들을 정의한다. \n2. 하위 문제들을 풀기위한 '재귀를 구현'한다.\n3. 베이스 케이스를 찾아낸다.[^BaseCase]\n\n# 동적 프로그래밍 방식으로 해결한 유명한 알고리즘 문제들\n1. 배낭문제\n    * 짐 무게의 최댓값이 정해져 '배낭'에 일정가치와 무게의 집들을 넣을 때 가지츼 총합을 최대로 할 방법\n2. 최장공통부분수열(LCS, longest common subsequence)\n    * 다수의 수열 모두의 부분수열이 되는 수열 중에 가장 긴 것(남아 있는 원소의 순서를 바꾸지 않은 채 일부 원소를 삭제하든지 하여 다른 수열로부터 파생 가능한 수열)을 찾는 문제\n3. 행렬 연쇄 곱셈(matrix chain multiplication)\n    * 행렬 집합에서 가장 효율적(가장 적은 연산)으로 행렬들을 곱하는 곱셈 순서 조합을 찾는 것 \n4. 동전 교환\n    * 정해진 금액을 동전(d1, d2, d3, ... dn)으로 바궈주는 경우의 수\n\n\n\n[^BaseCase]: 재귀 호출을 멈추는 조건(중단점)","excerpt":"동적 프로그래밍이란? 동적 프로그래밍은 복잡한 문제를 작은 하위 문제들로 나누어 푸는 최적화기법 DFS…","fields":{"slug":"/동적프로그래밍/"},"frontmatter":{"date":"Mar 19, 2020","title":"동적프로그래밍 설명","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 재귀 호출이란? \n* 어떤 문제를 작은 단위의 동일한 문제들로 나누어 해결하는 방법\n* 함수 자기 자신을 다시 호출하는 것\n* 재귀 호출을 멈추는 조건(중단점)을 `베이스케이스(basecase)`가 만드시 필요하다\n\n# 자바스크립트에서 호출 스택 크기의 한계\n* 브라우저에서 재귀호출로 인해 호출 스택이 계속 샇이게 되면 `스택 오버플로우(stack overflow)`에 걸린다. \n\n# 호출 스택 크기\n* 사용중인 os, browser 종류마다 수치는 다르다.\n\n* 20200319 ios, chrome 버전 80은 \"15683\"번 호출한다.\n\n\n## 호출 스택 크기 확인 코드\n```js\n    var i = 0;\n\n    function recursiveFn(){\n        i++;\n        recursiveFn();\n    }\n\n    try{\n        recursiveFn();\n    } catch (ex) {\n        alert(`i: ${i}, error: ${ex}`);\n    }\n\n```","excerpt":"…","fields":{"slug":"/재귀/"},"frontmatter":{"date":"Mar 19, 2020","title":"재귀","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 리뷰 \n* 동적 프로그래밍(POINT5,6,7), 거스름돈 최적 케이스 조건3(POINT8,9,10)을 고민하는데 시간이 소요 됐으며 동적 프로그래밍 보다 최적케이스조건중 POINT9번을 생각하는데 더 시간 소요 됐다.\n\n# 문제 \n* 주어진 금액을 동전 d1, d2, d3... dn으로 바꿔줄 때 필요한 동전의 최소 개수\n* 예\n    - 1, 5, 10, 25센트 동전이 있고 36센트를 바꿀때 최소 동전 개수는 25, 10, 1 센트이다.\n        \n# 해결 방법 \n* 모든 x < n에 대한 해를 찾아야한다.\n* 더 적은 금액의 동전에 대한 해를 바탕으로 최적해를 찾아간다.\n\n# POINT\n> 거스름돈 amount\n> 동전: coins  \n> newAmount = amount - coins[i];  \n> newMin = me.makeChange(newAmount);  \n> min = \n\n* POINT1: 동전을 배열로 받는다\n* POINT2: 중복 계산을 막기위해서 makeChange로 들어온 amount 단위별로 caching 해 놓는다. \n* POINT3: 거스름돈 금액이 음수면 빈배열 반환\n* POINT4: 캐시있는 금색이면 캐시된 값 반환\n\n* 동적 프로그래밍 핵심\n    * POINT5: iterator coins - 동전 금액을 기준으로 문제를 풀기 위해서 동전 금액 기준으로 순회한다. \n    * POINT6: newAmount - 거스름돈에서 각 동전을 뺀다./ POINT7에서 재귀호출 때문에 교환 가능한 최소 금액까지 도달한다.(동전 최소 금액이 1이면 거스름돈이 1까지 도달한다는 의미)\n    * POINT7: `재귀호출`: newAmount >= 0이면 newAmount값에 대해서 다시 재귀 호출을 해서 결과를 newMin 변수에 담는다.\n\n* 거스름돈 최적 케이스 조건 3\n    * POINT8: newAmount가 유효여부 확인( 교환 가능한 최소금액이 최소 금액 까지 도달한건가? -> POINT6 확인 \n    * POINT9: 최적의 newMin(동전의 최소 개수)이 도출 됐는지\n    * POINT10: newMin과 newAmount 모두 유효한 값인지\n\n* POINT11: POINT8,9,10 모두 충족한다면 그것은 이전보다 더 나은 결과를 얻었다는 반증(예 - 5센트 거스름돈이 1센트 5개보다 5센트 동전 개가 더 바람직)\n* POINT12: 최종 겨로가 반환\n\n# CODE\n```js\nfunction MinCoinChange(coins){\n    var conins = coins; //POINT1\n    var cache = {};     //POINT2\n\n    this.makeChange = function(amount){\n        var me = this;\n        if(!amount){    //POINT3\n            return [];  \n        }\n\n        if(cache[amount]){  //POINT4\n            return cache[amount];\n        }\n\n        var min = [], newMin, newAmount;\n\n        for (var i=0; i<coins.length; i++){ //POINT5\n            var coin = coins[i];\n            newAmount = amount - coin;      //POINT6\n            if (newAmount >= 0){\n                newMin = me.makeChange(newAmount);  //POINT7\n            }\n\n            if( newAmount >= 0                                  //POINT8\n                && (newMin.length < min.length-1 || !min.length)//POINT9\n                && (newMin.length || !newAmount)){              //POINT10\n                min = [coin].concat(newMin);                    //POINT11\n                console.log(`new Min: ${min} for ${amount}`);   \n            }\n        }\n        return (cache[amount] = min);                           //POINT12\n    }\n}\n\nvar minCoinChange = new MinCoinChange([1,5,10,25]);\nconsole.log(minCoinChange.makeChange(36));  //[1, 10, 25]\n```\n\n\n# 손으로 풀어본 알고리즘\n* 반복문 안에 재귀 호출과 재귀호출 전, 후 처리할 알고리즘이 있는 경우 어떻게 동작하는지 중점으로 분석해봤다.\n\n* 설명1\n    * coins = [1,3,5], amount = 5 일때 amount 3일때 최소 거스름돈은?\n![](./최소거스름돈_Stack기준_분석.jpg)\n\n\n* 설명2\n    * 기준 makeChange(mc)는 point5,6을 수행후 '재귀호출' 이후에 나머지 부분(point8,9,10)부분을 수행\n    * makeChange는 주어진 coins 만큼 반복\n![](./최소거스름돈_Stack기준_분석1.jpg)\n\n* 설명3\n    * point6,7에 의해서 재귀호출에 의해서 amount가 1이된 경우에 makeChange에 amount가 1인경우 나머지 coin을 순회하면서 amount가 1일때 가장 적합한 거스름돈을 찾는다.\n    * return으로 [1]을 반환하면서 다음 스택 newMin 변수에 넘긴다.(POINT7 참고)\n![](./최소거스름돈_Stack기준_분석2.jpg)\n\n* 설명4\n    * point6,7에 의해서 재귀호출에 의해서 amount가 2이된 경우에 makeChange에 amount가 1인경우 나머지 coin을 순회하면서 amount가 1일때 가장 적합한 거스름돈을 찾는다.\n    * 이전 stack에서 [1]을 반환 받았고 현재 coin이 1일때 amount2일때 최소 거스름돈이다.\n![](./최소거스름돈_Stack기준_분석3.jpg)\n\n* 설명5\n    * 설명3,4와 같이 설명4 stack에서 return value [1,1]이 newMin으로 설정되고 coin이 1인 경우에 point8,9,10 조건을 만족해 [1,1,1]이 min에 대입 된다. \n    * coins 순회에서 1번째 값이 3인 경우 amount - coins[1] = 3 - 3 = 0 이다. \n    이 의미는 거스름돈 3센트를 3센트 하나로 거슬러줄 수 있다는 의미이다. 그래서 조건 point8,9,10 조건을 만족해서 min이 [3]으로 교체 된다.\n        - makeChange function(3) -> coin[1]은 3 -> newAmount = amount - coins[1] = 0 일때 makeChange(0) return value로 [](빈배열)을 반환 받는다.\n![](./최소거스름돈_Stack기준_분석4.jpg)","excerpt":"리뷰 동적 프로그래밍(POINT5,6,7), 거스름돈 최적 케이스 조건3(POINT8,9,10)을 고민하는데 시간이 소요 됐으며 동적 프로그래밍 보다 최적케이스조건중 POINT9번을 생각하는데 더 시간 소요 됐다. 문제 주어진 금액을 동전 d1, d…","fields":{"slug":"/최소거스름돈/"},"frontmatter":{"date":"Mar 19, 2020","title":"동적프로그래밍_최소거스름돈","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* num이 1,2일때 '베이스 케이스'\n* fib(n) = fib(n-1) + fib(n-2);\n\n\n# CODE - 재귀호출 방법\n```js\nfunction fibonacci(num){\n    if(num===1 || num === 2){\n        return 1;\n    }\n    return fibonacci(num-1) + fibonacci(num-2);\n}\n\nfinonacci(5); //5\n```\n\n# CODE - 재귀호출 아닌 방식\n```js\nfunction fib(num){\n    var n1 = 1,\n    n2 = 1,\n    n = 1;\n    for(var i = 3; i<=num; i++){\n        n = n1 + n2;\n        n1 = n2;\n        n2 = n;\n    }\n    return n;\n}\n\nfib(5); //5\n\n```\n\n# fibonacci graph\n![](./fibonacciGraph.jpg)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 num이 1,2일때 '베이스 케이스' fib(n) = fib(n-1) + fib(n-2); CODE - 재귀호출 방법 CODE - 재귀호출 아닌 방식 fibonacci…","fields":{"slug":"/피보나치수열/"},"frontmatter":{"date":"Mar 19, 2020","title":"피보나치 수열","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# https://youtu.be/5UUISCK6CL4\n * VMSubject > notify에서 this.notifyTarget은 hook으로 상속받은 애가 결정하도록 되어 있다. \n * [ ] 이게 뭐때문에 설명한것지 찾아보기 \n\n\n# Processor\n* https://youtu.be/5UUISCK6CL4\n    - binder에다가 addProcessor로 원하는 Process를 만들어 끼워 넣어주는 형태로 되어 있다. \n\n* https://youtu.be/5UUISCK6CL4\n    - ViewModel에 \"style, attributes, propeties\"를 명시하고 있다! \n    - 일반화 하는것을 배울 예정 \n\nProcessor가 독립되어서 ViewModel에서 원하는 key값을 target에서 parsing해올 수 있지만 \nViewModel을 보니 key값이 하드코딩되어 있어 확장가능하지 않다! -> 개선예정(데이터 구조를 동적으로 바꾸는 일)\n\n* https://youtu.be/5UUISCK6CL4?t=788\n    - \bObject.entires(data).forEach(()=>{}) 코드 설명 \n\n\n* https://youtu.be/5UUISCK6CL4?t=1021\n    - parser를 짜보자! \n    - json에대한 재귀 parser를 짜본다.\n    - define 함수를 재귀호출하면서 모든 키들을 getter, setter로 만든다 \n    - JSON.stringify, JSON.parser를 꼭 만들어 보라고 하심\n    - ViewModel > Symbol 설명 \n    - parsting 하면 getter, setter를 만들면서 obseverable한 객체를 만들어서 넘겨준다. (객체를 변경하면 변화를 알 수 있다.)\n    - 그래서 결론은 binder, viewmodel에도 더이상 특수한 키가 등장하지 않고 특정키를 지정해주는 것은 Processor 밖에 없다. \n    우리는 Proessor에 특정키를 주면 그에 해당하는 ViewModel이 유무에 따라서 동작한다. 그래서 ViewModel에 작성할때 참조해야 한건 ViewModel이 어떤 데이터를 원하냐가 아닌 내가 사용할 Processor가 어떤 키를 원하는게 더 중요하다. 그래서 OCP가 완저하게 보장\n        - ViewModel은 아무런 spec을 강요하지 않는데 내가 A,B,C Processor를 쓸꺼니까 A,B,C Processor가 원하는 Key를 갖춘 ViewModel을 필요로 한다.  \n\n* https://youtu.be/5UUISCK6CL4?t=2528 - setDomProcesor function (42:08/ 1:56:44 )\n    * 매번 Processor Set를 만들수 없기 때문에 만들어준다 \n    * decorator pattern\n        - 자기 일하고 다음아이에게 추가적으로 시키는 것 \n        - binder에게 baseProcessors.forEach(v=>binder.addProcessor(v)) 이 만큼을 binding해준다. \n        - 이것은 \"collection\": 한놈 사고치면 다 망가짐\n    * chain of responsibility pattern\n        - linked list로 처리기를 연결해켜 놓은 것/ 다음 아이에게 일을 시킬 때 일을 시킬지 말지 결정할 수 있는 구조\n        - binder에 대한 동작을 설명하면서 binder의 동작이 decorator이다. (Binder class > render의 this.#items 반복문)\n        \n    * Processor class에 link list를 구현해본다\n        - 아래 코드 적다가 강의 듣느라 안적음. \n        - decorator pattern, chain of responsibility pattenr을 쓰는이유? \n            : 게를 소유하는 애와 격리시켜 구조화를 시킬 수 있다. \n        ```js\n            #next = null;\n\n            next(process){\n                this.#next = process;\n            }\n\n            process(...){\n                if(this.#next) this.#next.process(vm, el, k, v);\n            }\n\n            const Binder = class extends ViewModelListener{\n                addProcessor(v){\n                    this.#processors[v.cat] = v;\n                }\n                //=> linked list로 구현 하면 다음과같이 바뀐다. \n                set processor(v){\n                    this.#processor = v;\n                }\n            }\n        ```\n        ```js\n            //? 쓰는게 optional이라고 말하고 있음요. \n        \u001e this.#processor?.cat === pk... \n        ```\n        - 배열, set사용 구분에 대한 설명\n        - 객체 안에 collection을 피해야한다 linked list를 사용해야한다. 이게 함수형 자료구조의 핵심 \n            - linked list를 돌면 다음 아이를 순회할때 조건을 추가할 수 있다. 이게 장점, 유리함입니다.\n\n        - 배열을 사용해야할 때는? \n            - 요소에 값만 들어 있을 경우에(행위가 없을때)는 배열을 사용해도 괜찮다. \n            - 그러나 process안에는 행위가 있다. \n            - decorator pattern은 필수다. 그래서 decorator의 chain of responsibility 핵심은? -> linked list 이다.\n            - 코드 -> 객체 -> 의존성이생긴다. ocp를 생길 수 없다.\n\n\n    \n* https://youtu.be/5UUISCK6CL4?t=4048 - const Binder = class extends ViewModelListener{}\n    - v.cat.split(\".\").pop() 에 대해서 설명 다시 시작\n    - binder, baseProcessors > _process에 대해서 설명 중...\n    - 제어권을 코어, 확장된 객체 이 둘중 어디에 둘까 고민중 \n \n\n * https://youtu.be/5UUISCK6CL4?t=4529 - html 화면  \n    - setDomProcessor > \"template\" process 구현 설명 \n\n    - static, 클래스를 언제 사용해야 할까의 구분\n        - 한번, 여러번 사용할 수 잇는 것에 대한 차이 \n        - 클래스는 상속을 할 수 있습니다. \n\n    - shield? 쉴드 패턴 \n        - balck list, white list : 정확성 코드, 처리하는 코드를 나눠라. \n    \n    - https://youtu.be/5UUISCK6CL4?t=5531 visitor.visit(el=>{}) 설명 시작","excerpt":"https://youtu.be/5UUISCK6CL4 VMSubject > notify에서 this.notifyTarget은 hook으로 상속받은 애가 결정하도록 되어 있다.  이게 뭐때문에 설명한것지 찾아보기  Processor https…","fields":{"slug":"/OOPWithJavascript_5/"},"frontmatter":{"date":"Mar 15, 2020","title":"객체지향 자바스크립트 5회차(MVVM pattern 개선2)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n# 화살표 함수와 일반함수의 차이점\n\n1. 선언 방법이 다르다. \n   1. return 부분을 확인해보자 \n2. 화살표, 일반함수에서 this의 scope영역이 다르다. \n   1. 화살표 함수는 상위 this scope을 가르킨다.\n3. 화살표 함수를 사용하지 말아야할 4가지 케이스가 있따. \n   - 메소드, prototype, 생성자함수, addEventListener\n\n# 1. 화살표 함수의 선언\n\n- 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=>)를 사용하여 보다 간략한 방법으로 함수를 선언\n- 하지만 모든 경우 화살표 함수를 사용할 수 있는 것은 아니다.\n- 화살표 함수의 기본 문법은 아래와 같다.\n\n```js\n// 매개변수 지정 방법\n    () => { ... } // 매개변수가 없을 경우\n     x => { ... } // 매개변수가 한 개인 경우, 소괄호를 생략할 수 있다.\n(x, y) => { ... } // 매개변수가 여러 개인 경우, 소괄호를 생략할 수 없다.\n\n// 함수 몸체 지정 방법\nx => { return x * x }  // single line block\nx => x * x             // 함수 몸체가 한줄의 구문이라면 중괄호를 생략할 수 있으며 암묵적으로 return된다. 위 표현과 동일하다.\n\n() => { return { a: 1 }; }\n() => ({ a: 1 })  // 위 표현과 동일하다. 객체 반환시 소괄호를 사용한다.\n(a) => (a *= a, a)\t// 중요!!! \n/*\n\t(a) => (a *= a, a) \n\t==\n\t(a) => {\n\t\ta *= a \n    \treturn a\n    }\n*/\n\n() => {           // multi line block.\n  const x = 10;\n  return x * x;\n};\n           \n// 콜백합수에서 사용하는 경우 \nconst arr = [1, 2, 3];\nconst pow = arr.map(x => x * x);\n\nconsole.log(pow); // [ 1, 4, 9 ]\n\n```\n\n\n\n# 2. 화살표 함수의 호출\n\n- 화살표 함수는 익명 함수로만 사용할 수 있다. \n- 따라서 화살표 함수를 호출하기 위해서는 함수 표현식을 사용한다.\n\n```javascript\n// ES5\nvar pow = function (x) { return x * x; };\nconsole.log(pow(10)); // 100\n// ES6\nconst pow = x => x * x;\nconsole.log(pow(10)); // 100\n```\n\n- 콜백 함수로 사용할 수 있다. \n- 이 경우 일반적인 함수 표현식보다 표현이 간결하다.\n\n```javascript\n// ES5\nvar arr = [1, 2, 3];\nvar pow = arr.map(function (x) { // x는 요소값\n  return x * x;\n});\nconsole.log(pow); // [ 1, 4, 9 ]\n\n// ES6\nconst arr = [1, 2, 3];\nconst pow = arr.map(x => x * x);\n\nconsole.log(pow); // [ 1, 4, 9 ]\n```\n\n\n\n# 3. this\n\n## 3.1 일반 함수의 this\n\n- [중요]자바스크립트의 경우 함수 <u>호출 방식에 의해 [this](https://poiemaweb.com/js-this)에 바인딩할 어떤 객체가 동적으로 결정된다</u>. \n  다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, **함수를 호출할 때 함수가 어떻게 호출되었는지에 따라** this에 바인딩할 객체가 동적으로 결정된다.\n- 콜백 함수 내부의 this는 전역 객체 window를 가리킨다.\n\n```JS\nfunction Prefixer(prefix) {\n  this.prefix = prefix;\n}\n\nPrefixer.prototype.prefixArray = function (arr) {\n  // (A)\n  return arr.map(function (x) {\n    return this.prefix + ' ' + x; // (B)\n  });\n};\n\nvar pre = new Prefixer('Hi');\nconsole.log(pre.prefixArray(['Lee', 'Kim']));\n```\n\n\n\n- [중요] 콜백 함수 내부의 this가 메소드를 호출한 객체(생성자 함수의 인스턴스)를 가리키게 하려면 아래의 3가지 방법이 있다.\n  (Arrow Function 제외)\n\n1. **that = this**\n2. **map(func, this)**\n3. **bind(this)**\n\n```js\n// Solution 1: that = this\nfunction Prefixer(prefix) {\n  this.prefix = prefix;\n}\nPrefixer.prototype.prefixArray = function (arr) {\n  var that = this;  // this: Prefixer 생성자 함수의 인스턴스\n  return arr.map(function (x) {\n    return that.prefix + ' ' + x;\n  });\n};\nvar pre = new Prefixer('Hi');\nconsole.log(pre.prefixArray(['Lee', 'Kim']));\n\n\n\n// Solution 2: map(func, this)\nfunction Prefixer(prefix) {\n  this.prefix = prefix;\n}\nPrefixer.prototype.prefixArray = function (arr) {\n  return arr.map(function (x) {\n    return this.prefix + ' ' + x;\n  }, this); // this: Prefixer 생성자 함수의 인스턴스\n};\nvar pre = new Prefixer('Hi');\nconsole.log(pre.prefixArray(['Lee', 'Kim']));\n\n\n// Solution 3: bind(this)\nfunction Prefixer(prefix) {\n  this.prefix = prefix;\n}\nPrefixer.prototype.prefixArray = function (arr) {\n  return arr.map(function (x) {\n    return this.prefix + ' ' + x;\n  }.bind(this)); // this: Prefixer 생성자 함수의 인스턴스\n};\nvar pre = new Prefixer('Hi');\nconsole.log(pre.prefixArray(['Lee', 'Kim']));\n\n```\n\n\n\n## 3.2 화살표 함수의 this ( Lexical this ! )\n\n- **일반 함수는** 함수를 선언할 때 **this에 바인딩할 객체가 정적으로 결정되는 것이 아니고**, \n  함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 **this에 바인딩할 객체가 동적으로 결정**된다고 하였다.\n- **화살표 함수는 함수를 선언할 때 <u>this에 바인딩할 객체가 정적으로 결정</u>된다.** \n  동적으로 결정되는 일반 함수와는 달리 **화살표 함수의 this 언제나 상위 스코프의 this를 가리킨다.** \n  이를 **Lexical this**라 한다. 화살표 함수는 앞서 살펴본 Solution 3의 Syntactic sugar이다.\n\n```js\nfunction Prefixer(prefix) {\n  this.prefix = prefix;\n}\nPrefixer.prototype.prefixArray = function (arr) {\n  // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다.\n  return arr.map(x => `${this.prefix}  ${x}`);\n};\nconst pre = new Prefixer('Hi');\nconsole.log(pre.prefixArray(['Lee', 'Kim']));\n```\n\n\n\n**화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.**\n\n```js\nwindow.x = 1;\nconst normal = function () { return this.x; };\nconst arrow = () => this.x;\n\nconsole.log(normal.call({ x: 10 })); // 10\nconsole.log(arrow.call({ x: 10 }));  // 1\n```\n\n\n\n# 4. 화살표 함수를 사용해서는 안되는 경우\n\n화살표 함수는 Lexical this를 지원하므로 콜백 함수로 사용하기 편리하다. 하지만 화살표 함수를 사용하는 것이 오히려 혼란을 불러오는 경우도 있으므로 주의하여야 한다.\n\n## 4.1 메소드\n\n```js\n// Bad\nconst person = {\n  name: 'Lee',\n  sayHi: () => console.log(`Hi ${this.name}`)\n};\n\nperson.sayHi(); // Hi undefined\n```\n\n<u>위 예제의 경우, 메소드로 정의한 화살표 함수 내부의 this는 메소드를 소유한 객체, 즉 메소드를 호출한 객체를 가리키지 않고 상위 컨택스트인 전역 객체 window를 가리킨다. 따라서 화살표 함수로 메소드를 정의하는 것은 바람직하지 않다.</u>\n\n이와 같은 경우는 메소드를 위한 단축 표기법인 [ES6의 축약 메소드 표현](https://poiemaweb.com/es6-enhanced-object-property#3-메소드-축약-표현)을 사용하는 것이 좋다.\n\n```js\n// Good\nconst person = {\n  name: 'Lee',\n  sayHi() { \t// === sayHi: function() {\n    console.log(`Hi ${this.name}`);\n  }\n};\n\nperson.sayHi(); // Hi Lee\n```\n\n\n\n### 4.1.1추가 확인 \n\n- 화살표 함수가 상위의 scope을 this를 가르키는지 확인 \n\n```js\nvar person = {\n  name: 'Lee',\n  sayHi: function(){        \n        return () => {\n            console.log(this);\t//{name: \"Lee\", sayHi: ƒ} === person 객체\n            console.log(`Hi ${this.name}`);\n        }\n    }\n};\n\nperson.sayHi()(); // Hi Lee\n```\n\n\n\n## 4.2 prototype\n\n화살표 함수로 정의된 메소드를 prototype에 할당하는 경우도 동일한 문제가 발생한다. \n\n prototype에 메소드를 할당하는 경우, 일반 함수를 할당한다.\n\n```js\n// Bad (화살표함수)\nconst person = {\n  name: 'Lee',\n};\nObject.prototype.sayHi = () => console.log(`Hi ${this.name}`);\nperson.sayHi(); // Hi undefined\n\n\n// Good (일반함수)\nconst person = {\n  name: 'Lee',\n};\nObject.prototype.sayHi = function() {\n  console.log(`Hi ${this.name}`);\n};\nperson.sayHi(); // Hi Lee\n```\n\n\n\n## 4.3 생성자 함수\n\n- <u>화살표 함수는 prototype 프로퍼티를 가지고 있지 않아 생성자 함수로 사용할 수 없다.</u> \n- 생성자 함수는 prototype 프로퍼티를 가지며 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor를 사용한다. \n\n```javascript\nconst Foo = () => {};\n// 화살표 함수는 prototype 프로퍼티가 없다\nconsole.log(Foo.hasOwnProperty('prototype')); // false\nconst foo = new Foo(); // TypeError: Foo is not a constructor\n```\n\n\n\n## 4.4 addEventListener 함수의 콜백 함수\n\n- addEventListener 함수의 콜백 함수를 **화살표 함수로 정의**\n  -  <u>내부 this가 상위 컨택스트인 전역 객체 window를 가리킨다.</u>\n- addEventListener 함수의 콜백 함수를 **일반 함수로 정의**\n  - <u>내부 this는 이벤트 리스너에 바인딩된 요소(currentTarget)를 가리킨다.</u>\n\n```javascript\n// Bad\nvar button = document.getElementById('myButton');\nbutton.addEventListener('click', () => {\n    //this는 화살표 함수는 전역객체를 가르키고 있다.\n    console.log(this === window); // => true\n    this.innerHTML = 'Clicked button';\n});\n\n\n// Good\nvar button = document.getElementById('myButton');\nbutton.addEventListener('click', function() {\n    //this는 id가 myButton인 dom 객체를 가르키고 있다.\n    console.log(this === button); // => true\n    this.innerHTML = 'Clicked button';\n});\n```\n\n","excerpt":"화살표 함수와 일반함수의 차이점 선언 방법이 다르다.  return 부분을 확인해보자  화살표, 일반함수에서 this의 scope영역이 다르다.  화살표 함수는 상위 this scope을 가르킨다. 화살표 함수를 사용하지 말아야할…","fields":{"slug":"/arrowFunction/"},"frontmatter":{"date":"Mar 15, 2020","title":"Arrow Function","tags":["ES6"]}}},{"node":{"rawMarkdownBody":"\n# 목표 \n* \b객체지향 프로그램이란 처음에 이루고자하는 목표에서부터 덩어리진 것을 차근차근 분리하고 깍아내는 과정입니다.  \n* 어떻게 깍을지 기준정하는 방법은? \"역할\" \n* 덩어리진 코드를 클래스로 나누려고 할때 \"역할, 기준\"이 필요하다. \n* 객체지향에서 \"역할, 기준\"은 역할, 책임 모델이라고 하는 것입니다.\n\n* \"역할, 책임\"은 비슷해보이지만 동전의 양면을 가지고 있다. \n* 책임을 가지고 있다는건? 그 책임에 대한 권한도 가지고 있다.\n* 권한이 있다는건? 권한에 대한 책임이 있다.\n* 그래서 역할을 정의하려면 어떤 권한을 주입 받고, 그 권한으로 부터 무슨 일을 수행하는 권한을 양도 받기위해서는 어떤 책임까지 가져야 하는지 한번에 정의해야 한다. \n\n# 1. ISP\n> SOLID 원칙 중 하나 \n> Interface Segregation\n> 인터페이스 분리하는 원칙(이 원칙으로 덩어리진 코드들을 나눌 수 있다.)\n\n\n* 한 코드에 여러개가 들어가 있으면 이것들을 인터페이스별로 잘라서 분리 할 수 있다. \n    - 여기서 인터페이스는 \b역할을 얘기합니다.(실제 물리적인 인터페이스를 말하는 것이 아님)\n* 객체지향에서 코드 분리할때 가장 기본적인 방법이다. \n* ViewModel을 이 법칙을 적용해보려고 한다. \n \n\n## 1.1 옵저버 서브젝트 파일 리팩토링 하기\n* pdf4, 5, 6\n```js\n    #isUpdated = new Set; #listeners = new Set;\n    addListener(v, _=type(v, ViewModelListener)){ \n        this.#listeners.add(v);\n    }\n    removeListener(v, _=type(v, ViewModelListener)){\n        this.#listeners.delete(v); \n    }\n    notify(){ \n        this.#listeners.forEach(v=>v.viewmodelUpdated(this.#isUpdated));\n    }\n\n    static #subjects = new Set; \n    static #inited = false; \n    static notify(vm){\n        this.#subjects.add(vm); \n        if(this.#inited) return; \n        this.#inited = true; \n        const f =_=>{\n            this.#subjects.forEach(vm=>{ \n                if(vm.#isUpdated.size){\n                    vm.notify();\n                    vm.#isUpdated.clear(); \n                }\n            });\n            requestAnimationFrame(f);\n        };\n        requestAnimationFrame(f);\n    }\n```\n- 뷰모델에는 어울리지 않다고 보인다 \n- 옵저버패턴에 서브젝트 역할 -> 분리하자!\n    * 메소드 코드를 분리할때 변수도 같이 이동해야한다.\n    * 메소드 설계시 의존하고 있는 필드를 역할별로 필드를 같이 쓰지 않게 잘 설계해야 한다.  \n\n* SOLID 원칙을 보며 고민...\n![Strategy](./4회/7.SOLID.png)\n    - SOLID원칙 보고 어떻게 뷰모델에서 옵저버 서브젝트 파일을 빼낼까 고민 중...\n    - 상속모델을 사용할 것이다 우측 하단과 비슷한 모델을 사용\n    - 서브젝트모델 === 인터페이스A/   \n    뷰모델 === 객체 === 서브젝트모델을 상속받은 모델\n\n```js\n    //설명1\n    const ViewModelSubject = class extends ViewModelListener{ \n        #info = new Set; #listeners = new Set;\n        //설명2 add, clear\n        add(v, _=type(v, ViewModelValue)){this.#info.add(v);} \n        clear(){this.#info.clear();}\n        addListener(v, _=type(v, ViewModelListener)){ \n            this.#listeners.add(v); \n            //설명3\n            ViewModelSubject.watch(this);\n        }\n        removeListener(v, _=type(v, ViewModelListener)){\n            this.#listeners.delete(v);\n            //설명4\n            if(!this.#listeners.size) ViewModelSubject.unwatch(this); \n        }\n        notify(){\n            this.#listeners.forEach(v=>v.viewmodelUpdated(this.#info));\n        }\n    };\n```\n\n* pdf8, 9\n```js\n    const ViewModelSubject = class extends ViewModelListener{ \n        #info = new Set; #listeners = new Set;\n        add(v, _=type(v, ViewModelValue)){this.#info.add(v);} \n        clear(){this.#info.clear();}\n        addListener(v, _=type(v, ViewModelListener)){ \n            this.#listeners.add(v); \n            ViewModelSubject.watch(this);\n        }\n        removeListener(v, _=type(v, ViewModelListener)){\n            this.#listeners.delete(v);\n            if(!this.#listeners.size) ViewModelSubject.unwatch(this); \n        }\n        notify(){this.#listeners.forEach(v=>v.viewmodelUpdated(this.#info));}\n    };\n```\n- 설명1 상속\n    - 3강에서 ViewModel은 ViewModelListener을 상속는데 여기서 ViewModelSubject에 ViewModelListener을 상속 받는 이유는 뭘까? \n        - Javascript는 다중 상속이 안돼서 어쩔 수 없이 ViewModelSubject가 ViewModelListener을 상속받고 ViewModel이 ViewModelSubject를 상속받는다 \n    ```\n    3장 ViewModel ->                     ViewModelListener\n    4장 ViewModel -> ViewModelSubject -> ViewModelListener\n    ```\n- 설명2 add, clear추가 \n    - `#isUpdated -> #info\n    - `#info는 부모에 있는 private 속성이다. 자식이 못건드리기 때문에 부모에 속성 #info private 속성을 제거, 추가할때는 부모쪽에서 서비스를 내려줘야한다. 그래서 내가 ViewModel #info를 변경하고 싶을때는 부모쪽 메소드에서 ViewModel Value를 직접 넘겨 ViewModel를 직접 넘겨서 ViewModel Value를 부모인 서브젝트가 직접 추가하도록 위임해서 동작하게 해야한다. clear도 부모에게 직접 요청해서 추가해야 한다.\n- 설명3 watch\n    - 이전에는 addListener를 하고 ViewModel이 생성되는 시점에 바로 전체 서브젝트 리스트에 등록했다. \n    - 지금은 Listener가 들어온순간 서브젝트를 watch로 보낼 것이다.\n    뷰모델 생성했다고 바로 requestAnimationFrame 넣어서 감시할 필요가 없다. \n    Listener가 하나라도 생겼을때 감시하면 된다!(\b뷰모델을 감사하는 사람이 없어 변화를 추적할 필요가 없다.)\n- 설명4 unwatch\n    - 뮤보델은 구독하는 listener가 없을때 unwatch를 하자!\n\n\n## 1.2 notify 리팩토링\n* pdf10\n```js\n    static #subjects = new Set; \n    static #inited = false; \n    static notify(vm){\n        this.#subjects.add(vm);\n        if(this.#inited) return;\n        this.#inited = true; \n        const f =_=>{\n            this.#subjects.forEach(vm=>{ \n                if(vm.#isUpdated.size){\n                    vm.notify();\n                    vm.#isUpdated.clear(); \n                }\n            });\n            requestAnimationFrame(f);\n        };\n        requestAnimationFrame(f); \n    }\n```\n* requestAnimationFrame에 의해서 subject돌면서 뷰모델에 notify해준다. \n\n\n* pdf11-12\n```js\n    const ViewModelSubject = class extends ViewModelListener{ \n\n        //... 위 코드 참고\n\n        static #subjects = new Set; static #inited = false; \n        static notify(){\n            const f =_=>{ \n                this.#subjects.forEach(v=>{\n                    if(v.#info.size){ \n                        v.notify();\n                        v.clear(); \n                    }\n                });\n                //설명1\n                if(this.#inited) requestAnimationFrame(f); \n            };\n            requestAnimationFrame(f); \n        }\n\n        //설명2\n        static watch(vm, _=type(vm, ViewModelListener)){\n            this.#subjects.add(vm); //set에 add해도 변화 x\n            if(!this.#inited){\n                this.#inited = true;\n                this.notify(); \n            }\n        }\n\n        //설명3\n        static unwatch(vm, _=type(vm, ViewModelListener)){\n            this.#subjects.delete(vm);\n            if(!this.#subjects.size) this.#inited = false; \n        }\n    }    \n```\n- notify가 무조건 돈다. \n- 설명1 flag를 통한 Animation 제어\n    - requsetAnimationFrame를 동작 여부를 결정하는 flag \"#inited\"를 사용하고 있다. \n- 설명2, 설명3 flag를 통한 Animation 제어\n    - 리스너가 없는 뷰모델을 여러개 만들어도 requestAnimationFrame은 돌지 않는다. 뷰모델에 리스너를 등록해야지 그 뷰모델을 감시하기 시작하고 리스너를 다 빼서 하나도 없다면 requestAnimation도 멈추게 된다. \n    - 기존 notify함수에 this.#subjects.add(vm); 코드로 subject를 관리했는데 이렇게 하면 외부에서는 notify에 #subject에 add한다는 사실을 모른다. 그래서 외부에서 알 수 있도록 watch, unwatch함수 #subject.add, #subject.delete를 통해서 관리해주고 있다. \n\n- 추가 정보: 플래그변수, 싱글스레드, 멀티스레드 \n    - Javascript는 싱글스레드이기 때문에 플래그 변수로 제어하기 쉽다. 다른 언어는 멀시스레드이기 때문에 플래그 제어가 안된다. \n    - 플래그 기만에 효율적인 알고리즘짜는것을 계속해서 연습해야 한다. \n    - 멀티 스레드에서 작업할때는 플래그 기만이 아니라 멀티스레드에서 안정성을 확보하고 효율성을 확보하는 패턴을 배워야한다.\n\n- 추가 정보: static method\n    - notify static private method로 설정해야하는데 Javascript에는 static method를 지원하지 않아서 공개적으로 되어 있다. \u001f\n    - watch, unwatch도 외부에 공개 되어야 하지만 public은 아니다. 내부 Framework안에서 돌기 때문에 \n\n\n# 2. 섬세한 권한 조정\n> 위 ISP방법을 통해서 ViewModel이 가벼워 졌는데 이제는 섬세한 권한 조정을 하려고 한다. \n\n* 권한 조정이 필요한 이유 \n    * 권한제어자가 기본적으로 제공되는 언어 java, 코틀린 private, internal, public \n    * Java의 기본 권한 private, Javascript 기본권한 public\n    * 그래서 생기는 문제는 getter, setter외부에 노출이 되면 코드 조작이 가능해서 문제가 생긴다. \n\n* 아래 코드에 설명할 부분을 주석으로 6가지를 표시 했으며 아래 설명이 있습니다.\n```js\n    const ViewModel = class extends ViewModelSubject{\n        static get(data){return new ViewModel(data);}\n        styles = {}; attributes = {}; properties = {}; events = {}; \n        \n        //설명1 readonly\n        #subKey = \"\";\n        get subKey(){return this.#subKey;}\n        #parent = null;\n        get parent(){return this.#parent;}\n        \n        //설명2 [설명6과 관련]Transaction 연산\n        setParent(parent, subKey){\n            this.#parent = type(parent, ViewModel);\n            this.#subKey = subKey;\n            this.addListener(parent);\n        }\n        \n        constructor(data, _=type(data, \"object\")){ \n            super();\n            Object.entries(data).forEach(([cat, obj])=>{ \n                if(\"styles,attributes,properties\".includes(cat)) {\n                    if (!obj || typeof obj != \"object\") throw `invalid object cat:${cat}, obj:${obj}`; \n                    this[cat] = Object.defineProperties({}, Object.entries(obj).reduce((r, [k, v])=>{\n                        r[k] = { \n                            enumerable:true, get:_=>v, set:newV=>{\n                            v = newV;\n                            //설명3 update할 객체 세팅 방법 변경\n                            this.add(new ViewModelValue(this.#subKey, cat, k, v)); }\n                        };\n                        return r; \n                    }, {}));\n                }else{\n                    Object.defineProperties(this, { \n                        [cat]: {\n                            enumerable: true,\n                            get: _ => obj,\n                            set: newV => {\n                                obj = newV;\n                                //설명3 update할 객체 세팅 방법 변경\n                                this.add(new ViewModelValue(this.#subKey, \"root\", cat, obj)); \n                            }\n                        } \n                    });\n                    //설명6 [설명2와 관련]트렌젝션으로 setParent로 한번에 처리\n                    if(obj instanceof ViewModel) obj.setParent(this, cat); \n                }\n            });\n            //설명4 ViewModel.notify(this); 제거\n            //ViewModel.notify(this);\n            Object.seal(this); \n        }\n        //설명5 viewModel\n        viewmodelUpdated(updated){updated.forEach(v=>this.add(v));}\n    }\n```\n\n* 설명1 readonly\n    - 외부 공개, 쓰기는 private(public getter, private setter pattern)\n\n* 설명2 Transaction 연산\n    - 자바스크립트는 트렌젝션을 따로 지원하지 않기 때문에 함수를 통해서 트렌젝션 연산이라는 것을 알려줘야 한다. \n        - Transaction이란? 코드가 한번에 일어나야 하는 구간이다.   \n        그런데 그 구간에서 하나하나 일어나야 하는건지 덩어리로 한번에 일어나는지 아닌지 구별하는 방법이 없다. 그런데 자바스크립트에서는 덩어리로 한번에 일어나게 하는 방법은 \"함수\"를 통해서 한번에 일어나야 할 코드들을 표시할 수 있다. \n    - 이렇게 setParent 함수로 만든 다른이유는? \n        - 코드로 가져 올때 코드가 아닌 함수로 가지고 오기때문에 '전달인자'를 넘겨줘서 문제 없이 세팅할수 있다. \n        - 함수가 아닌 코드로 클래스에서 있을경우 함수에서 인자로 넘겨주는 변수들이 '지역변수, 클로저'에 설정되어 있기 때문에 문제가 될수있기 때문에   \n    - 내부 함수는 \"_\"를 붙이자.    \n    - 이 코드는 parent를 세팅할\u001f때 있어야 하는 코드(기존에는 constructor안 dfineProperty하는 로직에 있었던 코드다.)\n    - 코드에서 꼭 표현해야 할 것! -> \"Transaction\"이다    \n* 설명3 update할 객체 세팅 방법 변경 \n    - 기존에는 뷰모델 #isUpdated에 직접 Set객체에 add통해 설정했지만 현재는 ViewModelSubject 클래스로 이동해 상속받았기 때문에 부모에게 호출하고 있다.(this.add(...))\n    ```js\n    //기존\n        vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v));\n    ```\n* 설명4 ViewModel.notify(this); 제거\n    - 기존에는 뷰모델이 직접 자신에게 notify를 등록했는데 지금은 하지 않는다. 왜? \n        - 생성시점에 등록 안할거고 addListener할때 lazy하게 등록할 것이기 때문!\n        - addListener에 lazy하는것도 뷰모델 서브젝트가 알아서 할 것이다. \n\n* 설명5 ViewModelListener Class viewmodelUpdated 함수 오버라이딩\n    - ViewModelListener Class viewmodelUpdated 함수를 ViewModelSubject에서 오버라이딩 하지 않았다.\n    그래서 ViewModel에서 오버라이딩 하지 않으면 throw된다.\n    - 이번 강의 ViewModel 상속 관계도  \n    : ViewModel -> ViewModelSubject -> ViewModelListener\n    - 추가적으로 설명3과 같이 this.#isUpdated.add(v) -> this.add(v)로 코드가 변경됐다.\n\n* 설명6 트렌젝션으로 setParent로 한번에 처리\n    - 기존에는 아래와 같은 코드를 setPraent 함수로 한번에 처리 했습니다.\n    v.parent = this; v.subKey = k;, v.addListener(this); \n\n* 추가 설명\n    - 그래서 부모 자식간, 필드 접근 권한, 트렌젝션에 의해 계층 권한이 생기는 경우 직접 변수에 접근한는 이유는 다양하다. \n    - 권한관계라는건 발생하는건 여러가지 인데 물론 직짜 권한때문에 일어나느 경우가 많지만 트렌젝션때문에 일어나는 경우도 비일비재 하다.\n    - 코드를 함수로 빼기위해서 코드를 한번 더 정리하기 때문에 코드 부분이 깔금하게 될 수 있다. \n    - 코드가 길다 싶으면 외부함수, 스태틱함수로 변경하는건 좋은 연습니다.  \n\n\n\n# 3. Visitor Pattern\n\n* Scanner? \n    - 특정 el 하위를 검색해서 viewmodel대상인 여부를 확인해서 BinderItem을 만들어서 binder에게 넘겨준다. \n\n## 리팩토링 전 Scanner 소스 설명\n\n```js\n    const Scanner = class{\n        scan(el, _ = type(el, HTMLElement)){\n            const binder = new Binder;\n            this.checkItem(binder, el);\n            \n            //설명2 Visitor 패턴 적용 대상\n            const stack = [el.firstElementChild]; \n            let target;\n            while(target = stack.pop()){\n                this.checkItem(binder, target);\n                if(target.firstElementChild) stack.push(target.firstElementChild); \n                if(target.nextElementSibling) stack.push(target.nextElementSibling);\n            }\n            //설명2-end\n\n            return binder;\n        }\n        checkItem(binder, el){\n            //설명1 스캐너 역할\n            const vm = el.getAttribute(\"data-viewmodel\"); \n            if(vm) binder.add(new BinderItem(el, vm));\n        } \n    };\n\n```\n\n* 설명1 스캐너의 역할\n    - Binder의 Scanner가 아니라 Scanner Class로 빠진이유. (스캐너를 빼낸 이유) \n    - vuejs el속성들을 쓰고 싶다면 이곳에서 조작 후 아이템에 꽂아 주면 된다. \n\n* 설명2 Visitor 패턴 \n    - dom을 파싱 하는 부분은 Scanner, Binder class역할이라고 보기에 어렵다. 그래서 Visitor 패턴을 사용한다. \n    - Visitor 패턴 등장 인물2개/ care taker(원본데이터, 보살핌을 받는애)\u001d - Visitor 패턴 \n    - Visitor에게 caretaker를 주면 Visitor가 돌아준다? \n\n* binder? \n    - 그림을 그릴 대상을 binderItem으로 가지고 있다가 viewmodel에 꽂아 주면 viewmodel에 맞게 그림을 그려주는 역할을 하고 있다. \n\n\n\n\n## 리팩토링 후 Scanner 소스 설명\n```js\n    const Visitor = class {\n        //설명1\n        visit(action, target, _0=type(action, \"function\")) {\n            throw \"override\" \n        }\n    };\n\n    const DomVisitor = class extends Visitor{\n        //설명2 Generic\n        visit(action, target, _0=type(action, \"function\"), _1=type(target, HTMLElement)) {\n            const stack = [];\n            let curr = target.firstElementChild; \n            do {\n                action(curr);\n                if (curr.firstElementChild) stack.push(curr.firstElementChild); \n                if (curr.nextElementSibling) stack.push(curr.nextElementSibling);\n            } while (curr = stack.pop()); \n        }\n    };\n\n    const Scanner = class {\n        #visitor\n        constructor (visitor, _ = type(visitor, DomVisitor)) {\n            this.#visitor = visitor;\n        }\n        scan (target, _ = type9target, HTMLElement) {\n            const binder = new Binder\n            const f = el => {\n                const vm = el.getAttribute('data-viewmodel')\n                if (vm) binder.add(new BinderItem(el, vm))\n            }\n            f(target)\n            this.#visitor.visit(f, target)\n            return binder;\n        }\n    }\n\n```\n\n* 설명1 추상인터페이스\n    - 추상인터페이스에서 target이 어떤 타입(HTMLElement, JSON 등등)인지 알 필요가 없습니다. \n    - 오버라이드를 하지 않으면 죽기때문에! 즉 오버라이드할때 target의 타입을 지정해줘야 한다. \n\n* 설명2 Generic\n    - 자식에서 구체적인 타입을 알게 되는 것을 Generic이라고 한다. \n    - Generic은 원래 class옆에 표시하는건데 자바스크립트에서는 Generic이 있지 않기 때문에 이렇게 표시해준다. \n    - 언어가 어떤 기능을 지원하는것보단 그 개념을 어떻게 적용하는지가 중요하다. \n\n# 4. 추상계층 불일치\n* Scanner 클래스 리팩토링! 추상계층을 일치시켜주는 작업을 한다.  \n* 연역적인 케이스를 가지고 연역적으로 원리를(추상적으로) 도출한뒤(귀납적) 다시 연역적으로 다시 도출  \n    - 귀납적: 원리 -> 현상 예측/ 연역적: 현상 -> 원리 도출\n\n![](./4회/추상계층불일치/추상계층불일치1.png)\n![](./4회/추상계층불일치/추상계층불일치2.png)\n1. Scanner 클래스 constructor에 Domvisitor객체를 주입\n    * 왜 Domvisitor를 바로 만들지 않고 Visitor 클래스를 만들어서 상속 받아서 구현했나? \n    * 순수한 메모리 객체? Dom에 의존적이 네이티브 객체? \n    \n    * 계층이 2, 1개 로 나뉘어 있다. \n        - Visitor, Domvisotor (순수한 메모리객체, Dom에 의존적인 네이티브 객체)\n        - Scanner\n        \n    * 한쪽이 추상계층으로 했다면 다른 한쪽도 추상계층으로 맞춰줘야 한다.  \n    \n       \n\n![](./4회/추상계층불일치/추상계층불일치3.png)\n\n2. 리팩토링 전후의 Scanner Class 비교\n\n\n![](./4회/추상계층불일치/추상계층불일치4.png)\n\n3. Scanner 클래스 scan에 Element 지식 설명\n    * 이것도 추상계층으로 나눈다 \n    * 리펙토링을 하면 Scanner 클래스는 인메모리 객체만 남게 된다. (네이티브 객체가 하나도 없다)\n        - 기존에 Scanner는 dom베이스 객체가 있었는데 없애 버린것이다. \n    * Scanner를 추상화 시켜 dom 객체가 없다면 DomScanner는 Scanner를 상속받아 scan 함수를 오버라이딩 한다.  \n        - DomScanner 클래스에 생성자 함수 DomVisitor를 받는다. 그리고 super로 Scanner 클래스에 전달하는데 Scanner 클래스는 Visitor 클래스를 받는다. \n            - 자식은 부모를 대체 가능하기 때문에 문제 없다. \n    * Scanner scan 함수에 받는 인자 값 타입이 없었는데 DomScanner scan에 타입을 설정함(제너릭 기능)으로 구상화 했다.\n\n![](./4회/추상계층불일치/추상계층불일치5.png)\n\n4. Scanner, Visitor, DomScanner, DomVisitor 클래스 설명(하늘색선 있는 ppt)\n    > 아래 두 계층을 나눈 설명은 이게 바로 추상레이어를 일치 시켜준 것이다. \n    * Scanner, Visitor: Dom에 대한 네이티브 객체가 없고 인메모리 객체만 있는 추상 계층이 생기고 \n    * DomScanner, DomVisitor: 더러운 Dom관련 처리를 해주는 구상클래스 세계\n    \n    * 마틴파울러 아저씨는 기능, 도메인 적인 기능을 나눠서 서로 협력하게 만들어야 한다고 얘기 하셨다. \n        - 기능: 변하지 않는 부분\n        - 도메인: 변하는 부분 \n            - 그래야 나중에 도메인이 바뀌었을때 그 부분만 교체 가능하다고 얘기 하셨다. \n            - 그래서 여기서 Scanner, Visitor는 \"기능\"적인 부분\n                DomScanner, DomVisitor은 \"도메인(Dom)\"을 처리하는 부분이 된다. \n        - 그런데 도메인은 상황에 따라 바뀔 수 있다. 어떤경우에는 비즈니스 부분을 보호하고 네이티브에 이것이 스프링, my-sql? 이되던 문제 없이 동작할거야 라고 하면 도메인 쪽이 기능이 되는 것이다. 즉 변한는 부분과 변하지 않는 부분을 구분하라는 것이다. \n        \n    * 결과적으로 \"변화율\"을 고려해서 레이어를 나눈것이다. \n        - 변화율때문에 코드를 나눠서 정복한것이있다 그건? 코드를 고치지 않고 코드를 추가함으로 수정할 수 있다.\n            - 예를 들어 Dom이 아닌 Canvas를 다룰 때 코드를 고치지 않고 CanvasScanner, CanvasVisitor를 만들면 됩니다.\n            따라서 기존 코드의 변화가 없고 회귀 테스트가 필요없다. \n            - 여기에 \"추상레이어\"의 장점은 코드를 수정하는게 아니라 코드를 추가함으로 요구사항, 문제가 생겼을때 해결할 수 있다.  여기서는 요구사항에 따라서 어떠한 Scanner, Visitor를 만들어 추가 할 수 있다. \n            - 이게 바로 \"설계\"에 목메다는 이유입니다!!!\n            \n    * 추상화 계층을 분리함으로써 \"OCP\" 를 지키고 있다. 다른말고 OCP를 지키려면 추상화 클래스가 필수다! \n        - O: OPEN, C: CLOSE - 확장에는 열려있고 수정에는 닫혀있다!\n        - SOLID 법칙은 사실 법칙이 아니라 객체지향설계를 잘하면 얻어질 수 있는 결과물이다. \n    \n    * 추상화계층을 만듬으로 \"OCP\"말고 다른 장점 \n        - 추상화계층 클래스(Scanner, Visitor 클래스)는 initialize할때 로딩하고 구상클래스틑 원할때 동적 로딩하면 된다. \n          즉 코드의 늦은 초기화, 클래스 초기화를 유도할 수 있다.   \n            -> 이게 \"의존성 역전의 법칙(DIP)\"이다...\n\n![](./4회/추상계층불일치/추상계층불일치6.png)\n\n5. 구상 visitor를 구상 Scanner에게 줘서 scaner type 변수에 넘기다.\n\n\n\n# 5. 설계 종합\n* UML diagram은 스팩이 너무 넓기 때문에 아래 캡쳐한것처럼 클래스 관계도를 그려서 설명합니다.\n\n\n![](./4회/설계종합/설계종합1.png)\n\n![](./4회/설계종합/설계종합2.png)\n\n![](./4회/설계종합/설계종합3.png)\n\n![](./4회/설계종합/설계종합4.png)\n\n1. ViewModel \n> subject관련된건 ViewModelSubject로 이사갔어요.  \n> Dom에 의존적인 클래스 없다. 모두 인메모리 객체를 가지고 있다.  \n\n2. ViewModelSubject \n* 이때 최적화를 했다.  \n* 좋은코드가 나오는 이유는 인간머리의 복잡성을 정복할 정도 쪼개져 있기때문,,, 그런데 쪼개는게 힘들어 왜? 아무렇게나 쪼개면 일관성이 없기 때문에 어떻게 쪼갤지 모르는게 문제야.\n* 객체 지향은 역할에 따라서 쪼개는것이다 !\n\n3. ViewModelListener\n* [대기]\n\n4. ViewModelValue\n* 아래와 같이 ViewModelValue은  다음 세개 클래스에 의존 되어 있다. -> ViewModel, ViewModelSubject, ViewModelListener Class\n* 선이 많이 몰리면 수정하기 어려운 객체 \n    ```\n    ViewModel -> ViewModelSubject -> ViewModelListener\n    ViewModelValue -> ViewModel\n    ViewModelValue -> ViewModelSubject\n    ViewModelValue -> ViewModelListener\n    ```\n\n* 이래서 Dom과 관련되 lib, fw에서는 제일 먼저 자기 이벤트를 정복해서 네이티브 이벤트를 보여주지 않으려고 한다.  \n    - 왜냐하면 네이티브이벤트에 돔과 과련된 이벤트를 짜면 감당이 안되기 때문이다.   \n    - 이벤트는 옵저버 모델에서 무조건 이렇게 무겁게 된다.  \n    - 옵저버 모델의 약점이다. ㅠ  \n\n* 하지만 설계잘했다. ! 왜? \n    - 단방향 의존성이기 때문이다. 양향도 없고 순회해서 다시 돌아오는 경우도 없다!\n    - 연관은 자연스럽다! 왜? 코드를 객체로 뺏고 그 객체를 빼기전 코드와 연관 지었기 때문에 의존성이 자동으로 생긴다. 하지만 의존성이 발생하는게 나쁜게 아니라 의존성을 단방향으로 유지하는게 중요한 것입니다. \t\t\n    \n* 클래스 관계도를 그리고 코드를 수정할일이 생겼을때 무거운 코드 클래스인지 확인해자.\n\n\n![](./4회/설계종합/설계종합5.png)\n\n![](./4회/설계종합/설계종합6.png)\n\n![](./4회/설계종합/설계종합7.png)\n\n![](./4회/설계종합/설계종합8.png)\n\n5. Scanner, DomScanner  \n* DomScanner에 DomVisitor를 넣어줬긴 했지만\n    - DomScanner가 DomVisitor에 의존적이다 물어보면?... 애매해 하지만 간접적으로 알고 있다. \n    - DomScanner는 DomVisitor를 생성자 함수에서 받고 있다.  \n\n    ```\n    DomScanner -> Scanner -> Visitor <- DomVisitor\n    ```\n\n![](./4회/설계종합/설계종합9.png)\n6. Binder\n> 결국 Scanner는 Binder를 만들어 낸다. \n* Binder의 주요 기능은? \n    - add를 통해서 items를 set으로 가지고 있다 \n    - viewModelUpdate Listener를 구현해서 Listener로 부터 업데이트 된것을 render에 반영할 수 있고 \n    - addProcessor로 rendering에 필요한 것들을 processor 로 가지고 \n    - 특정 뷰모델은 watch, unwatch, 직접 render할 수 있다.  \n    ```\n    DomScanner -> Scanner -> Visitor <- DomVisitor\n                  Scanner -> Binder\n    ```\n\n\n![](./4회/설계종합/설계종합10.png)\n\n7. Binder의 의존성을 확인해보자 \n    - 모두 단방향이다. Binder는 Scanner쪽을 모르고 ViewModelValue에서 Binder를 의존하지 않기 때문에 모두 단방향이다. \n    - 나가는 선이 많은(Binder) 같이 변화, 깨지기 쉬운 클래스  \n        반대로 들어오는 선이이 많은 클래스(ViewModelValue)는 무거운 클래스 \n    ```\n    Binder -> ViewModel\n    Binder -> ViewModelValue\n    Binder -> ViewModelListener\n    ```\n![](./4회/설계종합/설계종합11.png)\n\n8. BinderItem\n* element, viewmodel을 알고 있다. \n* element가 들어가 있어서 문제가 된다. \n* Binder -> BinderItem\n\n![](./4회/설계종합/설계종합12.png)\n\n9. Processor\n* element, viewModel을 받아서 처리해주는 클래스 \n* Binder -> Processor\n\n![](./4회/설계종합/설계종합13.png)\n\n10. ConcreateProcessor\n* Processsor는 method만 가지고 있는 것 구상 Processor가 실제적으로 Dom 지식을 가지고 있다. \n* ConcreateProcessor -> Processor\n\n![](./4회/설계종합/설계종합14.png)\n\n11. ConcreateProcessor, DomScanner, DomVisitor 클래스\n* 실제 Dom 정보를 가지고 있는 클래스는? 그리고 클라이언트에서 작성해야할 클래스는? \t\n    - <u>위 클래스를 제외 하고 인메모리 객체를 가지고 있다.</u>\n\n# 6.종합설명\n* MVVM이 좋은점? \n    - ConcreateProcessor, DomScanner, DomVisitor 클래스를 교체하면 안드로이드, IOS에서 사용할 수 있다. \n    \n* 옵저버 패턴을 적용해서 ViewModel 클래스 주변으로 \"ViewModelSubject, ViewModelListener, ViewModelValue\" 다음과 같은 클래스들이 생겨났다. \n    - 그림, 설명한것처럼 비용이 싸지 않습니다. 그래서 Binder에서 render를 call하는 경우도 있습니다. \n\t\t\n* 코드를 깍아나갈때 중요한 점 \n\t- 추상화 레벨을 맞춰야 한다. \n\t    * Binder, Scanner, Visitor이 세개 클래스는 dom 네이티브 객체를 가지고 있지 않는다. \n\t    * 이것을 맞추기 위해서 DomScanner, DomVisitor가 탄생한 것   \n\n* 코드를 짤때 궁극적으로 강사님이 원하는건? \n\t- dom, node, db가 됐던 특정한 네이티브 지식이 나오면 코드를 분리하자 그리고 그 위에 네이티브 지식을 모르는 것들끼리 통신을 하게 하자 ! 그러면 녹색 클래스를(Dom 네이티브지식을 가진 클래스) 제외하고 재활용 할 수 있다.  \n        * Binder, Scaner, Visitor 클래스가 어떻게 되어 있는지 확인해보자 \n\n* 다음 시간에는 중요한 패턴 2가지를 배울 것 입니다. \n\t- 추상팩토리메소드 패턴 \n\t- 커맨드 패턴 \n\t\n\t\n\t\n# 7.작업 클래스\n```js\n    const ViewModelListener = class {}\n    const ViewModelSubject = class extends ViewModelListener {}\n    const ViewModel = class extends ViewModelSubject {}\n    const ViewModelValue = class {}\n\n    const BinderItem = class {}\n    const Binder = class extends ViewModelListener {}\n\n    const Processor = class {}\n    \n    const Scanner = class {}\n    const DomScanner = class extends Scanner {}\n\n    const Visitor = class {}\n    const DomVisitor = class extends Visitor {}\n\n    const scanner = new DomScanner(new DomVisitor);\n    \n    binder.addProcessor(new class extends Processor {})\n    binder.addProcessor(new class extends Processor {})\n    binder.addProcessor(new class extends Processor {})\n    binder.addProcessor(new class extends Processor {})\n\n```\n\n# 8.작업 코드\n```html\n  <!DOCTYPE html>\n  <html lang=\"en\">\n\n  <head>\n      <meta charset=\"UTF-8\">\n      <title>MVVM 4회</title>\n  </head>\n\n  <body>\n      <section id=\"target\" data-viewmodel=\"wrapper\">\n          <h2 data-viewmodel=\"title\"></h2>\n          <section data-viewmodel=\"contents\"></section>\n      </section>\n\n      <script>\n      </script>\n  </body>\n\n  </html>\n```\n\n``` js\n  const type = (target, type) => {\n      if (typeof type == \"string\") {\n          if (typeof target != type) throw `invalid type ${target} : ${type}`\n      } else if (!(target instanceof type)) {\n          throw `invalid type ${target} : ${type}`\n      }\n      return target;\n  }\n\n  const ViewModelListener = class {\n      viewmodelUpdated(updated) {\n          throw 'override';\n      }\n  }\n\n  const ViewModelSubject = class extends ViewModelListener {\n      static# subjects = new Set;\n      static# inited = false;\n      static notify() {\n          const f = () => {\n              this.#subjects.forEach(v => {\n                  if (v.#info.size) {\n                      v.notify();\n                      v.clear();\n                  }\n              })\n              if (this.#inited) requestAnimationFrame(f);\n          }\n          requestAnimationFrame(f)\n      }\n      static watch(vm, _ = type(vm, ViewModelListener)) {\n          this.#subjects.add(vm);\n          if (!this.#inited) {\n              this.#inited = true;\n              this.notify();\n          }\n      }\n      static unwatch(vm, _ = type(vm, ViewModelListener)) {\n          this.#subjects.delete(vm);\n          if (!this.#subjects.size) this.#inited = false;\n      }#\n      info = new Set; #listeners = new Set;\n      add(v, _ = type(v, ViewModelValue)) {\n          this.#info.add(v);\n      }\n      clear() {\n          this.#info.clear();\n      }\n      addListener(v, _ = type(v, ViewModelListener)) {\n          this.#listeners.add(v);\n          ViewModelSubject.watch(this);\n      }\n      removeListener(v, _ = type(v, ViewModelListener)) {\n          this.#listeners.delete(v);\n          if (!this.#listeners.size) ViewModelSubject.unwatch(this);\n      }\n      notify() {\n          this.#listeners.forEach(v => v.viewmodelUpdated(this.#info))\n      }\n  }\n\n\n  const ViewModel = class extends ViewModelSubject {\n      static get(data) {\n          return new ViewModel(data);\n      }\n      styles = {};\n      attributes = {};\n      properties = {};\n      events = {};\n      #subKey = '';\n      #parent = null;\n      \n      get subKey() {\n          return this.#subKey;\n      } \n      // read only\n      get parent() {\n          return this.#parent;\n      }\n      setParent(parent, subKey) {\n          this.#parent = type(parent, ViewModel);\n          this.#subKey = subKey;\n          this.addListener(parent);\n      }\n\n      static descriptor = (vm, category, k, v) => ({\n          enumerable: true,\n          get: () => v,\n          set(newV) {\n              v = newV;\n              vm.add(new ViewModelValue(vm.subKey, category, k, v));\n          }\n      })\n      static define = (vm, category, obj) => (\n          Object.defineProperties(\n              obj,\n              Object.entries(obj)\n              .reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {});\n          )\n      )\n      constructor(data, _ = type(data, 'object')) {\n          super();\n          Object.entries(data).forEach(([k, v]) => {\n              if ('styles,attributes,properties'.includes(k)) {\n                  if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`;\n                  this[k] = ViewModel.define(this, k, v);\n              } else {\n                  Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))\n                  if (v instanceof ViewModel) {\n                      v.setParent(this, k);\n                  }\n              }\n          })\n          Object.seal(this);\n      }\n      viewmodelUpdated(updated) {\n          updated.forEach(v => this.add(v));\n      }\n  }\n\n  const ViewModelValue = class {\n      subKey;\n      category;\n      k;\n      v;\n      constructor(subKey, category, k, v) {\n          Object.assign(this, {\n              subKey,\n              category,\n              k,\n              v\n          })\n          Object.freeze(this);\n      }\n  }\n\n  const BinderItem = class {\n      el;\n      vmName;\n      constructor(el, vmName, _0 = type(el, HTMLElement), _1 = type(vmName, 'string')) {\n          this.el = el;\n          this.vmName = vmName;\n          Object.freeze(this);\n      }\n  }\n\n  const Binder = class extends ViewModelListener {\n      #items = new Set;\n      #processors = {};\n      add(v, _ = type(v, BinderItem)) {\n          this.#items.add(v);\n      }\n      addProcessor(v, _ = type(v, Processor)) {\n          this.#processors[v.category] = v;\n      }\n      render(viewmodel, _ = type(viewmodel, ViewModel)) {\n          const processores = Object.entries(this.#processors);\n          this.#items.forEach(({vmName,el}) => {\n              const vm = type(viewmodel[vmName], ViewModel);\n              processores.forEach(([pk, processor]) => {\n                  Object.entries(vm[pk]).forEach(([k, v]) => {\n                      processor.process(vm, el, k, v);\n                  })\n              })\n          })\n      }\n\n      watch(viewmodel, _ = type(viewmodel, ViewModel)) {\n          viewmodel.addListener(this);\n          this.render(viewmodel);\n      }\n\n      unwatch(viewmodel, _ = type(viewmodel, ViewModel)) {\n          viewmodel.removeListener(this);\n      }\n\n      viewmodelUpdated(updated) {\n          const items = {};\n          this.#items.forEach(({vmName,el}) => {\n              items[vmName] = [type(rootViewModel[vmName], ViewModel), el];\n          })\n          updated.forEach(({subKey,category,k,v}) => {\n              if (!items[subKey]) return;\n              const [vm, el] = items[subKey], processor = this.#processors[category];\n              if (!el || !processor) return;\n              processor.process(vm, el, k, v);\n          })\n      }\n  }\n\n  const Processor = class {\n      category;\n      constructor(category) {\n          this.category = category;\n          Object.freeze(this);\n      }\n      process(vm, el, k, v, _0 = type(vm, ViewModel),\n                              _1 = type(el, HTMLElement),\n                              _2 = type(k, \"string\")) {\n          this._process(vm, el, k, v)\n      }\n      _process(vm, el, k, v) {\n          throw 'override';\n      }\n  }\n\n  const Scanner = class {\n      #visitor\n      \n      constructor(visitor, _ = type(visitor, Visitor)) {\n          this.#visitor = visitor;\n      }\n      visit(f, target) {\n          this.#visitor.visit(f, target);\n      }\n      scan(target) {\n          throw `override`;\n      }\n  }\n\n  const DomScanner = class extends Scanner {\n      constructor(visitor, _ = type(visitor, DomVisitor)) {\n          super(visitor);\n      }\n      scan(target, _ = type(target, HTMLElement)) {\n          const binder = new Binder;\n          const f = el => {\n              const vm = el.getAttribute('data-viewmodel');\n              if (vm) binder.add(new BinderItem(el, vm));\n          }\n          f(target);\n          this.visit(f, target);\n          return binder;\n      }\n  }\n\n  const Visitor = class {\n      visit(action, target, _ = type(action, 'function')) {\n          throw 'override';\n      }\n  }\n  const DomVisitor = class extends Visitor {\n      visit(action, target, _0 = type(action, 'function'), _1 = type(target, HTMLElement)) {\n          const stack = [];\n          let curr = target.firstElementChild;\n          do {\n              action(curr);\n              if (curr.firstElementChild) stack.push(curr.firstElementChild);\n              if (curr.nextElementSibling) stack.push(curr.nextElementSibling);\n          } while (curr = stack.pop())\n      }\n  }\n\n  const scanner = new DomScanner(new DomVisitor);\n  const binder = scanner.scan(document.querySelector('#target'))\n  binder.addProcessor(new class extends Processor {\n      _process(vm, el, k, v) { el.style[k] = v; }\n  }('styles'))\n  binder.addProcessor(new class extends Processor {\n      _process(vm, el, k, v) { el.setAttribute(k, v); }\n  }('attributes'))\n  binder.addProcessor(new class extends Processor {\n      _process(vm, el, k, v) { el[k] = v; }\n  }('properties'))\n  binder.addProcessor(new class extends Processor {\n      _process(vm, el, k, v) { el[`on${k}`] = e => v.call(el, e, vm); }\n  }('events'))\n\n  const getRandom = () => parseInt(Math.random() * 150) + 100;\n  const wrapper = ViewModel.get({\n      styles: {\n          width: '50%',\n          background: '#ffa',\n          cursor: 'pointer'\n      },\n      events: {\n          click(e, vm) {\n              vm.parent.isStop = true\n          }\n      }\n  })\n  const title = ViewModel.get({\n      properties: {\n          innerHTML: 'Title'\n      }\n  })\n  const contents = ViewModel.get({\n      properties: {\n          innerHTML: 'Contents'\n      }\n  })\n  const rootViewModel = ViewModel.get({\n      isStop: false,\n      changeContents() {\n          this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`\n          this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '')\n      },\n      wrapper,\n      title,\n      contents\n  })\n  \n  binder.watch(rootViewModel)\n  const f = () => {\n      rootViewModel.changeContents()\n      if (!rootViewModel.isStop) requestAnimationFrame(f)\n  }\n  requestAnimationFrame(f)\n```\n\n태그: [대기]","excerpt":"…","fields":{"slug":"/OOPWithJavascript_4/"},"frontmatter":{"date":"Mar 15, 2020","title":"객체지향 자바스크립트 4회차(MVVM pattern 개선2)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n\n# 목표 \n* 전략적 패턴 적용\n    - 기존 Binder 클래스가 코드로 확정 되어 있다. 이 부분을 전략적으로 빼내는 방법을 살펴본다. \n    \n* call -> Observation\n    - Binder, ViewModel 통신을 이전 강의 까지 call로 해결해쓴는데 이번에 Observation으로 해결을 설명합니다.  \n    그래서 결과적으로 모델이 변하면 binder가 자동으로 view를변하게 해준는게 목표이다.   \n        * [전 강의 observe -> call로 대체](https://happyjy.github.io/객체지향%20자바스크립트_2/#observe---call로-대체)  \n\n* 배울 keyword \n    - Strategy Pattern, Dependency Injection, \n    - Observer Pattern\n    - Template method Pattern\n    - Composite Pattern\n\n\n# 1. Strategy Pattern(Binder Class에 적용)\n* 참고: [제로초 전략패턴](https://www.zerocho.com/category/JavaScript/post/580f17ef77023c0015ee9688)\n\n## 적용 준비\n우리는 5가지 단계를 통해서 `전략패턴`과, 전략패턴이 적용되기 위해 필수 조건인 `알고리즘의 일반화`를 배울것이다. \n\n1. Binder Class에서 Structure, strategy부분을 나눈다. \n2. strategy의 공통점을 찾는다. \n3. 찾은 strategy가 어떻게 상태와 관계를 맞는지 확인\n    * 상태: 이전강의에서 최종코드 Binder class render method에 있는 코드 vm.styles, vm.attrivutes, vm.properties, vm.events\n    * 공통된 Strategy: k, v, el, viewmodel\n4. 1,2,3에 도출된 형을 만들고 (Strategy, composite, template method pattern 적용)\n5. 만든 형을 가지고 알고리즘을 만들것 입니다. (알고리즘 일반화)\n\n```\n* Strategy pattern\n    - Composite pattern: Binder class에서 Stratege 부분을 뽑아내는 \n    - Composition하는 과정에서 아래 개념 \n        * dependency, dependency injection \n        * Template method pattern\n* 알고리즘의 일반화 \n    - Strtegy Pattern을 통해서 Binder Class를 수정한다(addProcess method추가, render method수정)\n```\n\n## Strategy Pattern 정의\n* 어떤 문제를 해결하기 위한 지식적인 부분, 도메인, 알고리즘을 교체하면서 문제를 해결할 수 있다. \n\n## Binder class에 Strategy Pattern 적용 준비\n> `Binder class`의 `Strategy`부분을 외제화 시켜`Processor class`인스턴스 위임을 받아서 처리하기 위한 과정을 설명할 것입니다.\n> Binder class는 Structure&control, Strategy부분으로 나뉘어 있다. 아래를 확인해보자 \n\n### Binder class의 구조부분 확인\n![Structure & control](./3회/1.Strategy_Structure&Control.png) \n\n### Binder class의 전략부분 확인\n* 전략부분: 특정 도메인(알고리즘,지식)을 해결하기 위한 전략적인 부분 \n![Strategy](./3회/2.Strategy_Strategy.png)\n\n* Binder class 전략 부분 code를 Object로 변경해야한다.\n    - code를 Obejct로 변경하는 작업을 Composition이라고하며 바로아래 설명이 시작합니다.\n![Code->Object](./3회/3.Strategy_CodeToObject.png)\n\n## Composition에 대해서 \n> * Binder에서 strategy(algorithm, knowlege, domain) code를 뽑아내 Object로 변경으로 인터페이를 정의해 주입 받는 부분에서 사용할 수 있도록 변경하는 작업 \n> * Depency Injection & Composition 관계\n>   - Composition작업으로 Binder class는 dependency가 생기고 외부에서 Strategy부분을 주입 받으면서 Depency Injection이 일어난다. \n\n* 객체 지향에서는 composition을 사용해서 해결한다. composition이란 **code를 object로 바꾸는 작업입니다.**\n* compositoin작업으로 code를 object로 수정하는 이유는? \n    - code를 고치면 의존하고 있는 부분을 테스트를 다시 해야 합니다.\n    - 그래서 **code를 안바꾸고서 object로 바꾸고 싶다.**\n* 전략을 도출하는데 성공했으면 code에서 `strategy부분`이 `structure`와 어떻게 관계를 맺는지 잘 확인해보고 그리고나서 code부분을 object로 변경합니다.\n* 하지만 임의의 객체로 변경하면 변경하려는 code와 `일반화 관계`를 맺을 수 없다. 그래서 **우리는 객체를 도출할떄 interface나 class로 type으로 노출**해야 한다.\n<u>왜냐하면 type을 정해야지만 code가 어떤식의 객체인지를 알아야 변경했을때 적용할 수 있기 때문이다.</u>\n        \n### Dependency가 생기는 이유 \n* code를 Object로 변경했기때문 \n* code대신에 type을 정의해서 객체를 받아 들이면 기존코드에는 의존이 없었는데 객체를 알아야 Binder를 진행할 수 있다.  \n그래서 code를 외부객체 composition으로 바꿀 것이다. 그러면 외부에서 공급되는 객체를 알아야 Binder가 작동할 수 있다.(그래서 Strategy 부분에 대해서 의존성이 생긴다 )\n* 객체지향에서 Dependency가 생기는 이유가 뭘까? \n    - 위임했기때문이 아니다! **Strategy를 외부 객체에 의해서 해결하고 싶다. <u>이렇게 하고 싶은 이유는 변화가 있을때 마다 code를 변경해야 하기 때문이다.**</u> 그래서 code를 object로 바꿔주면 바꿔준 object에 대해서 의존성이 생기는 것 입니다. 이렇게 Binder는 Binder strategy와 의존관계가 생성이 됩니다.\n\n### DI(Dependency Injection)\n* 의존성이 생겼을때 내부에서 의존성이 있는 sub Type을 만들어 내는 경우가 있고 공급받는 경우가 있는데 내부에서 만들면 다시 하드코딩을 해야하기 때문에 **외부에서 공급**받는 것을 말한다.(그래야 내부에는 type에 대한 의존만 있고 특정 객체에대한 의존성을 없앨 수 있다.) \n\n### 정리\n> Binder의 Strategy 부분을 Composite pattern으로 변경의 결론 \n* **Composition(코드를 객체로 빼내는 순간)을 하면 `Dependency`,`Dependency Injection`이 생긴다.**\n* `Dependency`가 생기는 이유는 코드를 객체로 변경했기 때문 \n    - 객체에 대한 의존성을 내부에서 생성해버리면 dependency만 생긴다. 이러면 다시 코드를 건드려야 해서 외부에서 공급(`Dependency Injection`)받아야지면 객체를 뺀이유가 생긴다.  \n\n# Binder 클래스 리팩토링\n## Binder Class에 Composition 적용 과정\n![Processor Class & Tempalte Method](./3회/4.ProcessorClass_TempalteMethod.png) \n1. 연역적 추리(다양한 현상으로 부터 원리가 되는 추상화를 도출)를 통해서 strategy로 부터 공통점을 이끌어낸다. \n    - 연역적 추리를 통해 도출한 결과물: viewmodel, el, k, v\n2. 도출한 결과물을 통해서 Processor Class 생성\n3. 생선한 Processort Class는 Template Method Pattenr을 가지고 있다.\n\n### Template method Pattern(Processor Class)\n> * 자신이 해야할일을 하고 Hook method에 위임을 통해서 나머지 일을 처리한다.   \n> * 외부에서 Processor클래스 _process를 바로 호출하면 throw걸린다.  \n    - 그래서 **Proccessor 클래스를 확장(상속)한 클래스에 _process를 재정의(overriding)한 곳에서 처리**하도록 의도해야 한다. \n* 부모와 자식사이에 Composition 일어난다. \n    - 전략을 위임 했는데 외부에서 주입 받아 위임한것이 아니라 상속 받은 객체에게 위임했다. \n    - 그래서 우리가 DI를 두가지 방향으로 위임할 수 있다. \n        1. 외부에서 주입\n        2. 자식에서 주입 \n* process method\n    - 외부에서는 process가 template method다. \n    - 내부에서는 process가 처리할때는 내부에서 선언한 메소드(_process)에 의존되어 있다. \n* _process method\n    -  Hook mehtod라고 한다.\n* [보완]객체지향 책에서 템플릿 메소드 부분 정리해서 추가하기 \n\n\n\n## STEP1 Binder class에서 Processor class 정리\n> Binder class에서 strategy pattern, composition pattern을 통해서 Processor class를 생성하고  \n> Processor에 여러 전략을 사용하기 위해서 Template Method pattern을 적용  \n> 아래에서 Template Method pattern을 적용하기 위해서 Processor Class를 상속한것을 설명합니다.\n\n* Binder class의 Strategy부분은 Processor class 인스턴스 위임을 받아서 처리하려고한다. \n* Binder class는 composition적용으로 Processor class를 소유를 통해서(Processor class를 Dependency Injection)을 통해서 해결하려고 있고 이를 처리해주는 \n* Processor class에서는 process마다 다양한 처리 방법을 Template Method방법을 통해서 해결  \nclient code에 binder.addProcessor함수로 추가하는 intance(hook method) 참고 \n\n\n\n## Processor Class를 상속 받은 Hook Method \n![Processor Class & Hook Method](./3회/5.Processor_HookMethod.png) \n* 전략이 어떤 structure와 관련이 되어 있는지 내용이 부족하다.\n    * 그래서 Processort에서 받을만한 힌트는 vm의 key String값(viewmodel에 정의)으로 충분하다.\n* Processor를 상속받은 클래스에 _process를 override해서 더 이상 throw를 던지지 않고 el.style에 k값의 키에 v를 세팅 \n    - Binder class render는 view를 실제로 수정할때 사용되는 코드\n    - 여기서 k, v는 viewmodel에서 받은 key, value값이다. \n* 예를 들어 첫번째 el.style가 있는 코드는 cat(=category)는 Styles로 정의했다.\n* 익명상속된 클래스의 장점  \n: 만든 인스턴스를 한번만 만들어 한번만 사용하게해 다시 사용할 수 없게 한다. \n* 우리는 이렇게 el에 style, property, attribute, event를 설정할 수 있는 전략 4개를 만들었다. \n    - 4개 전략 이외에 예를들어 lazy loader, scroll injector등의 기능을 넣을 수 있게 됐다.  \n* 이렇게 Processor를 상속받아 만은 인스턴스는 각기 다른 객체이지만 하나 \u001c의 Processor type으로 인식하게 된다.  \n\n\n### 객체 망을 구성하는 3요소\n* 객체향은 객체망에 의해서 문제를 해결\n* 어떤 객체가 다른 객체를 '필드'수준, '메소드'수준, '자식'수준으로 안다. \n\n\n## STEP2 Binder class 변경 \n> Binder에서 strategy 부분을 공급 받기 위해서 만든 Process class를 생성/ 상속 받은 클래스 인스턴스까지 만들어 봤으니 외부에서 Strategy를 주입 받기에 주입받는 Binder를 수정해보자 \n\n![Processor Class & Hook Method](./3회/6.BinderClass_modification.png) \n* 변수 #processors 설명\n    - set으로 안만들고 Array로 만든 이유 \n    - 한개의 category당 한개의 값만 갖기 위해서(제일 마지막에 들어 온것만 덮어 쓴다)\n* 아래 코드 설명\n    - 아래 주석 설명1, 설명2 참고 \n    - processors의 순환문의 pk: Processor의 catetory(cat)   \n    \n* [보완]: 아래 설명을 따로 빼서 적어 놓기 \n```js\n    //# 설명1: 자바스크립트는 single thread machine이기 때문에 render method가 돌때 갑자기 addProcessor가 동작할 수 없다.\n    const processors = Object.entries(this.#processors);\n    this.#item.forEach(item => {\n        const vm = type(viewmodel[item.viewmodel], ViewModel);\n        const el = item.el;\n        //# 설명2\n        /*\n            # processor value \n            : Binder Class addProcessor에 의해서 생성된 #processors value\n                {\n                    styles: {category: \"styles\"}, \n                    attribute: {category:\"attribtues\"},\n                    properties: {category:\"properties\"},\n                    events: {category: \"events\"}\n                }\n\n            # vm value: ViewModel instance\n            : Binder Class render에 의해서 받은 value\n                : videModel Instacne에 아래 key값이 있다.\n                : 그래서 vm[pk]가 성립 가능\n                instance.styles\n                instance.attribute\n                instance.properties\n                instance.events                \n            \n            # processor.process()\n            : processor 인스턴스는 Process class를 상속받아서 생성\n\n        */\n        processors.forEach(([pk, processor]) => {\n            Object.entries(vm[pk]).forEach(([k,v])=>{\n                processor.process(vm, el, k, v);    //interface에 교환하는 작업 \n            });\n        });\n    });\n```\n\n### 알고리즘의 일반화 \n* 구조부분을 남기고 Strategy에 해당하는 code를 object를 type으로 빼냈다. \n* 그리고 빼낸 Object를 DI를 한다. \n* 그리고 받은 Object기준으로 알고리즘을 바꾸는것을 말한다.\n* **알고리즘의 일반화가 어렵기때문에 전략패턴을 사용하기 어렵다**\n    - 안정화 시키려면 Process class에 기능이 적은게 좋다. \n    - 그래야 Procssor를 의존하고 있는 Binder도 코드가 안 변하니까. \n    - 그래서 Binder코드를 짜기 어렵다. \n    - 이렇게 안정화 되어 있는 코드는 **약속하고 있는 protocol 내용이 적다.** \n    - 적은데도 똑같은 알고리즘을 작성하는 것이 어렵다. \n    - **그분이 processors를 forEach 돌리는 부분이다.**\n\n ## binder에 addProcessort 추가\n > Binder class가 전략 패턴으로 바뀜으로 addProcessor를 추가해 전략을 추가하는 로직이 추가 됐다.\n \n ![binderInstane_modification](./3회/7.BinderInstance_modification.png) \n\n * Binder가 Processor를 Dependency한다. \n    - Processor가 변경되면 Binder가 변경된다.\n    - 의존성은 한방향으로만 되어야한다. \n* Dependency가 생기면 Dependency Injection이 생긴다. \n    - code를 Object로 type으로 빼내면 Dependency가 생기고 Dependency Injection이 생긴다.  \n\n\n# 2. Observation Pattern\n![binderInstane_modification](./3회/8.ObserverPatternInMVVM.png) \n* 전 강의에서 binder대신에 call을 사용했다. 이번 시간에는 Observer Pattern을 적용할 것입니다. \n* 구현 메커니즘  \n위 사진에서 Binder, ViewModel 클래스 사이에 observe, notify를 구현으로 ViewModel이 변경됐을때 따로 Binder에게 알려 변경하지 않고 자동으로 변경되는 것으로 구현합니다.\n    - observe: Binder가 ViewModel을 감시한다고 설정하고 \n    - notify: ViewModel이 변하면 Binder에게 알려주는 형식이다. \n* recognize property change\n    - 어떻게 인메모리객체가 변할때 알려줄 수 있을까?  \n    자바스크립트에서는 \"defineProperty, Proxy\"이 두가지를 지원해줍니다. \n* defineProperty & Proxy  \n우리는 defineProperty의 3번째 인자 descriptor에 setter, getter의 속성을 이용해서 구현합니다.\n    - defineProperty: \n        * [defineProperty mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n        * [defineProperties mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)\n    - Proxy: ex6 부터 적용, babel로 변환이 안됨\n\n    \n## ViewModelListener class \n* mouseevent에서 eventListener를 등록할 때 함수로 등록합니다. \b하지만 지금은 객체의 특정한 함수를 호출해 observing 시킨다. \n* 아리 클래스는 Binder, ViewModel Class에 상속되어 사용됩니다.(즉 Binder, ViewModel Class에 viewmodelUpdated 함수를 재정의 해서 Observation pattern을 구현합니다.)  \n```js\n    const ViewModelListener = class {\n        viewmodelUpdated(updated) { throw 'override'; }\n    }\n```\n\n## ViewModel Class에 Observer Pattern 적용 \n아래 POINT1, 2, 3, 4, 4.1, 4.2 주석이 있으며 코드 아래 설명이 있습니다. \n\n``` js\n/*\n    # Class List\n        * ViewModelValue\n        * ViewModelListener\n        * ViewModel\n*/\nconst ViewModelValue = class {\n    category; k; v;\n    constructor(subKey, category, k, v) {        \n        this.category = category; \n        this.k = k; \n        this.v = v; \n        Object.freeze(this)\n    }\n}\n\nconst ViewModelListener = class {\n    viewmodelUpdated(updated){ throw 'override'; }\n}\n\nconst ViewModel = class extends ViewModelListener {\n    static get = data => new ViewModel(data);\n    static #subjects = new Set;\n    static #inited = false;\n    static notify(vm) {\n        this.#subjects.add(vm);\n        if (this.#inited) return\n        this.#inited = true;\n        const f = () => {\n            this.#subjects.forEach(vm => {\n                if (vm.#isUpdated.size) {\n                    vm.notify();\n                    vm.#isUpdated.clear();\n                }\n            })\n            requestAnimationFrame(f);\n        }\n        requestAnimationFrame(f);\n    }\n    static descriptor = (vm, category, k, v) => ({\n        enumerable: true,\n        get: () => v,\n        set(newV) {\n            v = newV;\n            //POINT4.2 defineProperties set정의\n            vm.#isUpdated.add(new ViewModelValue(category, k, v))\n        }\n    })\n\n    static define = (vm, category, obj) => (\n        //POINT4.1 reducing \n        Object.defineProperties(obj,\n            Object.entries(obj).reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {})\n        )\n    )\n\n    subKey = '', parent = null;\n    styles = {}, attributes = {}, properties = {}, events = {};\n    //POINT1: #isUpdated, #listeners\n    #isUpdated = new Set, #listeners = new Set;\n\n    constructor(data, _ = type(data, 'object')) {\n        super();\n        //POTIN4: 중복을 없앴다.\n        Object.entries(data).forEach(([k, v]) => {\n            if ('styles,attributes,properties'.includes(k)) {\n                if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`\n                this[k] = ViewModel.define(this, k, v);\n            } else {\n                Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))\n                if (v instanceof ViewModel) {\n                    v.parent = this;\n                    v.subKey = k;\n                    v.addListener(this);\n                }\n            }\n        })\n        //\n        ViewModel.notify(this);\n        Object.seal(this);\n    }\n\n    viewmodelUpdated(updated){ updated.forEach(v => this.#isUpdated.add(v));}\n    //POINT2: addListener, removeListener method\n    addListener(v, _ = type(v, ViewModelListener)){ this.#listeners.add(v);}\n    removeListener(v, _ = type(v, ViewModelListener)){ this.#listeners.delete(v);}\n    //POINT3: notify method\n    notify(){ this.#listeners.forEach(v => v.viewmodelUpdated(this.#isUpdated));}\n}\n\n```\n* [보완] 숫자 앞에 설명 PREFIX 붙이기\n* 1.subject이기때문에 listener를 거느리고 있어야 notification을 할 수 있다. \n    * 변수 #listener에 listener를 받아서 notification될때 #listener에 nofication을 때려준다!\n* 2.addListener, removeListener method\n    * 변수 #listener에 추가, 제거해주는 method\n* 3.notify method\n    * true, false가 아니라 Set type을 보내주는 이유 \n        - update가 여러번 일어 날 수 있기 때문에 \n* 4.중복을 없앴다\n    * [보완] 전 강의 Binder Code 수정\n    * 참고: [전 강의 Binder Code](https://happyjy.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_2/#binder)\n    * \"\".inclues.(k)\n        - 문자열의 indexof는 자바스크립트에서 특별하게 빠르다. (object에서 key를 찾는 것보다)\n    * defineProperty를 할것이다 왜냐하면 setter를 감시하기 위해서 \n* 4.1.reducing\n    * [reduce mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n    * reducing 설명\n        - reduce두번째 인자는 accumulaotr 초기값을 설정\n        - reduce함수에는 하나의 인자 callback function이 들어와야 합니다. \n        - callback function의 인자 설명\n            * 첫번째 인자: callback's return values(reduce의 두번째 인자로 초기화 가능)\n            * 두번재 인자: Current Value(배열의 요소)\n            * 세번째 인자: Current Index\n            * 네번째 인자: Source Array\n        - 배열 두번째 순회 설명  \n            * 그럼 다음 2번째 배열 인자를 순회 했을때 callback의 첫번째 인자 \"accumulator\"는 reduce 첫번째 요소를 순회 했을때 accumulator의 return 값 callbcak function 의 첫번째 인자(accumulator)가 된다. \n        - 결국 위 코드에서는 r객체가 반환 되겠습니다. \n            * 반된 값은 아래와 같습니다. \n\n            ```js\n            //Object.entries(obj)가 아래와 같은 값을 가질때 반환 값 입니다.\n            //ViewModel의 descriptor method를 참고하면 이해가 될 것입니다.\n            [[\"width\", \"50%\"], [\"background\", \"#ffa\"], [\"cursor\", \"pointer\"]] \n\n            {\n                width: {enumerable: true, get f, set: f ...}\n                background: {enumerable: true, get f, set: f ...}\n                cursor: {enumerable: true, get f, set: f ...}\n            }\n            ```\n    * reduce의 두번째 인자는 초기화 데이터 타입으로, return시 이 type으로 반환된다. \n        - 현재 {} 으로 초기화\n    * Object.entries(obj)는 2차원 배열을 반환\n        ```js\n            [[\"width\", \"50%\"], [\"background\", \"#ffa\"], [\"cursor\", \"pointer\"]] \n        ```\n* POINT4.2 defineProperties set정의\n    - vm(ViewModel instance)에 #isUpdated(Set type)에 뭔가를 추가해주고 싶다. \n    - 뭔가란?\n        * ViewModelValue의 instance!!! 코드 참고 \n        ```js\n            vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v))\n        ```\n    - 이렇게 set에 설정을 하게 되면 이것을 끄집어 낼때 예를 들어 style에 background가 빨간색으로 바뀌었네 라고 알수 있습니다. \n    - 옵저버패턴에서 subject... 지옥이네 🐶빡세네 \n\n## 핵심\n* POINT4.2 defineProperties set정의에 아래 코드와 같이 ViewModeValue instance를 넘겨주고 notification되면 set에 담겨있는 것을 호출하는 메커니즘 이해가 중요합니다. \n    - 호출은 viewModel에 notify method가있고 이 method는 this.#listeners Set 변수 값으로 담겨 있는 것을 viewmodelUpldated로 보내 호출한다. \n    - [보완] 코드를 보고 ViewModel Class에 변수 #listener가 어떤 값이 세팅되는지 확인하자.\n ```js\n    new ViewModelValue(vm.subKey, category, k, v))\n ```\n\n# 3. Composite(ViewModel class 수정)\n> 내가 내 문제를 동일한 문제임에도 불구하고 내가 해결하지 않고 위임을 계속 반복해서 그것들을 취함하는 행동들을 말합니다. \n> 이 부분은 ViewModel class와 관련 있습니다. \n* 대중 계층에 대한 고민이 상항 있다. \n    - 예를 들어 폴더안에 파일 폴더안에 파일\n    - 다중노드가 전개되어 있는 트리를 얼마나 빠르게 화면에 뿌릴 수 있는지 중요!\n* 동적탐색, 트리탐색으로 풀 수 있는데\n    - 속도는 동적탐색이 빠른데 정형화된 알고리즘으로 가면 트리 탐색이 쉽다.  \n\n* 우리에게 Composite 문제가 필요한가? \n    - 우리가 만든 ViewModel 안에 ViewModel이 있었다.(wrapper, title, contents)\n    - 이렇게 viewModel안에 있는 ViewModel이 변화가 일어났을때 자기의 변화는 자기가 구독하고 있는에게는 간다. \n    - 그런데 우리는 구독을 ViewModel에게 걸까? 아니 이 ViewModel을 소유하고 있는 ViewModel에게 건다(sub ViewModel에게 구독을 걸지 않는다.)\n    - 그 이유는 binder는 통 VeiwModel을 알아야지 아이템이 맵핑되어 있는 전체 ViewModel을 매핑 할 수 있기 때문입니다. 그래서 다 감싸고 있는 ViewModel에 구독을 한다. (sub ViewModel에 구독을 하지 않습니다.)\n    - 그러면 우리는 전제 다 감싸고 잇는 ViewModel뿐이 아니라 sub ViewModel에게도 Listener에게 알려야 합니다. sub ViewModel안에 또 sub ViewModel이 있다면 이것도 Lsitener에게 알려 줍니다. 모든걸 다 알려줘야 합니다.    \n    - 이런 문제를 동적탐색, 트리탐색으로 풀지 않고 객체지향에서는 `동적위임`으로 해결한다!!!\n\n\n* Binder Class가 변경된 부분 주석으로 걸어 놓은 POINT1, 2, 3, 4, 5, 5.1 내용 확인\n\n``` js\n/*\n    #index class\n    * ViewModelValue\n    * ViewModelListener\n    * ViewModel\n*/\nconst ViewModelValue = class {\n    //POINT3: subKey\n    subKey; category; k; v;\n    constructor(subKey, category, k, v) {\n        this.subKey = subKey; \n        this.category = category; \n        this.k = k; \n        this.v = v; \n        Object.freeze(this)\n    }\n}\n\nconst ViewModelListener = class {\n    viewmodelUpdated(updated){ throw 'override'; }\n}\n\nconst ViewModel = class extends ViewModelListener {\n    static get = data => new ViewModel(data);\n    static #subjects = new Set;\n    static #inited = false;\n    //POINT5.1 notify: observer에게 통보할 subjects들이 모인 곳\n    // vm.notify는 결국 v.viewmodelUpdated를 통해서 binder의 viewmodelupdated를 통해서 el을 변경한다 !!!\n    static notify(vm) {\n        this.#subjects.add(vm);\n        if (this.#inited) return\n        this.#inited = true;\n        const f = () => {\n            this.#subjects.forEach(vm => {\n                if (vm.#isUpdated.size) {   //업데이트 여부 확인 \n                    vm.notify();            //vm이 가지고 있는 Listener들에게 notify \n                    vm.#isUpdated.clear();  //notify한 것은 제거 해준다. \n                }\n            })\n            requestAnimationFrame(f);\n        }\n        requestAnimationFrame(f);\n    }\n    static descriptor = (vm, category, k, v) => ({\n        enumerable: true,\n        get: () => v,\n        set(newV) {\n            v = newV;\n            //POINT4 vm.subKey 추가: 자식이자 자신입을 알려주기 위해서 \n            vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v))\n        }\n    })\n\n    static define = (vm, category, obj) => (\n        Object.defineProperties(obj,\n            Object.entries(obj).reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {})\n        )\n    )\n\n    subKey = '', parent = null;\n    styles = {}, attributes = {}, properties = {}, events = {};\n    #isUpdated = new Set, #listeners = new Set;\n\n    constructor(data, _ = type(data, 'object')) {\n        super();\n        Object.entries(data).forEach(([k, v]) => {\n            if ('styles,attributes,properties'.includes(k)) {\n                if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`\n                this[k] = ViewModel.define(this, k, v);\n            } else {\n                //POINT1: el의 wrapper, title, contents\n                Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))\n                if (v instanceof ViewModel) {\n                    //부모자식 개념이 생겼다. \n                    v.parent = this;      //부모\n                    v.subKey = k;         //subKey가 누구 소속일때 할당(부모를 알게 된다), 없는건 root\n                    v.addListener(this);  //자식의 Listener가 되는 코드\b(자식이 변화 했을때 변화를 알아차려 나의 일부의 변화로 포함 시킬 수 있다. )\n                }\n                //\n            }\n        })\n        //POINT5: ViewModel.notify\n        ViewModel.notify(this); //ViewModel이 새로 만들어졌을때 변경됐다고 알려준다.(ViewModel기준으로 ViewModel이 바뀌면 한번만)\n        Object.seal(this);\n    }\n\n    //POINT2: viewmodelUpdated\n    viewmodelUpdated(updated){ updated.forEach(v => this.#isUpdated.add(v));}\n    addListener(v, _ = type(v, ViewModelListener)){ this.#listeners.add(v);}\n    removeListener(v, _ = type(v, ViewModelListener)){ this.#listeners.delete(v);}\n    notify(){ this.#listeners.forEach(v => v.viewmodelUpdated(this.#isUpdated));}\n}\n\n```  \n> 중요: Observer pattenr은 보통 Composite 같이 일어나는데 concept은 이해가 되지만 코드와 연관 지어서 고민해볼 필요가 있습니다.\n* POINT1 el의 wrapper, title, contents가 들어오는 케이스\n    - 이것의 변화도 위로 보고 해야한다.( ViewModel의 옵저버가 되야 한다.) 그래야 얘를 수신 할 수 있다. \n    - subject일 경우 그의 자식인 viewModel에게는 옵저버가 되어야 한다.(변화를 수신해야 변화를 외부에 통보할 수 있다.)  \n    - subject이면서 동시에 viewModel에 옵저버이기도 합니다. 그래서 내가 viewModel이 아니면 전파가 끝남\n* [보완] - 분석\n    - ViewModel Class의 notify부분 분석 필요(subject의 기능이 들었다.)\n        * this.#subjects가 어떤 값이 있을지 확인해보자.\n    - ViewModel Class Constructor의 ViewModel.notify에서 v에 따라서 VeiwModel의 viewmodelUpdated, binder의 viewModelUpdated가 호출 된다. 어떤 경우인지 확인필요(확인하면서 concept정리)\n\n\n\n# 4. Observer(Binder Class 수정)\n* Binder가 실제로 ViewModel을 구독역할(Observer)을한다. \n* Binder Class가 변경된 부분 주석으로 걸어 놓은 POINT1, 2 내용 확인\n```js\n    const Binder = class extends ViewModelListener {\n        #items = new Set;\n        #processors = {};\n\n        //POINT2: 공포의 Listener를 구현\n        viewmodelUpdated(updated) {\n            const items = {};\n            this.#items.forEach(({ vmName, el }) => {\n                items[vmName] = [type(rootViewModel[vmName], ViewModel), el];\n            });\n            updated.forEach(({ subKey, category, k, v }) => {\n                if (!items[subKey]) return;\n                const [vm, el] = items[subKey], processor = this.#processors[category];\n                if (!el || !processor) return;\n                processor.process(vm, el, k, v);\n            })\n        }\n\n        add(v, _ = type(v, BinderItem)) { this.#items.add(v); }\n        addProcessor(v, _ = type(v, Processor)) { this.#processors[v.category] = v; }\n        render(viewmodel, _ = type(viewmodel, ViewModel)) {\n            const processores = Object.entries(this.#processors)\n            this.#items.forEach(({ vmName,el }) => {\n                const vm = type(viewmodel[vmName], ViewModel);\n                processores.forEach(([pk, processor]) => {\n                    Object.entries(vm[pk]).forEach(([k, v]) => {\n                        processor.process(vm, el, k, v)\n                    })\n                })\n            })\n        }\n        //POINT1: 특정 ViewModel에 listener에 등록되고 말고를 결정한다. \n        watch(viewmodel, _ = type(viewmodel, ViewModel)) {\n            viewmodel.addListener(this);\n            this.render(viewmodel);\n        }\n        unwatch(viewmodel, _ = type(viewmodel, ViewModel)) {\n            viewmodel.removeListener(this);\n        }\n\n    }\n```\n* [보완] - 분석\n    - viewmodelUpdated method breakpoint걸어 확인해보기\n\n\n\n# 5. Client\n```js\nconst Scanner = class {\n    scan(el, _ = type(el, HTMLElement)) {\n        const binder = new Binder();\n        this.checkItem(binder, el);\n        const stack = [el.firstElementChild];\n        let target;\n        while (target = stack.pop()) {\n            this.checkItem(binder, target);\n            if (target.firstElementChild) stack.push(target.firstElementChild);\n            if (target.nextElementSibling) stack.push(target.nextElementSibling);\n        }\n        return binder;\n    }\n    checkItem(binder, el) {\n        const vmName = el.getAttribute('data-viewmodel');\n        if (vmName) binder.add(new BinderItem(el, vmName));\n    }\n}\n\nconst scanner = new Scanner();\nconst binder = scanner.scan(document.querySelector('#target'));\nbinder.addProcessor(new class extends Processor {\n    _process(vm, el, k, v) { el.style[k] = v; }\n}('styles'))\nbinder.addProcessor(new class extends Processor {\n    _process(vm, el, k, v) { el.setAttribute(k, v); }\n}('attributes'))\nbinder.addProcessor(new class extends Processor {\n    _process(vm, el, k, v) { el[k] = v; }\n}('properties'))\nbinder.addProcessor(new class extends Processor {\n    _process(vm, el, k, v) { el[`on${k}`] = e => v.call(el, e, vm); }\n}('events'))\n\nconst getRandom = () => parseInt(Math.random() * 150) + 100\nconst wrapper = ViewModel.get({\n    styles: {\n        width: '50%',\n        background: '#ffa',\n        cursor: 'pointer'\n    },\n    events: {\n        click(e, vm) {\n            vm.parent.isStop = true\n        }\n    }\n})\nconst title = ViewModel.get({\n    properties: {\n        innerHTML: 'Title'\n    }\n})\nconst contents = ViewModel.get({\n    properties: {\n        innerHTML: 'Contents'\n    }\n})\nconst rootViewModel = ViewModel.get({\n    isStop: false,\n    changeContents() {\n        this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`\n        this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '')\n    },\n    wrapper,\n    title,\n    contents\n})\nbinder.watch(rootViewModel)\nconst f = () => {\n    rootViewModel.changeContents()\n    if (!rootViewModel.isStop) requestAnimationFrame(f)\n}\nrequestAnimationFrame(f)\n```\n\n\n\n\n\n# 6. 전체코드\n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>MVVM</title>\n</head>\n\n<body>\n    <section id=\"target\" data-viewmodel=\"wrapper\">\n        <h2 data-viewmodel=\"title\"></h2>\n        <section data-viewmodel=\"contents\"></section>\n    </section>\n    <script>\n        const type = (target, type) => {\n            if (typeof type == \"string\") {\n                if (typeof target != type) throw `invalid type ${target} : ${type}`;\n            } else if (!(target instanceof type)) {\n                throw `invalid type ${target} : ${type}`;\n            }\n            return target;\n        }\n\n        const ViewModelListener = class {\n            viewmodelUpdated(updated) {\n                throw 'override';\n            }\n        }\n\n        const ViewModel = class extends ViewModelListener {\n            static get = data => new ViewModel(data);\n            static #subjects = new Set;\n            static #inited = false;\n            static notify(vm) {\n                this.#subjects.add(vm);\n                if (this.#inited) return\n                this.#inited = true;\n                const f = () => {\n                    this.#subjects.forEach(vm => {\n                        if (vm.#isUpdated.size) {\n                            vm.notify();\n                            vm.#isUpdated.clear();\n                        }\n                    })\n                    requestAnimationFrame(f);\n                }\n                requestAnimationFrame(f);\n            }\n            static descriptor = (vm, category, k, v) => ({\n                enumerable: true,\n                get: () => v,\n                set(newV) {\n                    v = newV;\n                    vm.#isUpdated.add(new ViewModelValue(vm.subKey, category, k, v))\n                }\n            })\n\n            static define = (vm, category, obj) => (\n                Object.defineProperties(\n                    obj,\n                    Object.entries(obj)\n                    .reduce((r, [k, v]) => (r[k] = ViewModel.descriptor(vm, category, k, v), r), {})\n                )\n            )\n\n            subKey = ''; parent = null;\n            styles = {}; attributes = {}; properties = {}; events = {};\n            #isUpdated = new Set; #listeners = new Set;\n\n            constructor(data, _ = type(data, 'object')) {\n                super();\n                Object.entries(data).forEach(([k, v]) => {\n                    if ('styles,attributes,properties'.includes(k)) {\n                        if (!v || typeof v != 'object') throw `invalid object k: ${k}, v:${v}`\n                        this[k] = ViewModel.define(this, k, v);\n                    } else {\n                        Object.defineProperty(this, k, ViewModel.descriptor(this, '', k, v))\n                        if (v instanceof ViewModel) {\n                            v.parent = this;\n                            v.subKey = k;\n                            v.addListener(this);\n                        }\n                    }\n                })\n                ViewModel.notify(this);\n                Object.seal(this);\n            }\n\n            viewmodelUpdated(updated) {\n                updated.forEach(v => this.#isUpdated.add(v));\n            }\n            addListener(v, _ = type(v, ViewModelListener)) {\n                this.#listeners.add(v);\n            }\n            removeListener(v, _ = type(v, ViewModelListener)) {\n                this.#listeners.delete(v);\n            }\n            notify() {\n                this.#listeners.forEach(v => v.viewmodelUpdated(this.#isUpdated));\n            }\n        }\n\n        const ViewModelValue = class {\n            subKey; category; k; v;\n            constructor(subKey, category, k, v) {\n                this.subKey = subKey; \n                this.category = category; \n                this.k = k; \n                this.v = v; \n                Object.freeze(this)\n            }\n        }\n\n        const BinderItem = class {\n            el;\n            vmName;\n            constructor(el, vmName, _0 = type(el, HTMLElement), _1 = type(vmName, 'string')) {\n                this.el = el;\n                this.vmName = vmName;\n                Object.freeze(this);\n            }\n        }\n\n        const Binder = class extends ViewModelListener {\n            #items = new Set;\n            #processors = {};\n            viewmodelUpdated(updated) {\n                const items = {};\n                this.#items.forEach(({ vmName, el }) => {\n                    items[vmName] = [type(rootViewModel[vmName], ViewModel), el];\n                });\n                updated.forEach(({ subKey, category, k, v }) => {\n                    if (!items[subKey]) return;\n                    const [vm, el] = items[subKey], processor = this.#processors[category];\n                    if (!el || !processor) return;\n                    processor.process(vm, el, k, v);\n                })\n            }\n\n            add(v, _ = type(v, BinderItem)) { this.#items.add(v); }\n            addProcessor(v, _ = type(v, Processor)) { this.#processors[v.category] = v; }\n            render(viewmodel, _ = type(viewmodel, ViewModel)) {\n                const processores = Object.entries(this.#processors)\n                this.#items.forEach(({ vmName,el }) => {\n                    const vm = type(viewmodel[vmName], ViewModel);\n                    processores.forEach(([pk, processor]) => {\n                        Object.entries(vm[pk]).forEach(([k, v]) => {\n                            processor.process(vm, el, k, v)\n                        })\n                    })\n                })\n            }\n            watch(viewmodel, _ = type(viewmodel, ViewModel)) {\n                viewmodel.addListener(this);\n                this.render(viewmodel);\n            }\n            unwatch(viewmodel, _ = type(viewmodel, ViewModel)) {\n                viewmodel.removeListener(this);\n            }\n        }\n\n        const Processor = class {\n            category;\n            constructor(category) {\n                this.category = category;\n                Object.freeze(this);\n            }\n            process(vm, el, k, v, _0 = type(vm, ViewModel),\n                                    _1 = type(el, HTMLElement),\n                                    _2 = type(k, \"string\")) {\n                this._process(vm, el, k, v);\n            }\n            _process(vm, el, k, v) { throw 'override'; }\n        }\n\n        const Scanner = class {\n            scan(el, _ = type(el, HTMLElement)) {\n                const binder = new Binder();\n                this.checkItem(binder, el);\n                const stack = [el.firstElementChild];\n                let target;\n                while (target = stack.pop()) {\n                    this.checkItem(binder, target);\n                    if (target.firstElementChild) stack.push(target.firstElementChild);\n                    if (target.nextElementSibling) stack.push(target.nextElementSibling);\n                }\n                return binder;\n            }\n            checkItem(binder, el) {\n                const vmName = el.getAttribute('data-viewmodel');\n                if (vmName) binder.add(new BinderItem(el, vmName));\n            }\n        }\n\n        const scanner = new Scanner();\n        const binder = scanner.scan(document.querySelector('#target'));\n        binder.addProcessor(new class extends Processor {\n            _process(vm, el, k, v) { el.style[k] = v; }\n        }('styles'))\n        binder.addProcessor(new class extends Processor {\n            _process(vm, el, k, v) { el.setAttribute(k, v); }\n        }('attributes'))\n        binder.addProcessor(new class extends Processor {\n            _process(vm, el, k, v) { el[k] = v; }\n        }('properties'))\n        binder.addProcessor(new class extends Processor {\n            _process(vm, el, k, v) { el[`on${k}`] = e => v.call(el, e, vm); }\n        }('events'))\n\n        const getRandom = () => parseInt(Math.random() * 150) + 100\n        const wrapper = ViewModel.get({\n            styles: {\n                width: '50%',\n                background: '#ffa',\n                cursor: 'pointer'\n            },\n            events: {\n                click(e, vm) {\n                    vm.parent.isStop = true\n                }\n            }\n        })\n        const title = ViewModel.get({\n            properties: {\n                innerHTML: 'Title'\n            }\n        })\n        const contents = ViewModel.get({\n            properties: {\n                innerHTML: 'Contents'\n            }\n        })\n        const rootViewModel = ViewModel.get({\n            isStop: false,\n            changeContents() {\n                this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`\n                this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '')\n            },\n            wrapper,\n            title,\n            contents\n        })\n        binder.watch(rootViewModel)\n        const f = () => {\n            rootViewModel.changeContents()\n            if (!rootViewModel.isStop) requestAnimationFrame(f)\n        }\n        requestAnimationFrame(f)\n    </script>\n</body>\n\n</html>\n```\n\n\n**강의 들으면 [보완]이라고 한 것들 찾아서 스터디해서 채워 넣기**\n","excerpt":"목표 전략적 패턴 적용 기존 Binder 클래스가 코드로 확정 되어 있다. 이 부분을 전략적으로 빼내는 방법을 살펴본다.  call -> Observation Binder, ViewModel 통신을 이전 강의 까지 call…","fields":{"slug":"/OOPWithJavascript_3/"},"frontmatter":{"date":"Mar 07, 2020","title":"객체지향 자바스크립트 3회차(MVVM pattern 개선)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n\n# 1장 자바스크립트에 익숙해지기\n* 아이템 1 어떤 자바스크립트를 사용하고 있는지 알아야 한다  \n* 아이템 2 자바스크립트의 부동 소수점 숫자 이해하기  \n* 아이템 3 암묵적인 형변환을 주의하라  \n* 아이템 4 객체 래퍼보다 원시 데이터형을 우선시하라  \n* 아이템 5 혼합된 데이터형을 ==로 비교하지 마라  \n* 아이템 6 세미콜론 삽입의 한계에 대해서 알아두자  \n* 아이템 7 문자열을 16비트 코드 단위의 시퀀스로 간주하라  \n\n# 2장 변수 스코프\n* 아이템 8 전역 객체의 사용을 최소화하라  \n* 아이템 9 항상 지역 변수를 선언하라  \n* 아이템 10 with를 사용하지 마라  \n* 아이템 11 클로저에 익숙해져라  \n* 아이템 12 변수 호이스팅에 대해 이해하라  \n* 아이템 13 지역 변수 스코프를 만들기 위해 즉시 실행 함수 표현식을 사용하라  \n* 아이템 14 기명 함수 표현식의 스코프에 주의하라  \n* 아이템 15 블록-지역 함수 선언문의 스코프에 주의하라  \n* 아이템 16 eval을 이용해 지역 변수를 생성하지 마라  \n* 아이템 17 직접적인 eval보다 간접적인 eval을 사용하라  \n\n# 3장 함수 사용하기\n* 아이템 19 함수, 메서드, 생성자 호출의 차이를 이해하라  \n* 아이템 20 고차 함수에 익숙해져라  \n* 아이템 21 지정된 수신자 객체로 함수를 호출하기 위해 call 메서드를 사용하라  \n* 아이템 22 다른 개수의 인자로 함수를 호출하기 위해 apply를 사용하라  \n* 아이템 23 가변 인자 함수를 생성하기 위해 arguments를 사용하라  \n* 아이템 24 절대 arguments 객체를 수정하지 마라  \n* 아이템 25 자바스크립트의 부동 소수점 숫자 이해하기  \n* 아이템 26 고정된 수신자 객체로 메서드를 추출하기 위해 bind를 사용하라  \n* 아이템 27 커링 함수에 bind를 사용하라  \n* 아이템 28 코드를 캡슐화하기 위해 문자열보다 클로저를 사용하라  \n* 아이템 29 함수의 toString 메서드에 의존하지 마라  \n* 아이템 30 비표준 스택 검사 프로퍼티를 사용하지 마라  \n\n# 4장 객체와 프로토타입\n* 아이템 31 * proto* 보다 Object.getPrototypeOf를 사용하라  \n* 아이템 32 * proto* 를 절대 수정하지 마라  \n* 아이템 33 생성자가 new와 관계 없이 동작하게 만들어라  \n* 아이템 34 메서드를 프로토타입에 저장하라  \n* 아이템 35 비공개 데이터를 저장하기 위해 클로저를 사용하라  \n* 아이템 36 인스턴스의 상태는 인스턴스 객체에만 저장하라  \n* 아이템 37 this의 명시적인 바인딩에 대해 이해하라  \n* 아이템 38 서브 클래스 생성자에서 수퍼 클래스 생성자를 호출하라  \n* 아이템 39 수퍼 클래스 프로퍼티 이름을 절대 재사용하지 마라  \n* 아이템 40 표준 클래스를 상속하지 마라  \n* 아이템 41 프로토타입을 세부 구현 사항처럼 처리하라  \n* 아이템 42 무모한 몽키 패칭을 하지 마라  \n\n# 5장 배열과 딕셔너리\n* 아이템 43 직접적인 객체의 인스턴스로 가벼운 딕셔너리를 만들어라  \n* 아이템 44 프로토타입 오염을 막기 위해 null 프로토타입을 사용하라  \n* 아이템 45 프로토타입 오염을 막기 위해 asOwnProperty를 사용하라  \n* 아이템 46 순서가 정해진 컬렉션에는 딕셔너리 대신 배열을 사용하라  \n* 아이템 47 Object.prototype에 열거 가능한 프로퍼티를 절대 추가하지 마라  \n* 아이템 48 열거하는 동안 객체를 수정하지 마라  \n* 아이템 49 배열을 반복할 때 for...in 대신 for 반복문을 사용하라  \n* 아이템 50 반복문 대신 반복 메서드를 사용하라  \n* 아이템 51 유사 배열 객체에 범용적인 배열 메서드를 재사용하라  \n* 아이템 52 Array 생성자 대신 배열 리터럴을 사용하라  \n\n# 6장 라이브러리와 API 설계\n* 아이템 53 일관된 컨벤션을 유지하라  \n* 아이템 54 undefined를 ‘값 이 없는’ 것처럼 처리하라  \n* 아이템 55 키워드 인자를 위해 옵션 객체를 받아들여라  \n* 아이템 56 불필요한 상태 유지를 피하라  \n* 아이템 57 유연한 인터페  \n","excerpt":"1장 자바스크립트에 익숙해지기 아이템 1 어떤 자바스크립트를 사용하고 있는지 알아야 한다   아이템 2 자바스크립트의 부동 소수점 숫자 이해하기   아이템 3 암묵적인 형변환을 주의하라   아이템…","fields":{"slug":"/20200306-EffectiveJS/"},"frontmatter":{"date":"Mar 06, 2020","title":"Effective Javascript","tags":["Javascript"]}}},{"node":{"rawMarkdownBody":"\n2015년 11월 SI회사에 입사하고 나서 2년반 동안 회사업무에만 집중했다. \n공부할 생각은 있었지만 평일에는 야근으로 늦은 퇴근, 주말에는 배드민턴에 빠져서 살았다.(레슨/대회에 참여할정도록 푹빠졋다.) \n\n그렇게 시간을 보내면서 계기가 있었다. 회사 독서 동아리로 매달 하나씩 책을 사서 보는데 2018년 3월쯤 신영준, 고영성 작가님의 `완벽한 공부법` 책을 알게 되고 `꾸준하게` 공부해서 `실력`이 있어야 한다는 깨달음을 얻었다. 회사 특성상 `지방 파견`을 지속적으로 다녀야 하는데 그 동안 파견생활 경험으로 지쳐있던 나는 그동안 하지 않았던 개발공부를 시작했다.  \n\n2018년 여름 8주 동안 캐스트 캠퍼스에서 vue 수강을 시작으로 \n2018년 12월 이직했고 \n\n2019년 instagram clone coding1, instagram clone coding2, Javascript core정리\n\n2020년 코드스피츠의 자바스크립트 객체지향을 통해서 MVVM 구현을 통해서 디자인패턴을 학습하고 있다. \n\n앞으로도 typescript, 디자인패턴, 설계, css, animation, 웹 표준, 성능, 보안, git, 백앤드학습으로 개인 개인블로그부터 시작해 product level 웹 서비스 만들어보기등 지속적으로 공부하며 블로그(글쓰기)를 통해서 스스로 동기부여를 하면서 새로운것도 익히는 경험으로 문제 해결능력이 뛰어난 개발자가 되고 싶다.","excerpt":"2015년 11월 SI회사에 입사하고 나서…","fields":{"slug":"/개발공부와블로그를시작하게된계기/"},"frontmatter":{"date":"Mar 01, 2020","title":"개발 공부와 블로그를 시작하게 된 계기","tags":["생각정리"]}}},{"node":{"rawMarkdownBody":"\n\njavascript Core를 정리하겠다고 마음먹고 제일 먼저 작성한 목록 입니다.\n뭘 정리해 할지 한눈에 보기 편해 정리하는데 확실한 동기부여가 됐습니다.\n\n\n![JavascriptRoadMap](JavascriptRoadMap.png)\n\n# index\n[실행컨텍스트](https://happyjy.github.io/Excute-context/)  \n[this](https://happyjy.github.io/this/)  \n[callback function](https://happyjy.github.io/callback/)  \n[call(), apply(), bind()](https://happyjy.github.io/call(),%20apply(),%20bind()/)  \n[closure](https://happyjy.github.io/closure/)  \n[prototype](https://happyjy.github.io/prototype/)  \n[class](https://happyjy.github.io/class/)  \n[Promise chaning](http://happyjy.github.io/3_Promise%20chaning/)  \n[Promise](https://happyjy.github.io/2_Promise/)  \n[callback](https://happyjy.github.io/1_callback/)  \n[eventLoop](https://happyjy.github.io/eventLoop/)\n\n- 참고  \n코어 자바스크립트 - 위키북스","excerpt":"javascript Core를 정리하겠다고 마음먹고 제일 먼저 작성한 목록 입니다.\n뭘 정리해 할지 한눈에 보기 편해 정리하는데 확실한 동기부여가 됐습니다.  index 실행컨텍스트 this callback function call(), apply…","fields":{"slug":"/JavascriptRoadMap/"},"frontmatter":{"date":"Mar 01, 2020","title":"Javascript RoadMap","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n\nES에서는 \n\n# var 키워드로 선언된 변수의 특징 4가지 \n1. 함수 레벨 스코프(Function-level scope)\n    - *함수의 코드 블록만을 스코프로 인정*   \n        -> *전역 함수 외부에서 생성한 변수*는 모두 전역변수(전역변수 남발 가능성 높음)\n    - for문의 변수 선언한 변수를 for문의 코드 블록 외부에서 참조 가능 \n2. var 키워드 생략 허용\n    - 암묵적 전역변수 양산 가능\n3. 변수 중복 선언 허용\n    - 변수값 변경이 일어날 가능성 \n4. 변수 호이스팅\n    - 변수 선언전에 참조 가능\n\n\n# let, const 키워드를 도입 이유 3가지\n1. 전역변수로 인해 문제가 많이 발생됨\n2. 전역변수는 간단한 애플리케이션의 경우 사용이 편리한 장점이 있지만 불가피한 상황을 제외하고 사용을 억제\n3.  전역변수는 scope넓어서 어디에서, 어떻게 사용될 것인지 파악하기 힘들며, 비순수 함수에 의해서 변경될 수 있어 복잡성을 증가 시키는 원인이 된다. (변수의 스코프는 좁을수록 좋다.)\n\n\n\n# let\n\n## 1.1 블록 레벨 스코프\n\n대부분의 프로그래밍 언어는 블록 레벨 스코프(Block-level scope)를 따르지만 자바스크립트는 함수 레벨 스코프(Function-level scope)를 따른다.\n\n* 함수 레벨 스코프(Function-level scope)\n함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.\n* 블록 레벨 스코프(Block-level scope)\n모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.\n\n\n* var 예시\n```js\n\nvar foo = 123; // 전역 변수\n\nconsole.log(foo); // 123\n\n{\n  var foo = 456; // 전역 변수\n}\n\nconsole.log(foo); // 456\n\n```\n\n\n* let 예시\n```js\nlet foo = 123; // 전역 변수\n\n{\n  let foo = 456; // 지역 변수\n  let bar = 456; // 지역 변수\n}\n\nconsole.log(foo); // 123\nconsole.log(bar); // ReferenceError: bar is not defined\n```\n\n\n\n## 1.2 변수 중복 선언 금지\n\n```js\n\nvar foo = 123;\nvar foo = 456;  // 중복 선언 허용\n\nlet bar = 123;\nlet bar = 456;  // Uncaught SyntaxError: Identifier 'bar' has already been declared\n\n```\n\n## 1.3 호이스팅\n자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅한다. 호이스팅(Hoisting)이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다.\n\n하지만 var 키워드로 선언된 변수와는 달리 let 키워드로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다. 이는 let 키워드로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다.\n\n```js\nconsole.log(foo); // undefined\nvar foo;\n\nconsole.log(bar); // Error: Uncaught ReferenceError: bar is not defined\nlet bar;\n```\n변수가 어떻게 생성되며 호이스팅은 어떻게 이루어지는지 좀 더 자세히 살펴보자. 변수는 3단계에 걸쳐 생성된다. 자세한 내용은 Execution Context을 참조하기 바란다.\n\n선언 단계(Declaration phase)\n변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 **스코프가 참조**하는 대상이 된다.\n초기화 단계(Initialization phase)\n변수 객체(Variable Object)에 등록된 변수를 위한 공간을 **메모리에 확보**한다. 이 단계에서 변수는 **undefined로 초기화된다.**\n할당 단계(Assignment phase)\nundefined로 초기화된 변수에 **실제 값을 할당**한다.\n\nvar 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉, <u>스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화(초기화 단계)한다.</u> 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라 한다.\n\n\n```js\n// 스코프의 선두에서 선언 단계와 초기화 단계가 실행된다.\n// 따라서 변수 선언문 이전에 변수를 참조할 수 있다.\nconsole.log(foo); // undefined\n\nvar foo;\nconsole.log(foo); // undefined\n\nfoo = 1; // 할당문에서 할당 단계가 실행된다.\nconsole.log(foo); // 1\n```\n\n\nvar lifecycle\n\nvar 키워드로 선언된 변수의 생명 주기\n\n<u>let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.</u> 즉, 스코프에 변수를 등록(선언단계)하지만 초기화 단계는 변수 선언문에 도달했을 때 이루어진다. 초기화 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다. 이는 변수가 아직 초기화되지 않았기 때문이다. 다시 말하면 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 ‘일시적 사각지대(Temporal Dead Zone; TDZ)’라고 부른다.\n\n\n```js\n// 스코프의 선두에서 선언 단계가 실행된다.\n// 아직 변수가 초기화(메모리 공간 확보와 undefined로 초기화)되지 않았다.\n// 따라서 변수 선언문 이전에 변수를 참조할 수 없다.\nconsole.log(foo); // ReferenceError: foo is not defined\n\nlet foo; // 변수 선언문에서 초기화 단계가 실행된다.\nconsole.log(foo); // undefined\n\nfoo = 1; // 할당문에서 할당 단계가 실행된다.\nconsole.log(foo); // 1\nlet lifecycle\n\nlet 키워드로 선언된 변수의 생명 주기\n\n결국 ES6에서는 호이스팅이 발생하지 않는 것과 차이가 없어 보인다. 하지만 그렇지 않다. 아래 예제를 살펴보자.\n\nlet foo = 1; // 전역 변수\n\n{\n  console.log(foo); // ReferenceError: foo is not defined\n  let foo = 2; // 지역 변수\n}\n\n```\n위 예제의 경우, 전역 변수 foo의 값이 출력될 것처럼 보인다. 하지만 ES6의 선언문도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다.\n\nES6의 let으로 선언된 변수는 블록 레벨 스코프를 가지므로 코드 블록 내에서 선언된 변수 foo는 지역 변수이다. 따라서 지역 변수 foo도 해당 스코프에서 호이스팅되고 코드 블록의 선두부터 초기화가 이루어지는 지점까지 일시적 사각지대(TDZ)에 빠진다. 따라서 전역 변수 foo의 값이 출력되지 않고 참조 에러(ReferenceError)가 발생한다.\n\n\n## 1.4 클로저\nvar funcs = [];\n\n```js\n// 함수의 배열을 생성하는 for 루프의 i는 전역 변수다.\nfor (var i = 0; i < 3; i++) {\n  funcs.push(function () { console.log(i); });\n}\n\n// 배열에서 함수를 꺼내어 호출한다.\nfor (var j = 0; j < 3; j++) {\n  funcs[j]();\n}\n```\n위 코드의 실행 결과로 0, 1, 2를 기대할 수도 있지만 결과는 3이 세 번 출력된다. 그 이유는 for 루프의 var i가 전역 변수이기 때문이다. 0, 1, 2를 출력하려면 아래와 같은 코드가 필요하다.\n\n\n\n```js\n\nvar funcs = [];\n\n// 함수의 배열을 생성하는 for 루프의 i는 전역 변수다.\nfor (var i = 0; i < 3; i++) {\n  (function (index) { // index는 자유변수다.\n    funcs.push(function () { console.log(index); });\n  }(i));\n}\n\n// 배열에서 함수를 꺼내어 호출한다\nfor (var j = 0; j < 3; j++) {\n  funcs[j]();\n}\n```\n자바스크립트의 함수 레벨 스코프로 인하여 for 루프의 초기화 식에 사용된 변수가 전역 스코프를 갖게 되어 발생하는 문제를 회피하기 위해 클로저를 활용한 방법이다.\n\nES6의 let 키워드를 for 루프의 초기화 식에 사용하면 클로저를 사용하지 않아도 위 코드와 동일한 동작을 한다.\n\n\n```js\n\nvar funcs = [];\n\n// 함수의 배열을 생성하는 for 루프의 i는 for 루프의 코드 블록에서만 유효한 지역 변수이면서 자유 변수이다.\nfor (let i = 0; i < 3; i++) {\n  funcs.push(function () { console.log(i); });\n}\n\n// 배열에서 함수를 꺼내어 호출한다\nfor (var j = 0; j < 3; j++) {\n  console.dir(funcs[j]);\n  funcs[j]();\n}\n\n```\nfor 루프의 let i는 for loop에서만 유효한 지역 변수이다. 또한, i는 자유 변수로서 for 루프의 생명주기가 종료되어도 변수 i를 참조하는 함수가 존재하는 한 계속 유지된다.\n\n## 1.5 전역 객체와 let\n\n\n\n\nlet 키워드로 선언된 변수를 전역 변수로 사용하는 경우, let 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.\n\n```js\n\nvar foo = 123; // 전역변수\n\nconsole.log(window.foo); // 123\n\n\n```\n\nlet 키워드로 선언된 변수를 전역 변수로 사용하는 경우, let 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.\n\n```js\nlet foo = 123; // 전역변수\n\nconsole.log(window.foo); // undefined\n\n```\n\n\n\n\n# 2. cosnt\n\n## 2.1 선언과 초기화\n* let은 재할당이 자유로우나 const는 재할당이 금지된다.\n* 주의할 점은 const는 반드시 선언과 동시에 할당이 이루어져야 한다는 것이다. 그렇지 않으면 다음처럼 문법 에러(SyntaxError)가 발생한다.\n* 또한, const는 let과 마찬가지로 블록 레벨 스코프를 갖는다.\n\n\n\n\n## 2.2 상수\n* 이밍이 적절한 상수로 선언하면 가독성과 유지보수성이 대폭 향상된다. const는 객체에도 사용할 수 있다. 물론 이때도 재할당은 금지된다.\n\n## 2.3 const와 객체\n* const는 재할당이 금지된다. 이는 const 변수의 타입이 객체인 경우, 객체에 대한 참조를 변경하지 못한다는 것을 의미한다. 하지만 이때 객체의 프로퍼티는 보호되지 않는다. 다시 말하자면 재할당은 불가능하지만 할당된 객체의 내용(프로퍼티의 추가, 삭제, 프로퍼티 값의 변경)은 변경할 수 있다.\n\n```js\nconst user = { name: 'Lee' };\n\n// const 변수는 재할당이 금지된다.\n// user = {}; // TypeError: Assignment to constant variable.\n\n// 객체의 내용은 변경할 수 있다.\nuser.name = 'Kim';\n\nconsole.log(user); // { name: 'Kim' }\n\n```\n\n# 3. var vs let vs const 비교 \n\n변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다.\n\nvar와 let, 그리고 const는 다음처럼 사용하는 것을 추천한다.\n\n* ES6를 사용한다면 var 키워드는 사용하지 않는다.\n* 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.\n* 변경이 발생하지 않는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 보다 안전하다.\n\n변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당을 하는 경우가 드물다. 따라서 변수를 선언할 때에는 일단 const 키워드를 사용하도록 하자. 반드시 재할당이 필요하다면(반드시 재할당이 필요한지 한번 생각해 볼 일이다.) 그때 const를 let 키워드로 변경해도 결코 늦지 않는다.\n\n\n\n","excerpt":"ES에서는  var 키워드로 선언된 변수의 특징 4가지 함수 레벨 스코프(Function-level scope) 함수의 코드 블록만을 스코프로 인정 -> 전역 함수 외부에서 생성한 변수는 모두 전역변수(전역변수 남발 가능성 높음) for…","fields":{"slug":"/let,Const/"},"frontmatter":{"date":"Mar 01, 2020","title":"Javascript RoadMap","tags":["Javascript","ES6"]}}},{"node":{"rawMarkdownBody":"\n# 목표 \n객체지향을 가지고 이것 저것 만들어 볼 예정인데 그중 `MVVM`을 을 만들어 본다. 그리고 다음시간에는 이것을 가지고 서비스를 만들어 볼 예정입니다. \n\n# MVVM\n* Model, View, ViewModel의 약자 \n* MS의 pwf에 적용 되어 있는 아키텍쳐(ms가 원조)\n* 핵심적인 내용 몇가지 차용 간단한 모델 만들고 객체지향으로 만들어 볼예정\n\n\n# MVC\n* Model View Controller\n* 두가지가 있다. \n\n## MVC 첫번째 \n\n![](./2회/MVC1.png) \n\n### Back-end에서의 MVC\n* Model을 Controller가 가져와 View가 소비할 수 있는 데이터를 가공해서 View한테 준다. \n* Controller는 Model도 알고 있고 View도 알고 있다\n* Controller가 Model 의해서 받은 데이터를 적절히 가지고 가공해서 뒤로 넘겨 주면 주는 그 받은 데이터를 가지고 화면을 그립니다. \n\n### Front-end에서의 MVC\n* View는 User의 interaction 받아들어 Model을 갱신한다.\n    - View는 User의 interaction 받아드리고 그에 따라서 Model을 갱신한다.\n    - View는 어떤 Model을 갱신 시켜야 되는지 Model에대한 의존성을 알고 있다.\n\n* 그런데 View가 Model과 의존성이 있는데 문제가 있다?! \n    - Model과 View가 바뀌는 원인은 다름\n        * Model은 비즈니스가 변경이 바뀌었을때 달라지고 \n        * View는 웹에서 User 인터랙션이 변경이 되었을 때 바뀐다.\n    - **클라이언트에서는 Model과 View가 바뀌는 원인은 다른데 서로 의존성이 있다는 것이 문제다**\n    \n### 결론\n* MVC는 주로 백엔드에서 서버에서 사용\n    - 대표적으로 스프링\n    - 이유\n        * **Model을 Controller에 넘기고 데이터를 가공해서 주는 View를 만들고 response로 던져버리면 끝난다.** 그 다음에 View가 Model을 참고해서 변경시키는 그런 과정이 없기 때문이다.\n        * **서버에서는 View와 Model을 연결짓는 의존성이 없다**. Model -> Controller -> View 이렇게 단방향으로 처리하기 때문에 서버에서는 MVC 패턴이 괜찮다.\n\n* 클라이언트에서는 MVC 패턴을 사용하기 어렵다 \n    - **View에서 인터랙션이 일어나면 Model을 바꾸는 경우가 있어 너무 밀접한 관계를 가지고 있어 이것이 문제다.** \n* 클라이언트 쪽에서는 MVC 패턴을 잘 사용하지 않는데 MVC 패턴을 사용한 백본은 망했다\n\n## MVC 두번째 \n![](./2회/MVC2.png)\n* 제왕적 MVC Model\n* 이 구조에서는 View가 Model의 의존구조가 없어졌지만, **Controller의 의존이 더 강해졌다.** \n    - View, Model의 변화를 모두 처리해줘야 한다. -> Container의 유지 보수가 너무 힘들다 \n* 그래서 점차 사용하지 않는 추세이다.\n\n\n# MVP\n![](./2회/MVP.png)\n> 4세대 language에서사용(비쥬얼 베이지, 파워 빌더, MFC, 안드로이드)   \n\n* visual basic으로 예를 들면 editor에 버튼 끌어다 놓으면 버튼을 제어 할 수 있는 property가 이미 있다. view에 interface를 노출하는게 아니라 프로그래밍으로서의 인터페이스로서 getter, setter를 노출하고 있다. (하나의 컴포넌트에 설정을 할 수 있는 getter, setter가 있다. )\n\n* presenter 역할\n    * **presenter는 view에 getter, setter로 접근한다.** \n        - view는 Model에 대한 지식이 하나도 없다 \n        - 원래 DOM 객체, native 객체로 보이는게 아니라 getter, setter를 가지고 있는 인터페이스로 보이게 된다. \n    * mvc처럼 Model을 던져 view를 제어하는게 아님.\n\n* 사용하는 이유\n    - **View에대한 Model의 의존성 완전히 제거**로 첫번째 MVC패턴에서 보여준 View, Model의 관계를 끊어 버린다.\n    - Presenter, Model만 개발하면 된다.\n\n* MVC를 탈피하기 위해서 MVP를 많이 사용한다. \n    - **View가 rednering 재량권을 다 잃어 버리고, Presenter가 getter, setter통해서 통제하는 방법으로 바꿔 주면된다.** \n    - **하지만 View단에 getter, setter를 다 만들어줘야 한다.** (= view가 무거워진다.) \n\n* 단점\n    - View에 getter, setter를 만들어줘야하는 부담이 있다.\n    - 가볍게 어플리케이션을 만들기 부담\n\n* 결론 \n    - FW에서 MVP를 지원했을때 사용한다. \n\n\n# MVVM\n![](./2회/MVVM.png)\n\n* 핵심\n    - `Binder`, `ViewModel`  \n    - **Binder를 통해서 ViewModel은 View에대한 의존성을 없앴다.**\n    - ViewModel은 순수객체로 이루어져있다.\n\n* **MVVM이 View를 변경하는 방법**\n    1. ViewModel의 순수한 객체를 갱신으로 View를 바꾼다.\n    2. Binder에게 그려달라고 요청  \n    3. Binder는 연결되어 있는 ViewModel을 해석해서 관련된 View를 갱신\n\n* `ViewModel`\n    - view다! 하지만 진짜 그림을 그리는 view가 아니라 **인메모리 객체로써의 순수한 data view(view를 대신하는 객체**)이다. \n    - view를 대신하는 순수한 데이터 구조체 그래서 Model에서도 ViewModel을 갱신 할 수 있다. 그래서 node에서도 ViewModel 변경으로 View를 변경할 수 있다. \n\n* View\n    - view는 viewModel이 변경되면 이에 맞게 View를 조작하면 된다. \n\n* `Binder`\n    - Binder는 observe에 의해서 ViewModel의 속성을 모두 알고 있고 변하면 View에게 알려준다. \n    - 양방향 바인딩은 view, binder에 observe를 적용해서 구현한다.\n        * ember, angular는 양방향 바인딩\n        * 안드로이드의 양방향 data binding은 양방향 바인딩을 걸수도 안걸수도 있다.\n\n## observe -> call로 대체 \n* MVVM의 핵심인 observe를 구현하기 어렵기 때문에 ViewModel이 변경되면 변경되었다고 Bidner에게 call 해서 따로 알려주는 방식으로 변경한다.\n*  수동으로 알려주는call의 장점 \n    : observe는 자동으로 viewModel변경을 감지해서 10번 변경이 일어나면 View에게 전달해주는 반면에 수동으로 call하는 방식은 10번 변경이 일어나도 한번 변경이 일어났다고 알려주는 장점도 있다. \n\n\n# TypeCheck\n구현에 들어가 먼저 Type을 Check를 알아봅시다. \n\n**Javascript는 compile언어가 아니기 때문에 runtime에 throw하지 않으면 무조건 오류가 전파됩니다. 그래서 좋은 전략은 throw로 멈추면 된다.**\n\n* ==, ===차이 \n    - === 은 두개의 작동이 들어 있다. type일치 검사를하고 ==검사를 한다. \n\n* react에서도 typeCheck를 이런방식으로 하고 있다.\n\n```js\nconst type = (target, type) => { \n    if(typeof type == \"string\"){\n        if(typeof target != type) throw `invaild type ${target} : ${type}`;\n    } else if(!(target instanceof type)) throw `invaild type ${target} : ${type}`;    \n    return target;\n};\n\ntype(12, \"number\");                 // 12\ntype(\"abc\", \"string\");              // \"abc\"\ntype([1,2,3], Array);               // [1,2,3]\ntype({}, Object)                    // {}\ntype(new Set, Set);                 // Set(0) {}\ntype(document.body, HTMLElement);   //<body>...</body>\n```\n\n## typeCheck 사용방법 \n* 인자가 순차적으로 해석된다.\n    - es6에서 첫번째 인자값이 그 이후에 오는 인자값에서 알수 있습니다. \n\n```js\nconst test = (arr, _ = type(arr, Array)) => {\n    console.log(arr)\n}\n\ntest([1, 2, 3]) //(3) [1, 2, 3]\ntest(123)       //Uncaught invaild type 123 : function Array() { [native code] }\n\n\nconst test2 = (a, b, c, _0 = type(a, \"string\"), _1 = type(b, \"number\"), _2 = type(c, \"boolean\"))=> { \n    console.log(a, b, c);\n};\n\ntest2(\"abc\", 123, true);        //abc 123 true\n```\n\n# View hook & bind\nbind에 View를 그냥 연결 시켜줄 수 없다.  \n그래서 View에는 어떤 ViewModel과 연결 시켜줄 Hook해주는 과정이 필요하다.\n\n![](./2회/viewHookAndBind.png)\n\n* hook\n    - 위 View(template)이 하나의 ViewModel과 연결이 된다. \n그래서 각 el은 어떤 ViewModel의 어떤 키와 매칭 될것인지 지정하는 해야 한다. \n그 방법을 template의 dataset을 사용해서 hook 해줄 수 있다. \n\n* el에 있는 data-viewmodel property value와 viewModel과 bind\n    - data-viewmodel property의 value \"wrapper\", \"title\", \"contents\"은 나중에 bind에 의해서 ViewModel 속성에 매칭 될 것이다. \n\n* bind가 하는 일 \n    - **view에 있는 스캔하면서 data-viewmodel을 hook해서 ViewModel과 연결해서 나중에 viewModel은 view에 반영해주게 된다.** \n\n* dataset\n     - html5 spec에 따르면 dataset 속성은 w3chtml5 validator를 통과하게 되어 있다. 왜냐하면 custom 속성을 마음대로 분리할 수 있는 속성이기 때문이다. \n     - angular에서 사용하는 template에서 사용하는 custom 속성들은 validation을 돌리면 다 깨진다. \n\n  \n# Role Design\n* MVVM에서의 핵심은 `Binder`에 있다. \n\n* Binder, View, ViewModel의 관계\n    - Binder가 View를 scan해서   \n        특정 ViewModel에 넘기고   \n        ViewModel이 변하면   \n        Binder는 변한 ViewModel을 가지고 sacan했던 View에 그린다.   \n        (ViewModel은 View를 모르기 때문에 Binder에게 시킨다.)\n\n## binding의 두가지 방법\n* template의 tag를 scan하는 방법: angular, vueJs\n* **template에 자기 ViewModel을 연결해서 만드는 방법: react** \n    - react는 state, property를 이용해서 자기 view를 자기가 소유(view를 scan하지 않는다.)\n* 장단점 \n    - angular에서는 ViewModel, view를 나눠서 관리하기 쉽다. \n    - **react는 state, view가 동시에 들어 있다. (component방식)**\n\n## Scanner\n![](./2회/Role_Design_Scaner.png)\n- **Scanner 존재의 역할**\n    1. Binder가 HTMLElement의 dataSet property를 Scan한다.  \n    2. Scanner로 부터 Binder를 알게 된다.   \n    3. 결국 Binder는 HTMLElement를 모르게 된다.   \n- **Scanner를 만드는 이유** \n    * **우리는 객체마다 바뀌는 이유를 하나로 만들어야 한다. (SRP 원칙-Single Responsibility(단일책임))**\n    * 원인에 따른 변화율이다 \n        * 코드를 바꾸는 이유가 같은가 다른가? \n            - **Binder는 ViewModel을 이용해서 view를 그릴때**\n            - **Scanner는 HTMLElement를 해석(Scan)하는데 방법이 바뀔때** \n    * 그래서 Binder에서 Scaner를 빼내서 관리한다. \n\n* BinderItem\n![](./2회/Role_Design_BinderItem.png)\n    - Binder안에 각 el에 해당하는 BinderItem을 만들어서 넣어주게 되어 있다.\n    - 위 예시에서 wrapper, title, contents의 hook이 items가 되고 이것을 BinderItem에 끼워준다.\n\n* 결론 \n    - ViewModel, Binder, BinderItem, Scanner를 만들것이다 \n    - 완성하면 HTMLElement로부터 hook을 생성한 통해서 생성한 BinderItem을 만들어 내고 \n    - 만들어낸 BinderItem을 소유한 Binder가 만들어진다. \n    - ViewModel을 만들어서 Binder에게 던져서 그려줘! 하면 Binder가 Scanner를 이용해서 그려줄 것이다. \n    - 그러면 결국에는 ViewModel을 갱신해서 Binder에게 그려달라고 하면 view가 변하는 것을 볼 수 있다.\n\n# 구현  \n> ViewModel, Binder, Scanner, client 이 네가지를 구현해볼 것입니다. \n\n## ViewModel\n* 순수한 인메모리 객체이기 때문에 구현하기 가장 쉽다.\n* 목적\n    - ViewModel이 View의 dom객체를 표현\n* 특징\n    - ViewModel을 만듬으로서 단위테스트를 짜기 편해짐\n        - 이유는 dom을 직접가지고와서 표현할 필요가 없기때문이다 \n        - *viewModel만 테스트하면되고 만약 잘못되면 binder(그림그리는 복잡한 로직)가 잘못된 것* \n            * **이 의미는 IOC가 성립된다는 것을확인 할 수 있다.** \n\n* MVVM Pattern 도식화  \n    \n    ![](./2회/mvvmPatternDiagram.png)\n\n```js\nconst ViewModel = class{\n    //POINT1\n    static #private = Symbol(); // Static private field\n    static get(data){\n        return new ViewModel(this.#private, data); \n    }\n    //POINT2\n    styles = {}; attributes = {}; properties = {}; events = {}; \n    constructor(checker, data){\n        //POINT1\n        if(checker != ViewModel.#private) throw \"use ViewModel.get()!\"; \n        //POINT3\n        Object.entries(data).forEach(([k, v])=>{\n            switch(k){\n                case\"styles\": this.styles = v; break;\n                case\"attributes\": this.attributes = v; break;\n                case\"properties\":  this.properties = v; break;\n                case\"events\": this.events = v; break;\n                default: this[k] = v;\n            }\n        });\n        Object.seal(this); \n    }\n};\n```\n* POINT1\n    * private constructor 첫번째 param\n        - 외부에서는 constructor에 첫번째 parameter에 ViewModel.#private 인자를 넘길 수 없다.  \n        -> **오직 내부에서만 ViewModel 인스턴스를 생성할 수 있다.**\n        - 외부에서 생성을 하는것을 막는다. 오직 static get을 통해서만 인스턴스를 만들고 싶다.  \n        \n        - \"#\" 문법\n            * [참고: Class field declarations proposal](https://poiemaweb.com/es6-class#5-class-field-declarations-proposal)\n            * 최신 브라우저(Chrome 72 이상) 또는 최신 Node.js(버전 12 이상)에서 정상 동작\n            * Javascript의 새로운속성 private 속성은 \"#\" 으로 시작 \n            * 외부, 내부에서 대괄호 구문으로 접근안되고, dot notaion으로만 접근가능\n            * 클래스 내부에서 밖에 쓸 수 없다. \n    * this는 viewModel을 가르킨다. \n* POINT2\n    - dom 객체를 대신하는 인메모리객체이기 때문에 dom에 있는 정보를 뽑아 냈다. \n* POINT3\n    - constructor에서 받은 data를 ViewModel instance에 POINT2에서 선언한 속성에 세팅한다.\n* POINT4\n    - 더 이상 this객체에 key를 추가하지 못하고 writable일때 변경만 가능하다\n    - [seal mdn 참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\n    - [freeze mdn 참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n\n## BinderItem && Binder\n* Binder는 native View를 있다. 그래서 ViewModel이 Binder에게 viewModel객체를 넘겨 view를 변경한다.\n* BinderItem class 생성시 설정되는 것은?  \n-> 참고: 실제 코드에서 선언되 html 코드 \n    - navtive element \n    - view에서 hook된 key값(data-viewmodel property value)\n\n### BinderItem\n* html을 하나하나 item으로 인식하기 위해서 element의 hook되어 있는 key로\n* Binder가 scan할때 알수 있는건 \"문자열, wrapper, title, content\" 뿐이다.  \nBinder가 어떤 viewModel과 결함해서 그릴지 모르기때문에 나중에 lazy Binding를 하기 위함이다.  \n그래서 hook해서 key만 가지고 있고 실제로 그림그릴때 ViewModel속성과 매칭(Binding)하기 위해서 key만 가지고 있는 것이다. \n \n* MVVM Pattern 도식화   \n![](./2회/mvvmPatternDiagram.png)\n\n```js\nconst BinderItem = class{\n    el; viewmodel;\n    \n    //POINT\n    constructor(el, viewmodel, _0=type(el, HTMLElement), _1=type(viewmodel, \"string\")){\n        this.el = el;\n        this.viewmodel = viewmodel;\n        Object.freeze(this);\n    } \n};\n\n//POINT1\nnew BinderItem(section, \"wrapper\"); \nnew BinderItem(h2, \"title\");\nnew BinderItem(section2, \"contents\");\n```\n\n```html\n<section id=\"target\" data-viewmodel=\"wrapper\">\n  <h2 data-viewmodel=\"title\"></h2>\n  <section data-viewmodel=\"contents\"></section>\n</section>\n```\n\n* POINT\n    - constructor param\n        * el: view의 elements\n        * viewmodel: hook의 key값(data-viewmodel의 value)\n        * _0, _1: el, viewmodel이 어떤 type인지 확인 할 수 있다. \n    - freeze로 BinderItem은 변할 수 없도록 한다. \n* POINT1\n    - 실제로 BinderItem은 **Scanner class의 checkItem에서** BinderItme을 설정한다.  \n      (new BinderItem(el, vm)코드 호출)\n    - new BinderItem으로 선언된 3개는 아래 html 코드와 관련된 내용이다. \n    \n\n\n### Binder\n* 객체지향은 identifier context를 지향한다. (메모리 기반으로 데이터를 구분)\n    - 객체 container는 언제나 \"set\"이다. (영상이 잘안들림...)\n\n* MVVM Pattern 도식화   \n![](./2회/mvvmPatternDiagram.png)\n```js\n    const Binder = class{\n        //POINT1\n        #items = new Set;\n        add (v, _ = type(v, BinderItem)) {this.#items.add(v);} \n        //POINT2\n        render (viewmodel, _ = type(viewmodel, ViewModel)){\n            this.#items.forEach(item=>{\n                const vm = type(viewmodel[item.viewmodel], ViewModel), \n                el = item.el; \n                Object.entries(vm.styles).forEach(([k, v])=>el.style[k] = v); \n                Object.entries(vm.attributes).forEach(([k, v])=>el.setAttribute\n                (k, v)); \n                Object.entries(vm.properties).forEach(([k, v])=>el[k] = \n                v); \n                Object.entries(vm.events).forEach( ([k, v])=>el[\"on\" + k] \n                = e =>v.call(el, e, viewmodel) );\n            }); \n        }\n    };\n```\n* POINT1(add)\n    - Scanner class의 checkItem에서 호출을 통해서 설정된다.\n    - add를 통해서 #items는 BinderItem 인스턴스를 가지고 있겠다.\n    - \"#item\"은 add를 통해서만 설정가능하다.\n\n* POINT2(render)\n    - 실제로 el을 render하는 과정이 있다.\n    - client에서 호출한다.\n    - render객체를 받고 있다.\n    - forEach \n        * \"#items\"을 순회하니까 Binderitems 인스턴스가 하나씩 순회하겠다.\n        * item.viewmodel은 hook의 key값이므로 viewmodel객체에서 유무를 확인한다. \n        * item.el은 natvie element를 가지고 있다.\n        * **e => v.call(el, e, viewmodel)) 의미**\n            - event객체 설정시 call을 통해서 this를 el객체로 element, e는 event 객체, viewmodel을 넘긴다.\n            - this가 설정되는 element이기 때문에 event객체로 e.target으로 확인하지 않아도 된다. \n\n        * [Object.entries mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n    - <u>el = tiem.el</u> 코드에 분기문이 없이 validation 가능한 이유.\n        * this.#items, viewmodel은 각각 BinderItem, Binder class에서 type체크를 하고 있기 때문에 \n\n## Scanner\n* 역할\n    - Scanner가 HTMLElement Dom을 읽어와 Dom에 hook과 관련된 property(여기에선 data-datamodel)를 읽어온다.\n    - 읽어온 hook 하나에 BinderItem을 만들어 Binder에 넣어준다.\n\n* dom 순회하는 코드를 만든다! \n\n* MVVM Pattern 도식화  \n![](./2회/Role_Design_Scaner.png)\n\n    ```js\n    const Scanner = class{\n        scan(el, _ = type(el, HTMLElement)){\n            //POINT1\n            const binder = new Binder; \n            //POINT3\n            this.checkItem(binder, el);\n\n            //POINT2 - dom 순회\n            const stack = [el.firstElementChild];         \n            let target;\n            while(target = stack.pop()){\n                //POINT3\n                this.checkItem(binder, target);\n                if(target.firstElementChild) stack.push(target.firstElementChild); \n                if(target.nextElementSibling) stack.push(target.nextElementSibling);\n            }\n            //POINT1\n            return binder;\n        }\n        //POINT3\n        checkItem(binder, el){\n            const vm = el.getAttribute(\"data-viewmodel\"); \n            if(vm) binder.add(new BinderItem(el, vm));\n        } \n    };\n    ```\n* POINT1\n    - **Binder를 만들어서 binder를 반환합니다.**\n \n* ***POINT2: dom순회***\n    - 재귀적으로 돌기 싫으면 stack Loop를 \u001d사용하게 된다 \n        - 재귀적으로 함수를 반복적으로 호출해서 문제를 해결하면 stack이 계속 쌓이기 때문에 \"stack over flow\"가 걸리게 된다. \n        - 재귀적인 문제를 해결하기위해서는 배열로 stack 역할을 하게 별도의 메모리 공간에 만들고 file을 돌면서 처리하면 됩니다. \n            * stack.pop(): 동적 게입법(동적으로 배열에 있는 것을 빼가면서 처리) \n            * stack.push 코드 두개를 보면 firstElementChild, nextElementSibling을 통해서 dom을 순회하기 때문에 stack에는 모든 dom 객체들이 쌓일 것이다.\n* POINT3\n    - **Scanner를 분리하게된 이유코드** \n        * el.getAttribute(\"data-viewmodel\");\n        * 이 코드가 binder와 무관하다.\n        * 이 코드를 바꿔주면 html의 spec을 바꿔 줄 수 있다(hook 할 html property)\n\n## client\n* MVVM Pattern 도식화   \n![](./2회/Role_Design_Scaner.png)\n![](./2회/mvvmPatternDiagram.png)\n\n    ```js\n    //POINT1\n    const viewmodel = ViewModel.get({\n        wrapper: ViewModel.get({\n            styles: { width: '50%', background: '#ffa', cursor: 'pointer'}\n        }),\n        title: ViewModel.get({\n            properties: { innerHTML: 'Title' }\n        }),\n        contents: ViewModel.get({\n            properties: { innerHTML: 'Contents' }\n        })\n    });\n\n    const scanner = new Scanner;\n    //POINT2\n    const binder = scanner.scan(document.querySelector(\"#target\"));\n    //POINT3\n    binder.render(viewmodel);\n    ```\n\n* POINT1\n    - render할대 필요한 viewmodel 객체 생성\n    - ViewModel.get 함수를 보면 ViewModel 인스턴스를 반환한다.\n* POINT2\n    - \"#target dom을 순회해서 binder 인스턴스를 반환한다.\n    - binder는 dom을 순회하면서 각dom에 BinderItem \"#item\" private variable에 세팅한다.(Set 객체)\n* POINT3\n    - render를 한다.\n\n## client개선\n- 배경 색을 계속 바꾸도록 변경하고 반뀌는 곳을 클릭하면 배경 바뀌는것이 멈춘다.\n\n    ```js\n    const scanner = new Scanner();\n    const binder = scanner.scan(document.querySelector('#target'));\n\n    const getRandom = () => parseInt(Math.random() * 150) + 100\n    const viewmodel = ViewModel.get({\n        isStop: false,\n        //POINT1\n        changeContents () {\n            this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`;\n            this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '');\n            binder.render(viewmodel);\n        },\n        wrapper: ViewModel.get({\n            styles: { width: '50%', background: '#fff', cursor: 'pointer' },\n            events: { click(e, vm) { vm.isStop = true } }\n        }),\n        title: ViewModel.get({\n            properties: { innerHTML: 'Title' }\n        }),\n        contents: ViewModel.get({\n            properties: { innerHTML: 'Contents' }\n        })\n    })\n\n    const f = () => {\n        //POINT1\n        viewmodel.changeContents();\n        binder.render(viewmodel);\n        if (!viewmodel.isStop) requestAnimationFrame(f);\n    }\n\n    requestAnimationFrame(f);\n    ```\n\n* POINT1\n    - viewmodel을 바궈 render하게 되면 binder가 viewmodel객체를 가지고 rendering 한다.\n\n\n# 최종 코드 \n- client코드는 개선된 코드를 사용(background색이 계속 변함)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <section id=\"target\" data-viewmodel=\"wrapper\">\n        <h2 data-viewmodel=\"title\"></h2>\n        <section data-viewmodel=\"contents\"></section>\n    </section>\n    <script>\n        const type = (target, type) => { \n            if(typeof type == \"string\"){\n                if(typeof target != type) throw `invaild type ${target} : ${type}`;\n            } else if(!(target instanceof type)) throw `invaild type ${target} : ${type}`;    \n            return target;\n        };\n\n\n        const ViewModel = class{\n            //POINT1\n            static #private = Symbol(); // Static private field\n            static get(data){\n                return new ViewModel(this.#private, data); \n            }\n            //POINT2\n            styles = {}; attributes = {}; properties = {}; events = {}; \n            constructor(checker, data){\n                //POINT1\n                if(checker != ViewModel.#private) throw \"use ViewModel.get()!\"; \n                //POINT3\n                Object.entries(data).forEach(([k, v])=>{\n                    switch(k){\n                        case\"styles\": this.styles = v; break;\n                        case\"attributes\": this.attributes = v; break;\n                        case\"properties\":  this.properties = v; break;\n                        case\"events\": this.events = v; break;\n                        default: this[k] = v;\n                    }\n                });\n                Object.seal(this); \n            }\n        };\n\n        const BinderItem = class{\n            el; viewmodel;\n            //POINT\n            constructor(el, viewmodel, _0=type(el, HTMLElement), _1=type(viewmodel, \"string\")){\n                this.el = el;\n                this.viewmodel = viewmodel;\n                Object.freeze(this);\n            } \n        };\n\n        const Binder = class{\n            //POINT1\n            #items = new Set;\n            add (v, _ = type(v, BinderItem)) {this.#items.add(v);} \n            //POINT2\n            render (viewmodel, _ = type(viewmodel, ViewModel)){\n                this.#items.forEach(item=>{\n                    const vm = type(viewmodel[item.viewmodel], ViewModel), \n                    el = item.el; \n                    Object.entries(vm.styles).forEach(([k, v])=>el.style[k] = v); \n                    Object.entries(vm.attributes).forEach(([k, v])=>el.setAttribute\n                    (k, v)); \n                    Object.entries(vm.properties).forEach(([k, v])=>el[k] = \n                    v); \n                    Object.entries(vm.events).forEach( ([k, v])=>el[\"on\" + k] \n                    = e =>v.call(el, e, viewmodel) );\n                }); \n            }\n        };\n\n        const Scanner = class{\n            scan(el, _ = type(el, HTMLElement)){\n                //POINT1\n                const binder = new Binder; \n                //POINT3\n                this.checkItem(binder, el);\n\n                //POINT2 - dom 순회\n                const stack = [el.firstElementChild];         \n                let target;\n                while(target = stack.pop()){\n                    //POINT3\n                    this.checkItem(binder, target);\n                    if(target.firstElementChild) stack.push(target.firstElementChild); \n                    if(target.nextElementSibling) stack.push(target.nextElementSibling);\n                }\n                //POINT1\n                return binder;\n            }\n            //POINT3\n            checkItem(binder, el){\n                const vm = el.getAttribute(\"data-viewmodel\"); \n                if(vm) binder.add(new BinderItem(el, vm));\n            } \n        };\n\n\n        const scanner = new Scanner();\n        const binder = scanner.scan(document.querySelector('#target'));\n\n        const getRandom = () => parseInt(Math.random() * 150) + 100\n        const viewmodel = ViewModel.get({\n            isStop: false,\n            //POINT1\n            changeContents () {\n                this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`;\n                this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '');\n                //binder.render(viewmodel); 없어도됨 -> 아래 f 함수에서 해주고 있다. \n            },\n            wrapper: ViewModel.get({\n                styles: { width: '50%', background: '#fff', cursor: 'pointer' },\n                events: { click(e, vm) { vm.isStop = true } }\n            }),\n            title: ViewModel.get({\n                properties: { innerHTML: 'Title' }\n            }),\n            contents: ViewModel.get({\n                properties: { innerHTML: 'Contents' }\n            })\n        })\n\n        const f = () => {\n            //POINT1\n            viewmodel.changeContents();\n            binder.render(viewmodel);\n            if (!viewmodel.isStop) requestAnimationFrame(f);\n        }\n\n        requestAnimationFrame(f);\n    </script>\n</body>\n</html>\n```\n* 크롬에서 그림그리는데 역량을 많이 쓰고 있다. binder.render는 거의 부하에 영향이 가지 않는다 \n    * binder.render는 viewmodel을 loop돌면서 걸린애들만 dom조작이 일어난다. \n\n\n# 결론\n## 결론1 - MVVM을 쓰는이유\n* **제어의 역전으로 view제어를 Binder에 모두 작성했다.**\n    - view를 Control하는 Code(view의 style, attribute, event 등)는 없다. \n    - Binder.render에서 viewmodel을 가지고 view를 update 한다. \n    - view를 조작하는 코드를 없앨수 있다. \n* 단위테스트를 viewmodel만 검사하면된다. \n* view를 조작하는 오류를 줄일 수 있다. \n\n## 결론2 - MVVM으로 해결한 문제 \n* MVVM을 구축하는 과정 보다 **MVVM 프레임워크자체의 객체 구조를 이해하는 것이 객체를 관리하는 것에 도움이 됨**\n* Model이 바뀔 때 마다 View가 영향을 받는 의존성 문제\n* View 마다 View를 그리는 로직들을 다 MVC에서 하나하나 만들어야 하는 문제\n* 어떻게해야 View마다 View를 그리는 로직을 다 없앨까?\n    * **제어 역전을 통해서(Binder에게 위임)**\n    * **View를 직접적으로 알지 못하게 하는 모델을 만듬**\n\n## 결론3 - 의존성에 문제가 있다. \n* 위 scanner내용에서 SRP내용 참고  \n* [scanner](https://happyjy.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_2/#scanner)\n","excerpt":"목표 객체지향을 가지고 이것 저것 만들어 볼 예정인데 그중 을 을 만들어 본다. 그리고 다음시간에는 이것을 가지고 서비스를 만들어 볼 예정입니다.  MVVM Model, View, ViewModel의 약자  MS의 pwf…","fields":{"slug":"/OOPWithJavascript_2/"},"frontmatter":{"date":"Feb 29, 2020","title":"객체지향 자바스크립트 2회차(MVVM 구현)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* H-Index를 구하라!\n* H-Index란? \n    - 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다.\n\n        \n# 해결 방법 \n* 논문이 \"**h번 이상 인용된 논문이 h편 이상**이고 나머지 논문이 h번 이하\" 이것이 포인트!\n* 아래처럼 h번이 의마하는 것을 생각해보면 배열을 내림차순으로 정렬하고 순환하며 h를 구할 수 있겠다.\n    - h번 이상인용된 논문: 배열의 요소\n    - h번 이상인용된 논문이 h편 이상: 배열 indx\n\n# STEP\n* STEP1: 내림차 순으로 정렬\n* STEP2: 순환하면서 hIndex를 구하고, 순환 유무 flag를 통해서 순환 제어\n\n# CODE\ncitation: 인용구\n```js\nfunction solution(citations) {\n    var hIndex = 0;\n    var iteratorFlag = true;\n    citations.sort((a, b)=> b-a).forEach((citation, idx) => {\n        if(citation > idx && iteratorFlag) {\n            ++hIndex;\n        } else {\n            iteratorFlag = false;\n        }\n    });\n\n    return hIndex;\n}\n\nconsole.log(solution([3, 0, 6, 1, 5]));\nconsole.log(solution([6, 6, 6, 6, 6]));\nconsole.log(solution([6, 6, 6, 6, 6, 6]));\nconsole.log(solution([6, 5, 4, 3, 2, 1]));\nconsole.log(solution([6, 0, 0, 0, 0, 0]));\nconsole.log(solution([4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6]));\n```\n\n# 결과\n3\n5\n6\n3\n1\n6\n","excerpt":"문제 H-Index를 구하라! H-Index란?  어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다. 해결 방법 논문이 \"h번 이상 인용된 논문이 h…","fields":{"slug":"/Hindex/"},"frontmatter":{"date":"Feb 25, 2020","title":"정렬_교수의 논문 인용단위 HIndex 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하라\n```\n예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\narray의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\n1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\n2에서 나온 배열의 3번째 숫자는 5입니다.\n```\n\n# 제한사항\n```\narray의 길이는 1 이상 100 이하입니다.\narray의 각 원소는 1 이상 100 이하입니다.\ncommands의 길이는 1 이상 50 이하입니다.\ncommands의 각 원소는 길이가 3입니다.\n```\n\n# 해결 방법 \n* map을 이용해 주어진 배열을 가공해 새로운 배열을 만든다.\n* 주어진 배열을 자르기 위해서, k번째 있는 수를 얻기위해서 \"slice\", 정렬을 위해서 \"sort\"를 사용해서 문제를 해결 할 수 있겠습니다.\n\n# STEP\n* STEP1: map을 이용해서 주여진 배열을 가공해 새로운 배열을 만듭니다.\n* STEP2: slice이용해 배열을 자른다.\n* STEP3: sort를 이용해 정렬한다.\n* STEP4: slice를 이용해 원하는 k번째 있는 수를 구한다. 또는 배열 요소에 접근해서 k번째 요소를 찾는다.\n\n\n# CODE\n```js\nvar arr = [1, 5, 2, 6, 3, 7, 4];\nvar commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]];\n\nfunction solution(array, commands) {\n    return commands.map( v => {\n        return slicedSorted = array.slice(v[0]-1, v[1]).sort((b,c) => b-c).slice(v[2]-1, v[2])[0];\n        \n    });\n}\n\nconsole.log(solution(arr, commands));\n```\n\n# 결과\n[5, 6, 3]\n\n","excerpt":"문제 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하라 제한사항 해결 방법 map을 이용해 주어진 배열을 가공해 새로운 배열을 만든다. 주어진 배열을 자르기 위해서, k…","fields":{"slug":"/배열 자르고 K번째 수/"},"frontmatter":{"date":"Feb 25, 2020","title":"정렬_K번째 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다\n\n# STEP\n* STEP1: 배열의 숫자형을 문자형으로 변환\n* STEP2: 문자형변환후 배열 요소를 자리를 바꿔가며 숫자 크기를 비교(문자열x)\n\n# CODE\n```js\nvar a = [3, 30, 34, 5, 9];\nvar b = [6, 10, 2];\n\nfunction solution(numbers) {\n    var answer = numbers.map(v => v + '')\n        .sort((a, b) => (b + a)* 1 - (a + b)*1)\n        .join('');\n\n    return answer[0] === '0' ? '0' : answer\n}\n```\n\n# 결과\n![](result.png)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다 STEP STEP…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 25, 2020","title":"정렬_배열로 조합할 수 있는 수중 가장 큰 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# Readme\nCloning Instagram with Python django + React\n\n# github\n[github 주소](https://github.com/happyjy/yoonGram)\n\n# 정리 노트 \n[notion 주소](https://www.notion.so/happyjy0109/2019-Node-js-Express-ReactJS-Prisma-201910-2019XX-df8d226e12f74f63a4118df9570e75c4)","excerpt":"Readme Cloning Instagram with Python django + React github github 주소 정리 노트 notion 주소","fields":{"slug":"/instagram clone coding/"},"frontmatter":{"date":"Feb 24, 2020","title":"INSTAGRAM CLONE CODING","tags":["TOYPROJ"]}}},{"node":{"rawMarkdownBody":"\n# README\nInstagram clone with Express + Prisma + React\n\n# github\n[Front End(React)github 주소](https://github.com/happyjy/prismagram-frontend)  \n[Back End(Express, Prisma)github 주소](https://github.com/happyjy/prismagram)\n\n# 정리 노트 \n[notion 주소](https://www.notion.so/happyjy0109/2019-Node-js-Express-ReactJS-Prisma-201910-2019XX-df8d226e12f74f63a4118df9570e75c4)","excerpt":"README Instagram clone with Express + Prisma + React github Front End(React)github 주소 Back End(Express, Prisma)github 주소 정리 노트 notion 주소","fields":{"slug":"/instagram clone coding_2/"},"frontmatter":{"date":"Feb 24, 2020","title":"INSTAGRAM CLONE CODING_2","tags":["TOYPROJ"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n```\n    숫자 야구 게임이란 2명이 서로가 생각한 숫자를 맞추는 게임입니다. \n\n    각자 서로 다른 1~9까지 3자리 임의의 숫자를 정한 뒤 서로에게 3자리의 숫자를 불러서 결과를 확인합니다. \n    그리고 그 결과를 토대로 상대가 정한 숫자를 예상한 뒤 맞힙니다.\n\n    * 숫자는 맞지만, 위치가 틀렸을 때는 \"볼\"\n    * 숫자와 위치가 모두 맞을 때는 \"스트라이크\"\n    * 숫자와 위치가 모두 틀렸을 때는 \"아웃\"\n    \n    예를 들어, 아래의 경우가 있으면\n    A : 123\n    B : 1스트라이크 1볼.    //123 중 2개 숫자, 1개는 자리까지 맞음\n    A : 356\n    B : 1스트라이크 0볼.    //3XX확신 (위숫자에서 겹치는게 3뿐이라서)/ 1,2숫중 1개는 볼\n    A : 327\n    B : 2스트라이크 0볼.    //32X확신 (3은 두번째서 고정, 그렇다면 첫,두번째에서 1개 볼인데 겹치는수가 2)\n    A : 489\n    B : 0스트라이크 1볼.    //마지막자리 빼고 확정이기 때문에 이런 경우 첫번째 두번째 자리숫자가 볼의 대상이된다. 그래서 324, 328이 답이된다. \n    이때 가능한 답은 324와 328 두 가지입니다.\n\n    질문한 세 자리의 수, 스트라이크의 수, 볼의 수를 담은 2차원 배열 baseball이 매개변수로 주어질 때, 가능한 답의 개수를 return 하도록 solution 함수를 작성해주세요.\n```\n\n# 제한사항\n* 질문의 수는 1 이상 100 이하의 자연수입니다.\n* baseball의 각 행은 [세 자리의 수, 스트라이크의 수, 볼의 수]를 담고 있습니다.\n\n# 입출력 예\n```\nbaseball\t                                            return\n[[123, 1, 1], [356, 1, 0], [327, 2, 0], [489, 0, 1]]\t2\n```\n\n# 해결 방법 \n* for문 2개\n    - outer for: 예상할 수 있는 3자리 숫자 Array\n    - inner for: 예상 정답 Array\n\n* 가능 정답 찾기 로직\n    - 위 for문을 돌면서 2번 예상 정답 Array안에서 찾기\n    - strike, ball 인경우를 조건문으로 찾는다.\n# STEP\n\n# CODE\n```js\n    function solution(baseball) {\n        var answer = 0;\n\n        // 서로 다른 3개의 수 조합. \n        for(let i=123; i<=987; i++) {\n            let [x, y, z] = (i+\"\").split('');\n\n            // 서로 다른 3개 수 조합을 만들기 위해서 \n            if(x === \"0\" || y === \"0\" || z === \"0\") continue;\n            if(x === y || x === z || y === z) continue;\n\n            for(let j=0; j<baseball.length; j++) {\n                let strike = 0;\n                let ball = 0;\n\n                //query: 던진 숫자\n                //query_s: query_strike\n                //query_b: query_ball\n                const [query, query_s, query_b] = baseball[j];\n                const [query_x, query_y, query_z] = (query + \"\").split('');\n                if(query_x === \"0\" || query_y === \"0\" || query_z === \"0\") break;\n                if(query_x === query_y || query_x === query_y || query_y === query_z) break;\n\n                if(x === query_x) strike++;\n                if(y === query_y) strike++;\n                if(z === query_z) strike++;\n                if(query_s != strike) break;\n\n                if((x === query_y) || (x === query_z)) ball++;\n                if((y === query_x) || (y === query_z)) ball++;\n                if((z === query_x) || (z === query_y)) ball++;\n                if(query_b != ball) break;\n\n                if(j === baseball.length - 1) answer++;\n            }\n        }\n        return answer;\n    }\n    \n    console.log(solution([[123, 1, 1], [356, 1, 0], [327, 2, 0], [489, 0, 1]])); //2\n```\n\n# 정답 \n2\n","excerpt":"문제 제한사항 질문의 수는 1 이상 100 이하의 자연수입니다. baseball의 각 행은 세 자리의 수, 스트라이크의 수, 볼의 수를 담고 있습니다. 입출력 예 해결 방법 for문 2개 outer for: 예상할 수 있는 3자리 숫자 Array…","fields":{"slug":"/숫자야구/"},"frontmatter":{"date":"Feb 24, 2020","title":"완전탐색_숫자야구","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n한자리 숫자가 적힌 종이 조각이 흩어져있습니다. \n흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.\n\n# 제한사항\nnumbers는 길이 1 이상 7 이하인 문자열입니다.\nnumbers는 0~9까지 숫자만으로 이루어져 있습니다.\n013은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.\n```\n# 입출력 예\nnumbers\t    return\n17\t        3\n011\t        2\n\n# 입출력 예 설명\n예제 #1\n[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.\n\n예제 #2\n[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.\n\n11과 011은 같은 숫자로 취급합니다.\n```\n\n# 해결 방법 \n* 배열에 있는 숫자를 이용해 만들수 있는 모든 숫자를 만든는 방법이 중요하다\n    - makeAllNumber function\n        - 재귀호출로 구현(아래 코드 주석 POINT)\n\n# STEP\n* 배열에 있는 숫자로 만들수 있는 모든 조합된 숫자 구한다.\n* Prime인지 아닌지 구분한다.\n\n\n# CODE\n```js\nconst isPrime = (n) => {\n    if (n < 2) return false;\n    const sqrt = Math.sqrt(n);\n    for (let i = 2; i <= sqrt; i++)\n        if (n % i === 0) return false;\n    return true;\n}\n\n/*\n    number  : type integer : \n    numbers : type array   : \n    return  : type array   : \n*/\nconst makeAllNumber = (number = null, ...numbers) => {\n    if (number === null) return [];\n    if (numbers.length === 0) return [number];\n\n    let arr = [number]; // arr : 조합된 숫자\n    for (const idx in numbers) {\n        // * rest : numbers에 idx 요소를 제외한 나머지 index 요소\n        const rest = numbers.filter((v, i) => i !== parseInt(idx, 10));\n        const idxNum = numbers[idx];\n\n        // * number, idxNum type : string \"\"+\"1\" = \"1\"/ \"1\" + \"2\" = \"12\"\n        //   - parseInt(\"1\") -> 1\n\n        // * rest가 빈배열 일때 까지 '재귀함수가' 반복 (위 filter return type은 array)\n\n        //STUDY2 - 모든 문자열 찾는 방법\n        arr = [...arr, ...makeAllNumber(number + idxNum, ...rest)];\n        arr = [...arr, ...makeAllNumber(idxNum + number, ...rest)];\n        arr = [...new Set(arr)];\n    }\n\n    return arr;\n}\n\nfunction solutions(numbers) {\n    numbers = numbers.split('');\n    \n    //STUDY1 - string type을 array type으로 변경하는 방법\n    let makedNumbers = makeAllNumber(\"\", ...numbers)\n        .filter(v => v !== '')\n        .map(v => parseInt(v));\n    //STUDY3 - 중복숫자제거\n    makedNumbers = [...new Set(makedNumbers)]; \n    console.log(\"#모든숫자: \", makedNumbers);\n\n    return makedNumbers.map(isPrime).filter(v => v === true).length;\n}\n\nconsole.log(solutions(\"123\"))\n```\n\n# 추가정보 \n## STUDY1 - string type을 array type으로 변경하는 방법\n* string type도 인자로 spread syntax와 함께쓰면 배열로 받을 수 있다.\n\n## STUDY2 - 모든 문자열 찾는 방법 핵심 \n* 다이나믹 프로그래밍 방법으로 makeAllNumbers를 재귀호출하면서 number: \n\n## SUTDY3 - set 으로 중복숫자제거하기\n* standard built-in object \"Set\"의 중복을 허용하지 않는 속성을 이용해서 배열에 있는 중복 숫자를 제거할 수 있습니다.\n* Set 객체에 string type value를 보내도 단어 하나 마다 배열의 요소로 설정해서 중복되는 단어을 제외한 단어를 포함한 Set 인스턴스를 반환한다.\n* set instance를 배열 안에서 spread syntax를 사용하면 일반 배열 타입으로 반환할 수 있다. ([...[setinstance]] => 배열 바환)\n\n\n\n# 정답 \n5\n","excerpt":"문제 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. \n흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers…","fields":{"slug":"/모든숫자조합 구해서 소수찾기/"},"frontmatter":{"date":"Feb 24, 2020","title":"완전탐색_모든 숫자조합 구해서 소수찾기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 학생 3명이 있고 각각 찍는 방법이 각각 다르고 그중 누가 제일 잘찍는지 확인하는 문제 \n        \n# 해결 방법 \n* 학생3명 찍는 방법 배열과 정답 리스트를 비교하면서 학생마다 맞힌 정답 배열길이를 새로운 배열에 push\n* 그 결과를 Math.max함수를 사용 제일 큰수(제일 많이 맞힌갯수) 구한다.\n* 위 두정보를 가지고 제일 많이 맞힌 학생을 구한다.\n\n\n# STEP\n* STEP1: 학생별 찍어서 맞은 정답 arr\n* STEP2: Math.max\n* STEP3: map, filter 함수를 적절하게 사용하여 제일 잘 찍은 학생을 구한다.\n\n# CODE\n```js\nfunction solution(answerList) {\n    let answer = [];\n\n    const stdPick1 = [1,2,3,4,5];\n    const stdPick2 = [2,1,2,3,2,4,2,5];\n    const stdPick3 = [3,3,1,1,2,2,4,4,5,5];\n\n    //STEP1\n    let std1Result = answerList.filter((v,i) => v === stdPick1[i%stdPick1.length]);\n    let std2Result = answerList.filter((v,i) => v === stdPick2[i%stdPick2.length]);\n    let std3Result = answerList.filter((v,i) => v === stdPick3[i%stdPick3.length]);\n\n    const stdResult = [];\n    stdResult.push(std1Result.length);\n    stdResult.push(std2Result.length);\n    stdResult.push(std3Result.length);\n\n\n    //STEP2\n    const maxValue = Math.max(...stdResult);\n    if(maxValue === 0){\n        answer = [0,0,0];\n    } else {\n        //STEP3\n        answer = stdResult.map((v,i) => { return {std: i+1, score: v} })\n                            .filter(v=> v.score === maxValue)\n                            .map(v=>v.std)\n                            .sort();\n    }\n\n    return answer;\n}\n\nconsole.log(solution([1,2,3,4,5]));\nconsole.log(solution([1,3,2,4,2]));\nconsole.log(solution([3,3,1,1,2,2,4,4,5,5,3,3,1,1,2,2,4,4,5,5]));\n```\n\n# 정답 \n[1]\n[1,2,3]\n[3]\n\n","excerpt":"문제 학생 3명이 있고 각각 찍는 방법이 각각 다르고 그중 누가 제일 잘찍는지 확인하는 문제 \n     해결 방법 학생3명 찍는 방법 배열과 정답 리스트를 비교하면서 학생마다 맞힌 정답 배열길이를 새로운 배열에 push 그 결과를 Math.max…","fields":{"slug":"/모의고사/"},"frontmatter":{"date":"Feb 24, 2020","title":"완전탐색_누가 더 잘찍을까?","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# INTRO\n* 목표\n    - 객체 지향을 자바스크립트로 해보자.\n    - 디자인 패턴과 함께 알아보자.\n    - 오늘 배운 이론 남은 4개 강의에서 활용.\n        * SOLID(SRP, OCP, LSP, ISP, DIP)\n        * Message, 의존성, DI, IOC, \n\n# Value Context, Identifier Context\n> value Context: 함수형 프로그래밍에서 사용  \n> identifier Context: 객체지향 프로그래밍에서 사용\n\n권장 하나의 context만 사용하자 특별한 사항을 제외하고 \n\n```js\nconst a = { a:3,b:5 };\nconst b = { a:3,b:5 };\nconsole.log(a === b);   //identifier context\nconsole.log(JSON.stringify(a) === JSON.stringify(b));   //value context\n```\n\n* 객체 지향의 기본: 메소드 인자, return value, 메소드가 만드는 무언가가 모든 객체만 사용한다임.\n* 객체지향에서 사용할수 있는 value context는 생성자 인자\n\n## value특징\n1. 끝없는복사본 \n    - value값은 변하지 않으면서 복사본을 계속해서 사용한다. \n2. 상태 변화에 안전?\n    - 1번 특징으로 값이 변하지 않음으로 상태에 변화에 안전하다 \n    - 3 + 1 연산에서 3이 4로 바뀌는게 아니라 4가 새로 생기는 것 \n    - 불변하는 값을 계속 만들어서 이것도 관리한는게 힘들다 => 그래서 `함수형 프로그래밍`이 탄생\n3. 연산을 기반으로 로직을 전개(수학적 프로그래밍)\n    - 수학적 프로그래밍은 '확정', '간단'한 로직은 어울린다. \n    - 구현하기 어려운 도메인을 복잡한 연산으로 구현하기 어렵다.\n        - 복잡한 것을 도메인을 수학적 프로그래밍으로 정교하게 구현해도 교체 하는 비중이 너무 커서 깨지기 쉽다 \n    - 넷플릭스에서 어울림 동영상 스트리밍 하는 것만 연산 하면 된다.\n\n## identifier 특징\n1. 하나의원본\n    - 값이 mutable\n    - 상태가 일관적이지 않음\n2. 상태 변화를 내부에서 책임짐 \n    - 내부 상태에서 책임지는 객체를 만드는게 힘들다.\n3. 메세지를 기반으로 로직을 전개\n    - 우리가 배울 테마 \n    - 구현하는데까지 만들고 다른 놈에게 위임 할 수 있다. \n\n## 정리 \n* 객체 지향에서 제일 중요한것은 value Context를 사용하지 않는것 \n\n\n# Polymorphism\n> Polymorphism 대체가능성 + Polymorphism 내적일관성  \n> 객체 지향 프로그래밍은 Polymorphism을 지원해야 한다.\n\n## polymorphism of Prototype\n\n```js\n    const Worker = class{ \n        run(){ console.log(\"working\") }\n        print(){ this.run(); } \n    };\n    const HardWorker = class extends Worker{ \n        //overriding\n        run(){ console.log(\"hardWorking\") }\n    };\n    const worker = new HardWorker(); \n    \n    // substitution\n    console.log(worker instanceof Worker); //true -> Polymorphism의 대체가능성\n    // internal identity\n    worker.print();                        //hardWorking -> Polymorphism의 내적일관성\n```\n\n## Polymorphism의 대체가능성(substitution)\n> 확장된 클래스(자식클래스)는 확장할 대상 클래스(부모클래스)를 대체할 수 있다.\n* worker instanceof Worker 결과 값은 true이다. 아래 도식화 참고\n\n\n## Polymorphism의 내적일관성(internal identity)\n> 태어났을때 원본 클래스를 유지하는 속성 \n* worker.print() 동작시 this.run()이 호출한 곳에서 가까운 Worker class의 run funtion이 호출되는게 아니라 **print를 호출한 대상 worker instance에서 가까운 run 함수를 호출하도록 하자 정한 것을 `내적일관성`**이라고 한다.  \n\n## Polymorphism의 장점 \n*  확장된 객체는 원본으로 대체 가능\n*  생성 시점의 타입이 내부에 일관성 있게 참조됨.\n\n## Polymorphism of Prototype\n* javascript prototype, prototype chain을 통해서 `대체가능성`, `내적일관성`을 구현했다.\n* [프로토타입체인 참고](https://happyjy.github.io/prototype/#2-2-프로토타입-체인)\n\n\n## 대체가능성 설명 도식화 \n![](1회/polymorphismOfPrototype1.png)\n![](1회/polymorphismOfPrototype2.png)\n* worker instanceof Worker 설명\n\t- 첫번째 사진에서 HardWorker class instance인자 확인 아니기 때문에 두분째 사진처럼 Worker class instance인지 확인\n\n## 내적일관성 설명 도식화 \n![](1회/polymorphismOfPrototype.png)\n    - 위코드에서 worker.print()가 'hardWorking'이 호출되는 것을 설명 할 수 있다.\n\n## 대체가능성, 내적일관성 설명 도식화 코드로 확인\n```js\n\nworker.__proto__ === HardWorker.prototype;           //true\nworker.__proto__.__proto__ === Worker.prototype;     //true\n\nworker.__proto__.constructor === HardWorker;         //true\nworker.__proto__.__proto__.constructor === Worker;   //true\n\nHardWorker === HardWorker.prototype.constructor;     //true\nWorker === Worker.prototype.constructor;             //true\n\n``` \n\n\n# 객체의 본질이란 ?\n> Maintenance of State(state 관리=> 데이터은닉)  \n> Encapsulation of Functionality(기능의 캡슐화)  \n> Isolation of change(격리)\n\n\n```js\nconst EssentialObject = class {\n    // 데이터은닉(hide state): 내부의 상태를 감춤\n    #name = '';\n    #screen = null;\n\n    constructor(name) { this.#name = name };\n    camouflage(name) { this.#screen = (Math.random() * 10).toString(16).replace('.', '') };\n\n    // 캡슐화(encapsulation): 안에서 무슨 일이 일어나는지 노출하면 안됨\n    get name(){ return this.#screen || this.#name };\n}\n```\n\n## 데이터 은닉(hide State)\n> 내부 상태(데이터)를 감춰야 한다.\n* 객체지향에서 데이터 은닉은 필수(= 상태를 외부에 보여주지 않는다. = private) \n* 객체 지향은 메모리 참조로 움직여야 하는데 속성이 공개되는 순간 속성을 값으로 취득해서 쓰기때문에 value context가 프레임 전체에 관여 -> 객체지향은 무너진다. \n\n\n## 캡슐화(encapsulation)\n> 메소드를 추상화 시켜야 한다.\n* 메소드 안에서 무슨일이 일어나는지 노출하면 안된다(=밖에서는 추상화로 인식해야 한다.)\n    - 예시 ATM에서 돈뽑는 것: 돈달라는 인터페이스만 노출, but 실제로 카드인증, 신용인증, 보안인증 트렌젝션 준비, 확인, 데이터 연산등이 있다. \n* 안좋은예\n    - setAge() 함수가 있다고 하자. 이 함수는 캡슐화가 된게 아니다. 왜냐하면 age 필드를 날로 노출했으니까. 그렇다면 본질적으로 왜 setAge하는지 알아야 한다. **더 생각해서 setAdult setChild 메소드로 만들고 그안에 나이 조건이 있고 이 나이에 따라서 컨텐츠를 구분해야 한다. 이런식으로 더 깊이 생각해야한다.** 이렇게 직접노출하지 않고 기능의 캡슐화가 가능하다 \n\n```\n데이터 은닉, 캡슐화 대상 비교\n* 데이터 은닉: 데이터 대상\n* 캡슐화: 기능 대상 \n```\n\n## Isolation of change\n> 격리: 해당 변화가 일어났을때 그곳에만 변화가 일어나고 다른곳에 여파가 오지 않게 하는 것 \n\n* 소프트웨어는 '당연하게' 요구사항이 계속 변함으로 같이 계속 변한다.\n* 우리는 변화를 막을 수 없기 때문에 Isolation 하는 것이 목표다.\n* 객체지향에서 '변질'을 막고 다른곳으로 퍼지지 못하게 하는것이 이것 밖에 없다.(그래서 본질로 생각한다.)\n\n\n\n# 알려진 기본 설계 요령\n> SOLID원칙  \n> DI(의존성주입), DRY(중복방지), Hollyworld Principle(의존성 부패방지), Law of demeter(최소지식)\n\n## SOLID 원칙 \n* SRP Single Responsibility(단일책임)\n* OCP Open Closed(개방폐쇄)\n* LSP Liskov Substitusion(업캐스팅 안전)\n* ISP Interface Segregation(인터페이스분리)\n* DIP Dependency Inversion(다운캐스팅금지)\n\n### SRP Single Responsibility(단일책임)\n> 수정하는 원인이 하나가 되도록 만드는 것\n* 이를 지키지 못했을때 산탄총 수술(shotgun surgery)가 필요하다 \n* [SRP(SOLID중 1개: Single Responsibility(단일책임))를 준수하는 객체망이 문제를 해결](https://happyjy.github.io/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%94%BC%EC%B8%A0%2086%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%201%ED%9A%8C%EC%B0%A8/#srpsolid%EC%A4%91-1%EA%B0%9C-single-responsibility%EB%8B%A8%EC%9D%BC%EC%B1%85%EC%9E%84%EB%A5%BC-%EC%A4%80%EC%88%98%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%A7%9D%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0)\n\n### OCP Open Closed(개방폐쇄)\n* open\t\n\t- extends, implements를 할 수 있게 만드는 것 \n* closed\n    - 수정이 필요하면 기존 class를 만드는게 아니라 다른 extends, implemtns class를  만들어서 문제를 해결하는 것(=새로운 객체를 만들어서 해결)\n    - 문제의 공통점을 인식해서 추상화에 성공해서 그 다음에도 추상화를 이어 받아서 새로운걸 해결 할 수 있는 것이다. \n\n### LSP Liskov Substitusion(업캐스팅 안전)\n> 추상층의 정의가 너무 구체적이면 구상층 구현에서 모순이 발생\n* 아래 예제1 '추상층'에서 다리로 이동한다. 라는 정의때문에 구상층 '아메바, 독수리, 고래'에서 위배된다. 그래서 예제2를 다시 확인해보자 \n\n[예제1]\n```\n* 추상층 - 생물\n    - 숨을 쉰다. \n    - 다리로 이동한다.\n* 구상층(구현)\n    - 사람, 타조: OK\n    - **아메바, 독수리, 고래: NO**\n```\n\n* 아래 예제2를 보면 추상층을 두개로 나눴다. \n    - 생물 class, 다리이동 interface  \n\t\n[예제2]\n```\n* 추상층 - 생물(숨을 쉰다), 다리이동(다리로 이동한다)\n\n* 구상층(구현)\n    - 사람, 타조: \"생물\", \"다리이동\" -> OK\n    - 아메바, 독수리, 고래: \"생물\" -> OK\n```\n\n### ISP Interface Segregation(인터페이스분리)\n> 위 원칙 LSP가 성림하지 않았기 때문에 ISP(예제1 -> 예제2)작업이 있었다.\n\n* ISP 필요대상 \n\t- 아래 위임, 인터페이스로 해결하는 방법을 소개하겠습니다.\n![](1회/ISP-필요대상.png)\n\n* 위임으로 해결하는 방법  \n![](1회/ISP-위임.png)\n    - 위임(소유): 인터페이스로 분리하지 않고 처리하는 첫번째 옵션\n    - 모듈A, B, C 바라볼 객체를 만들어서 객체별로 A,B,C를 상대하도록 만들어 준다\n\n* 인터페이스로 해결하는 방법  \n![](1회/ISP-interface.png)  \n    - 객체를 만들때 처음부터 인터페이스 A, B, C 세개를 가져와서 인터페이스에 맞게 메소드를 오버라이드한다. \n    - 그래서 외부에서 볼때는 객체를 보는게 아니라, 객체가 구현한 인터페이스를 보게 된다. \n\n### DIP Dependency Inversion(다운캐스팅금지)\n> `의존성 역전`의 법칙이라고도함  \n> 의존성은 언제나 부모쪽으로 흘러야 한다. \n* 다운캐스팅을 안하면 나머지 SOLID원칙이 다 지켜지는것이기 때문에 어려운 항목이다. \n* 고차원의 모듈은 저차원의 모듈에 의존하면 안된다. **이 두 모듈 모두 추상화된것에 의존해야 한다.**\n    - 고차원: extends를 더 많이 한 것(자식 쪽)\n* 추상화 된 것은 구체적인 것에 의존하면 안된다. **구체적인 것이 추상화된 것에 의존해야한다.**\n\n## 기타 \n### DI(Dependency Injection, 의존성주입) \n* IoC(Inversion of control, 제어역전)의 일부, 구현체 중에 하나 \n\n### DRY(Don't Repeat YourSelf)(중복방지)\n\n### Hollyworld Principle(의존성 부패방지)\n* 요구하지 말고 요청 또는 기다려 내가 요청할께 \n* 액션이 처리할 사람이 거꾸로 연락하게 하는 패턴  \n* 은닉화, 캡슐화가 지켜지지 않은 경우\n\n### Law of demeter(최소지식)\n* classA.methodA의 최대지식한계 \n    - classA의 필드 객체\n    - methodA가 생성한 객체\n    - methodA의 인자로 넘어온 객체\n* 이 법칙이 지켜지지 않으면 **열차전복(train wreck)**가 일어난다. \n\n\n# Message\n> 다른객체에게의뢰하는것=다른객체에게메세지를보내는것  \n> 객체지향은 Message를 통해서 문제를 해결한다. \n\n\n## SRP(SOLID중 1개: Single Responsibility(단일책임))를 준수하는 객체망이 문제를 해결\n[SRP Single Responsibility(단일책임)](https://happyjy.github.io/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%94%BC%EC%B8%A0%2086%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%201%ED%9A%8C%EC%B0%A8/#srp-single-responsibility%EB%8B%A8%EC%9D%BC%EC%B1%85%EC%9E%84)\n* 책임이 상세하게 분리 \n\t- 각자의 역할만하고 다른놈에게 넘겨서 문제를 해결  \n\t: 마치 data structure에 linked-list처럼  \n\t: 이것이 객체지향이 문제를 해결하는 방법이다.\n    - 이렇게 문제를 해결하지 않고 쭉 코드를 짜면 수정하는 원인이 한가지가 아니라 여러가지 이다.  \n* 설계라는것은? \n    - 어디까지 나눠야할지 말아야할지 결정하는 것이다. \n    - 변화가 많이 일어나면 더 상세하게 나눠야 한다. \n* **단일 책임 원칙을 준수하는 객체에게 책임 이상의 업무를 부여하면?**\n    1. **만능 객체가 되려한다.** \n    2. **다른 객체에게 의뢰한다.**\n* **Message를 보낸다의 의미**\n    - **다른객체에게의뢰하는것 = 다른객체에게메세지를보내는것**\n\n### 메세지, 오퍼레이션, 메소드 용어 정리 \n1. `메세지`-의뢰할내용\n2. `오퍼레이션` - 메세지를 수신할 객체가 제공하는 서비스 \n    * 오퍼레이터\n        - 메세지를 수신 하는 역할을 한다. \n        - 실제로 잘동하지 않는다. \n        - 대외적으로 공개된 채널로 내부적으로 매핑(`런타임`구성)에 따라서 하나의 메소드를 실행시칸다. \n        - 위 worker.run()을 예를 들어서 생각해보자. \n            - run()이라는 `오퍼레이터`는 Wokrer, HardWorker 둘중 어느것을 수행할지는 worker.run()을 수행할 때 `런타임`이 정해져 어떤 run을 수행할지 정해진다. 이를 `동적바인딩`이라고 한다. 이렇게 javascript는 `prototype`에 의해서 동적 바인딩을 지원한다. \n\t\t\t- [prototype게시글-2 프로토타입 체인](https://happyjy.github.io/prototype/#2-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8)\n3. `메소드` - 오퍼레이션이 연결될 실제 처리기\n\n### 추상클래스, 인터페이스를 상속하게 하는 이유는?\n    - **오퍼레이션, 메소드를 분리해서 런타임에 원하는 애를 바뀌기 위해서**\n    - 결국 **SRP통해서 OCP(SOLID중 1개: Open Closed(개방폐쇄))를 만들어 낸다**\n\n\n# Dependency \n> 의존성은 가장 중요한 격리의 문제\n\n* 우리가 진짜 원하는 얘기\n* 격리가 되지 않는 이유?\n    - **문제가 되고 있는 객체를 의존해서**\n* 설계의 어려운 이유 \n    - SRP(위 대chapter Message-srp)설명할때는 책임을 상세하게 나누라고 했는데 여기서는 난눈 개체가 문제가 생기면 격리가 안되서 문제라고 한다. \n    - 그래서 이 둘(SRP, Dependency)을 고민해서 설계해야 한다.  \n    : 적당하게 의존성을 가지고 있어야한다.  \n* 의존성 다소의 차이\n    * 의존성이 많을때는 객체가 각자의 역할이 정해져있다. \n    * 의존성이 적을때는 한개의 객체가 많은 역할을 수행한다.\n\n## 의존성의 종류 \n> 두가지가 있다. \n> 1. 객체의 생명주기 전체에 걸친의존성 \n> 2. 각 오퍼레이션 실행 시 임시적인 의존성 - 의존(dependency)\n1. **객체의 생명주기 전체**에 걸친의존성 \n    * 상속(extends)\n        - **강력한 의존성으로 부모객체와 합체 된 개념으로 부모의 변화가 있으면 자식의 변화를 감수해야한다.** \n        - 그래서 상속이 안좋다고 하는 이유입니다. \n    * 연관(association)\n        - 필드의 그 객체 타입을 알고 있다. \n        - **예를 들어 A클래스에 B라는 멤버를 생성해서(소유), 생성한 B멤버 클래스는 클래스A인스턴스가 만들고 없어질때까지 B멤버 클래스와 연관이 있는것이다.** \n\n2. 각 **오퍼레이션 실행 시** 임시적인 의존성 \n    * 의존(dependency)\n        * 오퍼레이션 실행시에만 수행된다. \n        * 메소드 단위로만 의존성이 생겼다 없어지고 메소드를 한번도 호출하지 않으면 의존성이 없기도하다.\n\n### 의존성 문제를 해결하기 위해서 우리가 '지향'해야할 방법\n> 상속 -> 연관 -> 의존 단계로 우리는 지향해야 한다. \n* 상속 -> 연관\n    - 상속을 소유로 바꾼는 것 \n* 연관 -> 의존\n    - 연관도 빡시면 **의존 단계에서 연산에서 처리**하지 꼭 필드에서 참조할 객체를 잡아야 하냐에서 시작\n    - 필드가 없다는건 상태가 없다는 것 -> 객체가 없다는건 함수를 쓰라는 것(이것이 `함수형프로그래밍`)\n    \n* 객체지향에서는 연관 -> 의존 단계로 바꾸기 어렵다. 왜? \n    - **객체지향에서는 '상태'를 유지하고 있기 때문** \n        - 수정 여파 규모증가\n        - 수정하기 어려운 구조 생성 -> 순환의존성\n    - **그런데도 객체지향 클래스들도 함수들을 쓰려고 하는 이유가 의존성을 낮추기 위해서다** \n\n### 의존성이 높으면? \n1. 수정 여파 규모증가\n2. 수정하기 어려운 구조 생성\n3. 순환의존성 \n    - A, B 둘 사이 의존성 없다. \n    - A -> C -> D 이렇게 알고 있다.\n    - 그런데 여기서 D -> B를 알게 되면 A가 B를 알게 되는 경우가 생긴다.  \n    : A -> C -> D -> B\n    - 그래서 B를 고쳤는데 A가 문제가 생기는 이유가 된다. \n\n# 객체지향을 배우는 이유\n> `격리구간`을 세우고 `의존성`을 관리하기 위해서  \n>  \t\t- 의존성은 `변화에 대한 격리를 위해서`관리한다\n\n* 위 쳅터 \"Message-SRP\", \"Dependency\"에서 설명\n\n# Dependency Inversion\n> [DIP Dependency Inversion(다운캐스팅금지)](https://happyjy.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_1/#dip-dependency-inversion%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85%EA%B8%88%EC%A7%80)\n\n* Polymorphism\n> 어떠한 경우에도 다운캐스팅은 금지  \n> 폴리모피즘(추상인터페이스) 사용\n\n```js\nconst Worker = class{ \n    run(){ console.log(\"working\") }\n    print(){ this.run(); } \n};\nconst HardWorker = class extends Worker{ \n    run(){ console.log(\"hardWorking\") }\n};\n\nconst Manager = class { \n    #workers; \n    constructor(...workers) {\n        if(workers.every(w=>w instanceof Worker)) this.#workers = workers;\n        else throw \"invalid workers\"; \n    }\n    doWork(){ this.#workers.forEach(w=>w.run()) }; \n};\n\nconst manager = new Manager(new Worker(), new HardWorker()); \nmanager.doWork();\n```\n\n* **아래 나오는 다음 3가지 설명으로 OCP, DIP를 통해서 객체지향을 느끼는 초석을 다지는데 좋은 설명이였다.**\n    - \"OCP를 위 예제 코드를 통해 설명\", \"DIP(의존성 역전의 법칙)를 위 예제 코드를 통해 설명\", \"Manager class 기준으로 OCP, DIP를 설명\" \n    \n1. OCP를 위 예제 코드를 통해 설명 \n    * **worker 사상 검증시 Worker class기준으로 했다.** 이 의미는 HardWorker는 추상클래스로 본것이다.(폴리모피즘을 이용해서 대체가능성을 이용해서 추상클래스로 본것이다.) 하위 클래스를 인식하지 않음으로써 더 많은 하위 클래스 xxxWorker만들어도 Worker패밀리리면 다 받아준다는 의미이다. 그래서 Worker클래스를 확장해서 xxxWorker 클래스들을 많들어도 된다. \n        - 그래서 Manager class constructor에서 workers 사상검증시(instanceof 키워드를 통해서)Worker를 기준으로하고 있다.\n        - Worker 클래스를 확장한 xxxWorker 클래스들을 Manager class constructor에서 검증할때 constructor를 변경할 필요가 있을까? -> NO\n        - worker로 부터 더 많은 extention을 만들 수 있따 -> ***\"Open extend\"(확장이 열려있다)***\n        - 그럼에도 불구하고 Manager class constructor를 수정할 필요가 없다 -> ***변화에 \"Closed\"***\n    * OCP를 달성하면 자연스럽게 **의존성 역전**이 달성된다. \n\n2. DIP(의존성 역전의 법칙)를 위 예제 코드를 통해 설명\n    - Manager class constructor에서 의존성을 무엇으로 가지고 있는가? \n        - ***구상클래스(Hardworker) 가지고 있지 않고 추상클래스(Worker)로 가지고 있다.*** \n    - 그래서 Manager class에 doWork 함수에서는 run이 사용될 수 있는것인가? \n        - 추상클래스(Worker)에 run 함수가 있기 때문이다.\n        - 왜냐하면 Manager class contsructor에서 Worker 클래스로 사상검증 했기 때문이다. \n\n3. Manager class 기준으로 OCP, DIP를 설명\n    - constructor에서 `OCP`를 표현하고 싶고 Worker class level에서 instance를 인식할 것이니까 Manager class에서는 Worker level의 메서드를 쓸것이다.(`DIP`) 라고 해석 할수 있다. (HardWorker의 함수를 사용하지 않는다.)\n\n* OCP가 안되면 DIP가 될 수 없다.(OCP, DIP는 깊은 연관을 가지고 있다.)\n\n\n# Inversion of Control\n> 객체지향에서 가장 마지막으로 도달해야 할 지점   \n> DIP 조차도 IOC의 재료   \n> IOC에 도달하면 객체지향에 도달했다고 생각해도된다.   \n\n## **Inversion의 쉬운 설명**\n* 제어를 안한다는 의미가 아니라 **내가 직접하지 않고 위임 하겠다 라는 의미**\n* <u>예를 들어 내가 운전을 못하지만 운전잘하는 사람의 차를 타면 밖에서 볼때 운전 잘하는 사람? 으로 보일 것이다. 오 이게 Inversion of Driving...이라고 말할 수 있겠네...😅</u>\n    - [IOC 참고 설명 - lib, fw와 같이 설명/ IOC, DI, DIP](https://black-jin0427.tistory.com/194)\n    - [IOC 참고 설명 - 코드](https://stackoverflow.com/questions/3058/what-is-inversion-of-control)\n    - [IOC 참고 설명 - drving](https://www.tutorialsteacher.com/ioc/inversion-of-control)\n\n## 제어역전의 개념과 필요성\n    1. Control = flow control(흐름제어) \n    2. 광의에서흐름제어 = 프로그램실행통제 \n    3. 동기흐름제어, 비동기 흐름제어 등\n\n## 문제점\n> 동적알고리즘(Dynamic Programing)에서 iterator를 돌면서 조건이 바뀌기 때문에 흐름제어가 어렵다. \n    1. 흐름 제어는 상태와 결합하여 진행\n    2. 상태 통제와 흐름제어 = 알고리즘\n    3. 변화에 취약하고 구현하기도 어려움\n        - 제어문이 많아질수록 유지 보수가 어렵다.  \n\n## 대안\n    1. 제어를 추상화하고\n        - 일반화라는 관점이 필요\n        - 제어들을 모으려면 공통된 부분, 다른 부분을 filter하는 게 필요하다. (`연역적추리`)\n        - 연역적 추리가 되면 원리를 뽑아내서 `귀납적 상황`을 만들어서 연역적 내용들을 모두 처리 할 수 있게 된다. \n        - 귀납적추리, 연역적추리\n            - 귀납적추리(Indcution): 원리를 가지고 현상을 예측하는 것\n            - 연역적추리(Deduction): 현상으로 원리를 깨닫는 것 \n    2. 개별 제어의 차이점만 외부에서 주입받는다.\n\n\n# 예제 소스 \n```js\n// POINT1\n// Renderer: base element에 view가 주는 element를 집어 넣어서 그림을 그리는 녀석 \nconst Renderer = class {\n    #view = null;\n    #base = null;\n    \n    constructor (baseElement) {\n        this.#base = baseElement;\n    }\n    set view (v) {\n        if(v instanceof View) this.#view = v;\n        else throw `invalid view: ${v}`;\n    }\n    render (data) {\n        const base = this.#base;\n        const view = this.#view;\n\n        if(!base || !view) throw 'no base or no view';\n        let target = base.firstElementChild;\n        //POINT2\n        //base안 element를 제거한다. \n        do base.removeChild(target);\n        while (target = target.nextElementSibling);\n        //POINT3\n        //view.getElement은 render function에 의해서 받은 data에 합당한 el을 반환 \n        //아래 renderer.view에 상속받아 구현함.\n        base.appendChild(view.getElement(data));\n        view.initAni();     //애니메이션 초기화 \n        view.startAni();    //애니메이션 시작해\n    }\n}\n\nconst View = class {\n    getElement (data) { throw `override!` };\n    initAni () { throw 'override!' };\n    startAni () { throw 'override!' };\n}\n\n//특정뷰를 받아서 그리는 역할 \nconst renderer = new Renderer(document.body)\n//POINT4\n//* new class extends View\n//  :익명클래스처럼 view를 상속받는 class를 하나 만들고 인스턴스를 만드는 코드 \nrenderer.view = new class extends View {\n    #el\n    //POINT5\n    //data에 의해서 받은 데이터로 dom을 생성해 본인(View를 상속받은 class)필드 '#el'에 집어 넣고 반환 \n    getElement (data) {\n        this.#el = document.createElement('div');\n        this.#el.innerHTML = `<h2>${data.title}</h2><p>${data.description}</p>`;\n        this.#el.style.cssText = `width:100%;background:${data.background}`\n        return this.#el;\n    }\n    initAni () {\n        const style = this.#el.style;\n        style.marginLeft = '100%';  //화면 밖 오른족으로 쭉 밀어버린다.\n        style.transition = 'all 0.3s';  //0.3이후에 오라고 transition 검 \n    }\n    startAni () {\n        //한프레임 건너뛰고 람다에서 style에 margin 0을 넣는건 마진 100%에서 왼쪽으로 쫚들어온다.\n        requestAnimationFrame(() => this.#el.style.marginLeft = 0);\n    }\n\n    \n}\n\nrenderer.render({ title:\"title test\", description:\"contents.......\", background:\"#ffffaa\"});\n```\n\n## 핵심1: Renderer, View Class 설명\n* Renderer class render 함수 레시피가 개별 View마다 만들어지지 않고 render에만 집중되어 있다. \n* Renderer class render 함수 레시피가 바로 제어문!\n    * 어떤 제어냐? \n        - 내용을 지우고 새로운 객체를 만들어서 내 자신을 만들어서 애니메이션을 처리 할꺼야 라는 레시피가 render안에 있다. \n        (== 제어문이 이 안에 있다라는 의미)\n* 그럼 이제 모든 뷰를 만들어 낼때 제어는 Renderer class의 render가 하고 제어에 해당하는 각각 부속물을 공급하는 역할을 view객체를 공급해주면 된다. \n* 그러면 앞으로 모든 뷰를 등장시킬때 render작업을 두번다시 할까? \n    - 안한다!    \n* Renderer class render 함수는 data에 맞는 view를 그리고 있다. \n\t- 그리고 제어부분이 집중되어 있고 개별뷰(set view)에는 제어부분이 없어진다. \n\t- 개별뷰(set view)에 있는 제어문은 render쪽에 모여 있다. \n* view가 가져야 할 제어를 render쪽으로 역전시켜서 한군데에만 있는 제어를 사용하고 이 제어에 부속(Veiw)으로써가 개별 공급해야할 내용들만 공급해준다는 의미\n* **제어의 역전**이 일어나고 있다.\n\t- <u>\"내가 view를 여러번 만들다 보니 계속 반복되는 내용을 render에다가 몰아 넣고 view는 필요한 부품만 render에 몰아 넣으면 될것 같다.\"라고 판단해 만든것이 Render class에 set view, render와 같다.</u>\n* **제어의 역전이 일어나니 \"의존성 역전\"(추상클래스를 받으니까)이 일어나고 \"OCP\"도 자동** \n\n\n## 핵심2: renderer.view객체 (View를 상속받은 instance 객체)\n* 뷰에대한 애니메이션 초기화와 애니메이션 동작은 각각 view에 대한 클래스에서 책임지고 있다. \n    - 전체적인 흐름은 Renderer class의 render가 한다. \n* 제어 역전에 들어가는 부속들은 일부 부속들(renderer.view가 가지고 있는 instance의 getElement, initAni, startAni)거기에 대한 일부 재료들만 제공만하고 실제 제어 부분은 빠지게 된다. 제어를다 중앙(Render class에 render)\n* 그래서 우리가 애니메이션 절차에 대해서 수정하고 싶으면 Render class의 render만 수정하면 된다. \n\n## 핵심3: 제어역전 코드(Renderer class의 render) & 제어역전에 대한 설명\n* Render class의 render쪽에 제어가 몰려 있고 공급되는 View들은 일부만 공급하게 된다 \n* 제어부분이 마음에 아니들면 renderer에서만 계속 고치면된다. 다른 애들은 '제어'에 대한 책임이 해제된다. 그래서 제어에 대한 부속(getElement, initAni, startAni)에만 관심을 갖게 되고 실제 제어는 renderer class의 render가 가져간다. \n* 스프링 프레임워크도 \"제어의역전\"을 사용하고 있다. 큰 프레임워크를 사용할때 사용하는 객체들은 controller들을 모은다. 그리고 web application이 움직이는건 '제어의역전'프레임워크가 해주는것이다. \n    - 제어의 역전의 의미\n    : 누군가 router태워서 필요한 컨트롤에 로딩해서 컨트롤에서 모델받아서 매칭되어 있는 뷰를 뿌려주는 이 과정 \n\n* 프레임워크, 라이브러리 차이 \n    - 프레임워크: 제어 역전이 있다.(IOC가 되어야 프레임워크가되는것이다)\n    - 라이브러리: 제어에 대한 책임 없음\n\n* IOC가 되어야 프레임워크는 받는 뷰를 요구한다.\n    - 나의 lifeCycle, 나의 미리 상속되어 있는 메소드들 일부만 구현에서 나에게 주기만하면 이를 제어해줄게이게 IOC 프레임워크이다. \n* 안드로이드 앱을 만들때 activity를 만들어야 하고 이 activity가 할수 있는 건 os에서 지정해놓은 메소드들만 구현한것이고 언제태어나고, 언제 만들어지고, 언제 앱이 뜨는지는 OS가 한다  \n\n\n# 제어역전 실제 구현\n\n* `전략패턴 & 템플릿 메소드 패턴` < `컴포지트 패턴` < `비지터 패턴` \n    - 오늘쪽으로 갈수록 넓은 범위의 제어 역전을 실현함\n    - 가장 소극전인 제어역전을 구현하고 있는 패턴은?   \n    : `전략패턴 & 템플릿 메소드 패턴` \n        - 전략패턴: 소유를 통한 제어의 역전 \n        - 템플릿메소드패턴: 상속을 통한 제어의 역전\n    - 위 예제 Renderer class는 `비지터 패턴`이다.\n\n## 추상팩토리 메소드 패턴\n* `비지터패턴`(위 예제 Renderer class)은 이미 만들어진 객체의 행위를 제어역전에 참여시킬 수 있지만 참여 할 객체 자체(View class)를 생성할 수 없음. 참여할 객체를 상황에 맞게 생성하고 행위까지 위임하기 위해 `추상팩토리 메소드 패턴`을 사용함.\n* 예를 들어 \n내가 피벗 테이블을 만들때 중간에 그래프, 플러그인이 끼워져 있으면 이것을 중간에 만들면서 셀을 만들고 싶다. 이미 주어져 있는 객체를 메소드 호출해서 만드는게 아니라 중간에 만들면서 끼워 넣고 싶다. 이렇게 만드려면 만들어주는 팩토리가 필요 \n* 그래서 `추상팩토리 메소드 패턴`은 `비지터 패턴`과 결함한다. \n    - 만드는것만 제공하는게 아니라 만들어진 메소드도 호출 가능하다 \n    - 그래서 `제어역전`을 구현하게 되면 `추상팩토리 메소드 패턴`을 사용 가능하게 되는 것이다. \n\n\n# 마무리 \n* 이번에 등장한 모든 디자인패턴들은 모두 `제어역전패턴`과 관련된 패턴이다.\n* 객체지향에서 `제어역전`을 궁극적으로 목표로 삼는 이유는 많은 버그를 제어문이 가지고 있어 제어를 한군데에서 하기 위함이다. \n* 앞으로 이어지는 4개의 강의는 샘플앱을 만들고 점진적으로 발전시켜가면서 제어역전, SOLID이 지켜지는지 확인하며 refactoring하고 기능을 붙여나갈 예정 \n","excerpt":"INTRO 목표 객체 지향을 자바스크립트로 해보자. 디자인 패턴과 함께 알아보자. 오늘 배운 이론 남은 4개 강의에서 활용. SOLID(SRP, OCP, LSP, ISP, DIP) Message, 의존성, DI, IOC,  Value Context…","fields":{"slug":"/OOPWithJavascript_1/"},"frontmatter":{"date":"Feb 23, 2020","title":"객체지향 자바스크립트 1회차(객체지향이란? with design Pattern)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n\nsetTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래 3개를 직접 그리며 개념을 정리했다.\n\n\n# 이벤트 루프 설명 시 주요 용어\n    - 호출스택\n    - 백그라운드\n    - 테스크큐\n    - 이벤트 루프\n\n# 이벤트 루프 설명 예시\n```js\n\nconsole.log('Hi');\n\nsetTimeout(function(){\n    console.log('CB');\n}, 3000)\n\nconsole.log('bye');\n\n```\n* 위 코드 결과는 Hi, bye, CB 순서로 로그가 남게 된다. 아래 설명을 참고\n* 만약 setTimeout이 0초로 설정하게 된다면 로그는 어떻게 출력이 될지 아래 설명을 보면서 생각해보자 \n\n## 이벤트 루프 예시 도식화/ 설명\n![](eventLoop1.jpg)\n* 상태 \n    - console.log('Hi')가 수행되어 콘솔에 찍히고 `호출스택`에서 빠진 상태\n* 설명\n    1. setTimeout이 수행되어 setTimeout callback function이 `백그라운드`로 이동된 상태\n    2. setTimeout callback function이 `백그라운드`로 이동\n    3. 3초후에 setTimeout callbakc function이 수행 되도록 설정 되어 있기 때문에 3초 이후 `태스크 큐`로 이동\n\n![](eventLoop2.jpg)\n\n* 설명\n    4. `호출 스택`실행이 끝나면 \n    5. `이벤트루프`는 태스크 큐의 callback function을 `호출 스택`으로 올린다.\n\n![](eventLoop3.jpg)\n* 설명  \n    6. run(setTimeout callback function)이 `호출 스택`에서 실행 되고 비워지게 된다.  \n    7. `이벤트루프`는 `태스크 큐`에 callback function이 들어올 때까지 대기\n\n\n# 추가 설명\n* setTimeout 0초는 4ms 지연 시간을 갖고 있어 hi, bye, CB 순서대로 로그가 남게 된다.\n* 백그라운드에서 3초를 설정했음에도 3초 후에 실행되지 않는경우 \n    - 호출 스택에서 많은 일을 하게 되면 이벤트루프가 태스크 큐에 쌓이 콜백함수들을 호출스택으로 끌어 올리지 못하기 때문\n* 백그라운드 사용하는 작업\n    - setTimeout, setInterval\n    - ajax 요청\n    - event Listener  \n        : 참고  http://latentflip.com/loupe/\n    - File Reader\n    - Javascript 기본제공 메소드 중 콜백 함수를 사용하는 메소드는 백그라운드를 사용하는 경우가 많다.\n\n# 참고 \n* 1. 제로초\n* 2. JSConf\n    - https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title","excerpt":"setTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래…","fields":{"slug":"/eventLoop/"},"frontmatter":{"date":"Feb 16, 2020","title":"eventLoop","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n* javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다.\n\n```\n목차 \n# excutor: promise\n# 소비자: then, catch, finally\n# 예시: loadScript\n```\n\n# excutor: promise\n\n```js\nvar promise = new Promise(function(resolve, reject) {\n    // executor (제작 코드, \"가수\")\n});\n```\n- excutor는 아래 콜백 중 하나를 반드시 호출해야 합니다. \n    - resolve(value): 성공적으로 끝난 경우 결과를 value param으로 전달하며 resolve 호출\n    - reject(error): 에러 발생시 에러 객체를 error param으로 전달하며 reject 호출\n\n* new Promise(executor)의 callback 'resolve(value)', 'reject(error)'의 state, result 상태 \n* new Promise 생성자가 반환하는 promise 객체는 다음과 같은 내부 프로퍼티를 갖습니다.\n    - state: 처음엔 \"pending\"(보류)이었다 resolve가 호출되면 \"fulfilled\", reject가 호출되면 \"rejected\"로 변합니다.\n    - result: 처음엔 undefined이었다, resolve(value)가 호출되면 value로, reject(error)가 호출되면 error로 변합니다.\n\n\n* 성공일때 예제(resolve) \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 프라미스가 만들어질 때 executor 함수는 자동으로 실행됩니다.\n\n        // 1초 뒤에 일이 성공적으로 끝났다는 신호와 함께, result가 'done'이 됩니다.\n        setTimeout(() => resolve(\"done\"), 1000);\n    });\n    ```\n\n* 실패일때 예제(reject)\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 1초 뒤에 에러와 함께 실행이 종료되었다는 신호를 보냅니다.\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    ```\n\n* resolve/reject 함수 호출 규칙\n    - excutor에 의해서 끝난일은 resolve, reject중 첫번째로 오는 것만 수행됩니다.\n    - 나머지는 무시\n    \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      resolve(\"done\");\n\n      reject(new Error(\"…\")); // 무시됨\n      setTimeout(() => resolve(\"…\")); // 무시됨\n    });\n    ```\n\n\n# 소비자: then, catch, finally\n> 프라미스 객체는 executor(‘제작 코드’ 혹은 ‘가수’)와 결과나 에러를 받을 소비 함수(‘팬’)를 이어주는 역할을 합니다. 소비함수는 .then, .catch, .finally 메서드를 사용해 등록(구독)됩니다.\n\n\n## then\n> excutor가 성공, 실패 한경우를 모두 handling 할 수 있다. \n> then parameter에 두개를 전달해줄 수 있는데 첫번째는 param에 성공 handling function, 두번째는 param에 실패 hanlding function을 전달할 수 있다.\n\n* excutor가 성공적으로 수행한 경우\n    - POINT 주석 참고\n\n        ```js\n        var promise = new Promise(function(resolve, reject) {\n        setTimeout(() => resolve(\"done!\"), 1000);\n        });\n\n        // POINT: resolve 함수는 .then의 첫 번째 함수(인수)를 실행합니다.\n        promise.then(\n            result => alert(result), // 1초 후 \"done!\"을 출력      \n            error => alert(error) // 실행되지 않음\n        );\n        ```\n    - 아래 와 같이 성공했을때는 작성 가능하다 \n        - then function에 parameter 한개만 전달해주면 된다.\n            \n            ```js\n            var promise = new Promise(resolve => {\n                setTimeout(() => resolve(\"done!\"), 1000);\n            });\n\n            promise.then(alert); // 1초 뒤 \"done!\" 출력\n            ```\n\n* excutor가 에러로 필해한 경우\n    - POINT 주석 참고\n        \n        ```js\n        var promise = new Promise(function(resolve, reject) {\n            setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n        });\n\n        // POINT: reject 함수는 .then의 두 번째 함수를 실행합니다.\n        promise.then(\n            result => alert(result), // 실행되지 않음\n            error => alert(error) // 1초 후 \"Error: 에러 발생!\"를 출력\n        );\n        ```\n\n\n## catch\n> excutor 수행 결과 중 error만 다루고 싶을 때 사용\n\n* 예시\n    - POINT 주석 참고\n    - .catch(f)는 문법이 간결하다는 점만 빼고 .then(null,f)과 완벽하게 동일\n    \n        ```js\n        var promise = new Promise((resolve, reject) => {\n            setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n        });\n\n        // POINT\n        // .catch(f)는 promise.then(null, f)과 동일하게 작동합니다\n        promise.catch(alert); // 1초 뒤 \"Error: 에러 발생!\" 출력\n        ```\n\n## finally\n> try... catch에 finally가 있는 것 처럼 promise에도 finally가 있다.\n\n\n* finally 예1  \n    : finally 이후 then을 통해 resolve 결과를 then으로 전달\n    ```js\n    new Promise((resolve, reject) => {\n        setTimeout(() => resolve(\"result\"), 2000)\n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .then(result => alert(result)); // <-- .then에서 result를 다룸\n    ```\n\n* finally 예2  \n    : finally 이후 cath를 통해 \n    ```js\n    new Promise((resolve, reject) => {\n        throw new Error(\"에러 발생!\");\n        // setTimeout(()=>{ reject(new Error('error'))}, 1000); // excutor 처리 시점만 조금 다르고 같은 결과 \n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .catch(err => alert(err)); // <-- .catch에서 에러 객체를 다룸\n    ```\n\n# 예시: loadScript\n* callback에서 loadScript 설명에서 callback hell을 해결 할 수 있는 방법이 promise라고 했는데 그 방법을 소개하겠다.\n\n* promise로 구현한 loadScript\n    ```js\n    function loadScript(src) {\n        return new Promise(function(resolve, reject) {\n            var script = document.createElement('script');\n            script.src = src;\n\n            script.onload = () => resolve(script);\n            script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));\n\n            document.head.append(script);\n        });\n    }\n    ```\n\n* 사용 방법\n    ```js\n    var promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\n    promise.then(\n        script => alert(`${script.src}을 불러왔습니다!`),\n        error => alert(`Error: ${error.message}`)\n    );\n\n    promise.then(script => alert('또다른 핸들러...'));\n    ```    \n    - 설명\n        - loadScript(script)로 스크립트를 읽고, 결과에 따라 그다음(.then)에 무엇을 할지에 대한 코드를 작성하면 되죠.\n    - 비교 \n        - 콜백으로 구현시에 loadScript(script, callback)를 호출할 때, 함께 호출할 callback 함수가 준비되어 있어야 합니다.  \n          loadScript를 호출하기 이전에 호출 결과로 무엇을 할지 미리 알고 있어야 했다.\n    \n\n# 참고 \n- Javascript.info  \nhttps://javascript.info/promise-basics\n","excerpt":"javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다. excutor…","fields":{"slug":"/2_Promise/"},"frontmatter":{"date":"Feb 16, 2020","title":"Promise","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n\n예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source를 사용하려면 당연히 사용 할수 없습니다.  \n(**스크립트 읽기가 지금 당장 시작되더라도 실행은 함수가 종료되고 난 후에야 실행되므로 스크립트는 ‘비동기적으로’ 실행되었다고 할 수 있습니다.**)\n\n이렇게 비동기 적으로 실행되고 있는 문제를 해결하기위해서 callback기반 비동기 프로그램 방법으로 해결 할 수 있습니다.  \n(**무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공** -> script load를 보장 하는 loadScript function capter)\n\n하지만 callback기반 비동기 프로그램은 callback hell이라는 단점이 있고 이런 문제를 해결 할 수 있는 방법이 'promise, Async & awiat'개념이 있습니다. -> callback hell capter\n\n\n\n# callback function \n## script load를 보장 할 수 없는 loadScript function\n* document객체에 생성한 script객체를 추가해주면 추가한 script 주소를 통해서 원하는 파일을 받을 수 있다.\n* `loadScript` 구현\n    ```js\n    function loadScript(src) {\n        // creates a <script> tag and append it to the page\n        // this causes the script with given src to start loading and run when complete\n        var script = document.createElement('script');\n        script.src = src;\n        document.head.append(script);\n    }\n    ```\n\n    ```js\n    loadScript('/my/script.js'); // the script has \"function newFunction() {…}\n    newFunction(); // no such function!\n    ````\n* sciprt.js에 newFunction() 이 있다고 하자 loadScript를 통해서 받은 script.js파일에 선언한 newFunction()을 호출 하면 호출하지 못 한다.\n* 이유는 브라우저가 script.js 파일을 받기 전에 newFunction을 호출 했기 때문이다.\n* 그래서 **파일을 받고 function을 호출 시키는 보장해주는 코드를 추가 해야한다.**\n\n## script load를 보장 하는 loadScript function\n* 위 load를 보장하지 못하는 코드와 달라진점은 `callback` function 을 parameter로 전달해주고 loadScript는 전달 받은 param을 script onload property에 추가해줬다.\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(script);   // 기능 개선한 부분\n\n        document.head.append(script);\n    }\n    ```\n\n### script laod를 보장하는 예제\n* load를 보장하는 기능이 개선 된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n        script.onload = () => callback(script);       //POINT\n        document.head.append(script);\n    }\n\n    loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n        console.log(`Cool, the script ${script.src} is loaded`);\n        console.log( _ ); // function declared in the loaded script\n    });\n    ```\n* 결과 \n    - loadScript callback function을 확인해보면 콘솔 로그가 두개 있는데. script.src에 추가한 loadScript 첫번째 param loadash cdn 주소를 포함한 문자열과 load한 lodash lib의 _ 객체를 확인 할 수 있다.\n    - **callback function은 받고 싶은 파일을 로드한뒤 사용할 수 있는 공간이다.**(loadScript callback callback function으로 넘어 갔기 때문)\n\n* 정리 \n    - **이런 방식을 `콜백 기반(callback-based)` 비동기 프로그래밍이라고 합니다. 무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공해야 합니다.**\n\n# callback in callback \n* 위 예제 처럼 callback으로 하나의 파일만 로드할 뿐만 아니라 여러개도 load하고 싶을 것이다. \n* 아래 예제와 같이 구현 할 수 있을 것이다.\n    ```js\n    loadScript('/my/script.js', function(script) {\n\n        loadScript('/my/script2.js', function(script) {\n\n            loadScript('/my/script3.js', function(script) {\n            // ...continue after all scripts are loaded\n            });\n\n        })\n\n    });\n    ```\n\n# Handling errors \n* error 처리를 할 수 있는 기능이 개선된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(null, script);\n        script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n        document.head.append(script);\n    }\n    ```\n* 에러 처리 기능이 개선된 laodScript 를 사용하는 방법\n    - callback function에 2개의 param을 설정한다.\n        - 첫번째 parameter: error 객체\n        - 두번째 parameter: loadScript로 받고 싶은 script src string 객체\n    ```js\n    loadScript('/my/script.js', function(error, script) {\n                if (error) {\n                    // handle error\n                } else {\n                    // script loaded successfully\n                }\n    });\n    ```\n\n# callback hell\n* callback을 사용해서 비동기 처리가 유용해보인다. 하지만 callback in callback capter에서 확인해볼 떄 callback 안에 callback을 사용함으로 아래 코드와 같이 가독성이 떨어지는 결과를 가지고 옵니다.\n\n* callback hell 예제\n    ```js\n    loadScript('1.js', function(error, script) {        // 첫번째 callback\n\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', function(error, script) {    // 두번째 callback\n                if (error) {\n                    handleError(error);\n                } else {\n                    // ...\n                    loadScript('3.js', function(error, script) {    // 세번째 callback\n                        if (error) {\n                            handleError(error);\n                        } else {\n                            // ...continue after all scripts are loaded (*)\n                        }\n                    });\n\n                }\n            })\n        }\n    });\n    ```\n\n* 이를 해결하기 위해서 아래와 같이 **중첩하는 callback function**으로 callback hell을 만들지 않고 function을 top-level로 나눠 조금더 가독성이 쉽게 구현 할 수 있습니다. \n    ```js\n    loadScript('1.js', step1);\n\n    function step1(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', step2);\n        }\n    }\n\n    function step2(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('3.js', step3);\n        }\n    }\n\n    function step3(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...continue after all scripts are loaded (*)\n        }\n    };\n    ```\n* 하지만 step1, 2, 3과 같은 function은 연쇄 작용하는 코드 밖에서 사용할 수 없는 단점이 있습니다. 그래서 이런 점과 callback hell을 피할 수 있는 \"promise, Asynch/await\" 개념을 정리해보겠습니다.\n\n\n# 참고 \n- Javascript.info  \nhttps://javascript.info/callbacks#callback-in-callback","excerpt":"예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source…","fields":{"slug":"/1_callback/"},"frontmatter":{"date":"Feb 16, 2020","title":"callback","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\npromise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다.\n\n# promise chaing 방법 두가지 \n## promise chaining 첫번째 방법(1/2)\n\n* promise객체의 하나에 then을 여러개 연속으로 연결해서 사용하는 방법으로 사슬고리처럼 연결되어 있어 다음 then에 value를 넘겨 줄 수 있습니다.\n    ```js\n        new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000); // (*)\n        }).then(function(result) { // (**)\n            alert(result); // 1\n            return result * 2;\n        }).then(function(result) { // (***)\n            alert(result); // 2\n            return result * 2;\n        }).then(function(result) {\n            alert(result); // 4\n            return result * 2;\n        });\n    ```\n\n\n## promise chaining 두번째 방법(1/2)\n* then을 선언할때마다 promise를 사용해서 선언하게 되면 모든 선언한 then에 pomise의 결과가 전달이 됩니다.\n    ```js\n        var promise = new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000);\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n    ```\n\n# 프로미스 반환하기 \n* 아래 예제 설명 \n    - 예시에서 첫 번째 .then은 1을 출력하고 new Promise(…)를 반환((*))합니다.  \n    - 1초 후 이 프라미스가 이행되고 그 결과(resolve의 인수인 result * 2)는 두 번째 .then으로 전달됩니다. \n    - 두 번째 핸들러((**))는 2를 출력하고 동일한 과정을 반복합니다.\n* **프라미스를 반환하는 것도 비동기 작업 체인을 만들 수 있다.**\n\n    ```js\n    new Promise(function(resolve, reject) {\n        setTimeout(() => resolve(1), 1000);\n    }).then(function(result) {\n        alert(result); // 1\n        return new Promise((resolve, reject) => { // (*)\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) { // (**)\n        alert(result); // 2\n        return new Promise((resolve, reject) => {\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) {\n        alert(result); // 4\n    });\n    ```\n\n# 예제: loadScript callback function 해결하기 \n\n    ```js\n    loadScript(\"/article/promise-chaining/one.js\")\n        .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n        .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n        .then(script => {\n            // 스크립트를 정상적으로 불러왔기 때문에, 스크립트 내의 함수를 호출할 수 있습니다.\n            one();      //...one.js에 있는 function \n            two();      //...two.js에 있는 function \n            three();    //...three.js에 있는 function\n        });\n    ```\n\n# fetch와 함께 체이닝 함께 응용하기 \n\n* 프론트 단에선, 네트워크 요청 시 프라미스를 자주 사용합니다. \n* 예시에선 메서드 fetch를 사용해 원격 서버에서 사용자 정보를 가져오겠습니다. \n* fetch는 promise객체를 반환 하기 때문에 fetch로 원하는 정보를 가지고 오고 promise에서 설명한 것 처럼 then을 통해서 후처리를 할 수 있습니다.\n\n    ```js\n    fetch('/article/promise-chaining/user.json')\n        // 원격 서버가 응답하면 .then 아래 코드가 실행됩니다.\n        .then(function(response) {\n            // response.text()는 응답 텍스트 전체가 다운로드되면\n            // 응답 텍스트를 새로운 이행 프라미스를 만들고, 이를 반환합니다.\n            return response.text();\n        })\n        .then(function(text) {\n            // 원격에서 받아온 파일의 내용\n            alert(text); // {\"name\": \"iliakan\", isAdmin: true}\n        });\n    ````\n\n# 참고 \n- Javascript.info  \nhttps://javascript.info/promise-chaining","excerpt":"promise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다. promise chaing 방법 두가지 promise chaining 첫번째 방법(1/2) promise객체의 하나에 then…","fields":{"slug":"/3_Promise chaning/"},"frontmatter":{"date":"Feb 16, 2020","title":"Promise chaning","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# 개발자로 어떻게 살 것인가? \n > 2020년 2월 4년 3개월차 개발자의 고민 작성 \n\n* 개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년 8개월이 지났다. 늦게 시작한 만큼 효율적으로 **목적을 정해두고 목표를 세워 시간을 만회하고 싶어** 작성하기 시작했다.\n\n\n\n# 목적 \n> fw/lib 익혀 비즈니스 개발에만 그치지 않고 CTO 성향을 가진 개발자  \n> 인문학도 공부하며 커뮤니케이션에 원활한 사람  \n> 사회/정치에도 관심을 두면서 개발자로서 그사이에 내가 해야 할 일을 고민하기  \n\n* FW/LIB 익혀 비즈니스 개발에 그치지 않고 원리를 알고 개발하며 나아가 **'설계, 성능, 보안, 설계에 관심을 두고, product level로 만들 수 있는 능력, 문제가 있을때 어디가 통찰력 있게 해결할 수 있는 능력, 지식 습득을 교양을 쌓는다고 여기며 꾸준하게** 할 수 있는 개발자가 되고 싶다. \n\n* 위 능력을 갖추면서 \"이슈\"가 생겼을 때 **먼저 나서서** 처리 할 수 있는 능력을 갖추고 싶다.\n\n\n# 목표 \n> 지속적으로 작성 계획\n\n## javascript개념을 정리하게된 계기\n* 그동안 공부해온 것을 정리하고 그다음으로 넘어가고 싶었다. \n    한 언어를 깊게 공부하고 싶었다. \n    - 이유는   \n    : 다른 언어를 배우더라도 내가 아는 개념과 뭐가 다르고 같은지 비교/생각해가며 공부하면 더 재밌고 수월할 것 같다고 생각했기 때문이다.  \n    : react, node를 사용해 toy project를 진행하며 Javascript를 느낄 수 있을 정도로 알고 싶었다.  \n    : 이슈 해결을 수월하고 더 재미있는 개발, 더 좋은 퍼포먼스를 낼 수 있을 거라고 느꼈다.\n    : Javascript를 정리해야 그다음 단계(설계, lib, fw)로 넘어갈 수 있는 자격이 주어지는 거라고 스스로 생각해서 꼭 해야겠다고 생각했다.\n\n## 그래서 그다음단계는? \n* 코드스피츠에서 front-end 관련해서 design pattern과 view Pattern을 정리/ project 완료하기  \n* react, node로 toy project 한 것 정리/ 확장\n    - 사용한 기술 정리를 통해서 공식 라이브러리 확인하기\n    - 스스로 개발지식을 습득하고 적용하는 연습\n* 알고리즘 문제를 풀면서 생각하는 연습을 지속해서 연습\n\n","excerpt":"개발자로 어떻게 살 것인가? 2020년 2월 4년 3개월차 개발자의 고민 작성  개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년…","fields":{"slug":"/개발자로 어떻게 살 것 인가/"},"frontmatter":{"date":"Feb 12, 2020","title":"개발자로 어떻게 살 것 인가?","tags":["생각정리"]}}},{"node":{"rawMarkdownBody":"<!-- ---\ntitle: 재귀\ndate: 2020-03-19\ntags:\n  - algorithm\nkeywords:\n  - 재귀\n--- -->\n\n\nhttps://www.youtube.com/watch?v=ln7AfppN7mY&list=PL52K_8WQO5oUuH06MLOrah4h05TZ4n38l\n\nRecursion - 개념과 기본예제들 1,2,3강\nRecursion의 응용\n    - 미로찾기\n    - Counting Cells in a Blob\n    - n queens problem\n        \n\n","excerpt":"https://www.youtube.com/watch?v=ln7AfppN7mY&list=PL52K_8WQO5oUuH06MLOrah4h05TZ4n38l Recursion - 개념과 기본예제들 1,2,3강\nRecursion…","fields":{"slug":"/재귀_1/"},"frontmatter":{"date":"Invalid date","title":"","tags":["undefined"]}}},{"node":{"rawMarkdownBody":"\n자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.\n\n\n```js\n\t1 클래스와 인스턴스의 개념 이해\n\t2 자바스크립트의 클래스\n\t3 클래스 상속\n\t\t3-1 기본 구현\n\t\t3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n\t\t3-3 constructor 복구 하기 \n\t\t3-4 상위 클래스에 접근 수단 제공\n\t4 ES6의 클래스 및 클래스 상속\n\n```\n# 1 클래스와 인스턴스의 개념 이해\n* 클래스\n    - **공통 속성, 기능 정의한 추상적 개념**\n    - 클래스를 바탕으로 인스턴스를 만들 때 비로소 어떤 객체가 클래스의 속성을 지닌다.\n    - 어떤 인스턴스가 다양한 클래스에 속할 수는 있지만 이 클래스들은 모두 인스턴스 입장에서는 '직계존속'\n    - 다중상속을 지원하는 언어이든 그렇지 않은 언어이든 결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐일 수 밖에 없기 때문\n\n* 인스턴스\n    - 클래스에 속한 객체 \n\n* static member(static method, static properties)\n    - 클래스 자체에서만 동작\n* prorotype method\n    - 인스턴스에서 활용 가능\n\n# 2 자바스크립트의 클래스\n\n* 생성자 함수 Array를 new연선자와 함께 호출하면 인스턴스 생성 하는 과정을 통한 설명\n    - Array를 일종의 클래스라고 하면, **Array의 prototype 객체 내부 요소들이 인스턴스에 '상속'**된다고 볼 수 있다. \n        - **엄밀하게 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으로 동일하게 동작**\n    - ***한편 Array 내부 프로퍼티들 중 prorotype 프로퍼티를 제외한 나머지 인스턴스에 상속되지 않는다.***  \n    (=== static member: static method, static properties)\n\n    - 인스턴스에 상속되는지(인스턴스가 참조하는지) 여부에 따라 **\"static member\"(상속불가능)**와 **\"instance member\"(상속가능)**로 나뉜다.\n        - 이 분류는 다른 언어의 클래스 구성요소에 대한 정의를 차용한것으로 클래스 입장에서 사용대상에 따라 구분한것 \n        - 하지만 **자바스크립트는 다른 언어와 달리 인스턴스에서도 직접 메서드를 정의할 수 있다.**\n        - 그래서 '인스턴스 메서드'라는 명칭은 프로토타입에 정의한 메서드를 지칭하는 것인지 인스턴스에 정의한 메서드를 지칭하는것인지 혼란이 올 수 있다.  \n        따라서 **프로토타입에 정의한 메서드를 프로토타입 메서드라고 부른다.**\n\n\n    - 도식화 - Array constructor function\n    ![](class&instance.jpg)\n\n    - 도식화 - prorotype, \\_\\_proto__, instance\n    ![](class&instance2.jpg)\n\n*  실제 예제\n```js\n    function Person(name, age){\n        this._name = name;\n        this._age = age;\n    }\n\n    Person.getInformations = function(inst){    //Static emthod\n        return{\n            name: inst._name,\n            age: inst._age\n        };\n    }\n    Person.prototype.getName = function(){      //(prototype) method\n        return this._name;\n    }\n    Person.prototype.getAge = function(){       //(prototype) method\n        return this._age;\n    }\n\n\n    var yoon = new Person(\"happyjy\", 30);\n    console.log(yoon.getName());    //happyjy\n    console.log(yoon.getAge());     //30\n\n    console.log(yoon.getInformations(yoon));    \n    //에러! yoon.getInformations is not a function\n    //생성자 함수 property(getInformations)에는 인스턴스가 직접 접근하지 못한다.\n    //생성자 함수 property는 인스턴스로 상속할 수 있는 프로퍼티로 만들지 않는다.\n    console.log(Person.getInformations(yoon)); //{name: \"happyjy\", age: \"30\"}\n    //생성자 함수 property는 생성자 함수로만 접근이 가능하다.\n```\n\n\n# 3 클래스 상속\n## 3-1 기본 구현\n* 구현 point\n    1. 프로토타입 설정\n    2. contsructor 복구\n\n    ```js\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.name = name || '홍길동(setting by Employee function)';\n        this.age = age || 0;\n        this.position = position || '미정';\n    };\n\n    //1.prorotype 설정\n    Employee.prototype = new Person();      // 이 코드에 의해서 new Employee에 의해서 생성된 인스턴스.__proto__에 Person 인스턴가 세팅된다.\n    //2. constructor 복구\n    Employee.prototype.constructor = Employee;  // prototype에서 다뤘던 내용\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    };\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n- mac의 결과 값\n    - ***문제: mac.\\_\\_proto__에 추상적이어야할 클래스 prorotype 담겨 있는 것***\n    - 만약 delete mac.name이후 mac.getName을 하면 undefined가 return 되어야 하는데 prototype chain에 의해서 홍길동(mac.__proto__ property)이 반환된다.\n    - 그래서 아래 예제 \"prototype\"로 상속 구현하기에 extendClass에 의해서 문제를 해결할 수 있다. \n        - 문제 해결 방법 요약: 상속할때 parent, child class 사이에서 extend해주는 개념이 필요하다  \n        : 아래 3-2, 3-3, 3-4 capter에서 다루도록 하겠다.\n\n    ![](Employee상속.png)\n\n\n\n## 3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **1,2번** 참고 \n\n## 3-3 constructor 복구 하기 \n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **3번** 참고 \n\n## 3-4 상위 클래스에 접근 수단 제공\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **4번** 참고 \n\n* extend Class 구현 개념\n    - 아래 구현 예제 주석 1,2,3,4번 코드 참고\n![](extendClass.jpg)\n\n* extendClass구현으로 prototype상속 구현\n\n    ```js\n    //* es5에서 많이 사용해서 아래와 같이 클래스 상속을 구현 \n    //* 클로저를 생성해서 'Bridge'를 단한번만 사용할 수 있게 함 \n    var extendClass = (function(){\n        function Bridge(){}\n        return function(Parent, Child){\n            Bridge.prototype = Parent.prorotype;  //1번\n            Child.prototype = new Bridge();       //2번\n            Child.prototype.constructor = Child;  //3번\n            Child.prototype.superClass = Parent;  //4번\n        }\n    })();\n\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.superClass(name, age); //4번: 하위 클래스에서 이런 호출로 상위 클래스가 설정한 프로퍼티 세팅 가능\n        this.position = position || '미정'\n    }\n\n    \n    extendClass(Person, Employee);\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    }\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n* 결과 \n![](extendClass적용.png)\n\n* 짚고 넘어가자! - this.superClass에 대해서 \n    - this.superClass는 Parent object이기 때문에 Person constructor function에서 name, age설정\n    - Person constructor function에서 this.name, this.age에 설정 시 this scope은 \"Employee instance object\"라서 위 결과 처럼 name, age가 Employee instance property에 설정 된다.\n\n\n# 4 ES6의 클래스 및 클래스 상속\n* class로 상속 구현하기\n```js\n    class Person {\n        constructor (name, age) {\n            this.name = name || '아무개';\n            this.age = age || '0';\n        }\n\n        getName(){\n            return this.name;\n        }\n\n        getAge(){\n            return this.age;\n        }\n    }\n\n    class Employee extends Person {\n        constructor (name, age, position){\n            super(name, age);\n            this.position = position || '미정';\n        }\n        getPosition(){\n            return this.position;\n        }\n\n    }\n```\n\n\n# 참고 \n* 코어 자바스크립트","excerpt":"자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.…","fields":{"slug":"/class/"},"frontmatter":{"date":"Feb 11, 2020","title":"class","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\njavascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자. \n\n\n```js\n\t1 프로토타입의 개념 이해 \n\t\t1-1 constructor, prototype, instance\n\t\t1-2 constructor 프로퍼티\n\t2 프로토타입 체인\n\t\t2-1 메서드 오버라이드\n\t\t2-2 프로토타입 체인\n\t\t2-3 객체 전용 메서드의 예외사항\n\t\t2-4 다중 프로토타입 체인\n```\n\n# 1 프로토타입의 개념 이해 \n# 1-1 Constructor, prototype, instance\n\n* Constructor\n    - A function that initializes an object\n    - similar to normal javaconstuctor\n* prototype\n    - Constructor의 property\n    - instance의 property \\_\\_proto__과 메모리 공유  \n    : constructor.prototype === instance.\\_\\_proto__\n* instance\n    - Constructor를 new키워드로 호출로 생성한 객체\n\n* prototype 도식\n    ![](프로토타입도식.jpg)\n    * 왼쪽 꼭짓점: Constructor(생성자 함수)\n    * 오른쪽 꼭짓점: Constructor.prorotype 프로퍼티\n    * new를 통해 instance 생성\n    * instance.\\_\\_proto__\n\n* 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출하면\n    * Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성됩니다.\n    * 이때 instance에는 \\_\\_proto__라는 프포퍼티가 자동으로 부여\n    * 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조\n\n* prototype 개념의 핵심: prototype 프로퍼티, \\_\\_proto__라는 프로퍼티\n    * **prototype은 객체**\n    * **이를 참조하는 \\_\\_proto__도 객체**\n    * prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장\n    * 그러면 인스턴스에서도 숨겨진 프로퍼티인 \\_\\_proto__를 통해서 이 메서들을 접근할 수 있게 된다.\n\n    ```js\n    var Person = function(name) {\n        this._name = name;\n    }\n\n    Person.prototype.getName = function(){\n        debugger;\n        return this._name;\n    }\n\n    //---\n    typeof Person                   // function\n    typeof new Person('boa');       // object\n    new Person('boa');              // Person {_name: 'boa'}\n    new Person('boa').__proto__     // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    Person.prototype                // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    //---\n    \n    var boa = new Person('boa');\n    boa.__proto__.getName();    //undefined\n    boa.getName();              //boa\n    /*\n        boa.__proto__에 _name 프로퍼티가 없어 식별자(this._name)를 찾을 수 없다.\n        * boa.__proto__.getName();, boa.getName(); \n            - getName이 호출 돼 scope에 있는 this가 서로 다르다. 그래서 결과 값이 다르다.\n            - boa.__proto__ this -> {getName: f, constructor: f}\n            - boa this ->  Person {_name: 'boa'} \n\n    */\n\n    Person.prototype === boa.__proto__;\n    /*\n        Constructor function의 prototype으로 생성한 instnace 'boa'의 property '__proto__'객체는 Consytructor function의 객체는 메모리를 공유하고 있다.\n\n        이런 특징으로 \n        instance.__proto__ property를 변경하면 Constructor.prototype도 변경이 된다.\n        즉 instance.__proto__, Constructor.prototype 객체는 메모리를 공유하고 있따. \n    */\n\n    var boa = new Person('boa');\n    boa.__proto__._name = 'boa.__proto__';\n    boa.__proto__.getName() =               //Boa__proto__\n    /*\n        * boa.__proto__.getName() 에 의해서 호출된 getName의 this는 boa.__proto__\n        * \n    */\n\n    //---\n    \n    var iu = new Person('iu');\n    iu.getName(); // iu\n    \n    /*\n        iu.__proto__.getName \n        = iu(.__proto__).getName\n        = iu.getName\n    */\n\n\n    //---\n\n    var Constructor = function(name) {\n        this.name = name;\n        console.log(this);\n    }\n\n    Constructor.prototype.method = function(){};\n    Constructor.prototype.prototype1 = 'constructor Prototype property';\n\n    var instance = new Constructor('INSTANCE');\n    console.dir(Constructor);\n    console.dir(instance);\n    /*\n        Constructor.prototype === instance.__proto__\n    */\n\n\n    //--\n    var arr = [1,2];\n    console.dir(arr);\n    console.dir(Array);     //Array: 내장 생성자 함수\n\n    arr.forEach(function(){});  //\n    Array.isArray(arr);         //true\n    arr.isArray()               //TypeError: arr.isArray is not a function\n\n\n    ```\n\n# 1-2 constructor 프로퍼티\n\n```js\n    var arr = [1,2];\n    Array.prototype.constructor === Array;\n    arr.__proto__.constructor === Array;\n    arr.constructor === Array;\n\n    var arr2 = new arr.constructor(3,4);\n    console.log(arr2) //[3,4]\n```\n\n\n```js\nvar Person = function(name){\n    this.name = name;\n}\n\nvar p1 = new Person('인간1');                           //Person {name:\"인간1\"} true\nvar p1Proto = Object.getPrototypeOf(p1);\n\nvar p2 = new Person.prototype.constructor('인간2');     //Person {name:\"인간2\"} true\nvar p3 = new p1Proto.constructor('인간3');              //Person {name:\"인간3\"} true\nvar p4 = new p1.__proto__.constructor('인간4');         //Person {name:\"인간4\"} true\nvar p5 = new p1.constructor('인간5');                   //Person {name:\"인간5\"} true\n\n[p1, p2, p3, p4, p5].forEach(function(p){\n    console.log(p, p instanceof Person);\n})\n\n[constructor]\n[instance].__proto__.constructor\n[instance].constructor\nObject.getPrototypeOf([instance]).constructor\n[Contsructor].prototype.constructor\n\n[Constructor]\n[instance].__proto__\n[instance]\nObject.getPrototypeOf([instance])\n\n```\n\n# 2 프로토타입 체인\n\n# 2-1 메서드 오버라이드\n\n* 예제 \n    - 아래 메서드 오버라이드 전, 후 캡쳐 참고\n        ```js\n        var Person = function(name){\n            this.name = name;\n        }\n        Person.prototype.getName = function(){\n            return this.name;\n        }\n\n        var boa = new Person('보아');\n        boa.getName = function(){\n            return '이 사람은 ' + this.name;\n        };\n\n        console.log(boa);               // Person {name: \"보아\", getName: ƒ}\n        console.log(boa.getName());     // 이 사람은 보아\n\n        console.log(boa.__proto__.getNam());    // undefined\n        Person.prototype.name = '권보아';\n        console.log(boa.__proto__);             // {name: \"권보아\", getName: ƒ, constructor: ƒ}\n        console.log(boa.__proto__.getName());   // 이사람은 권보아\n        console.log(boa.__proto__.getName.call(boa));   // this를 명시적으로 선언\n        /*\n            메서드가 오버라이드된 경우에는 자신으로부터 가장 가까운 메서드에만 접근\n            그다음으로 가까운 __proto__의 메서드도 우회적인 방법을 통해서 접근 가능\n        */ \n        ```\n* 결과\n    - override 하기 전\n    ![](method_override.png)\n    \n                             \n    - override 후\n    \n    ![](method_override1.png)\n\n# 2-2 프로토타입 체인\n* Object의 내부 구조\n\n![](prototypeOfObject.png)\n\n* Array의 내부 구조\n![](prototypeOfArray.png)\n\n\n* Array 내부 도식화\n![](Array내부도식화.jpg)\n    - [1,2]는 Array.prototype, Object.prototype내부의 메서드를 자신의 것처럼 실행 할 수 있다. \n    - .\\_\\_proto__는 생략 가능하다\n    - 예시\n\n        ```js\n        var arr = [1,2];\n        arr(.__proto__).push(3);                            //3\n        arr(.__proto__)(.__proto__).hasOwnProperty(2);      //true\n        ```\n\n* 메서드 오버라이드와 프로토타입 체이닝\n\n```js\nvar arr = [1,2,3];\nArray.prototype.toString.call(arr);     //1,2,3\nObject.prototype.toString.call(arr);    //[object Array]\narr.toString();                         //1,2,3\n\narr.toString = function(){      //결과 아래 캡쳐 참고 \n    return this.join('_');\n};\narr.toString();                         //1_2_3\n```\n\n* arr 객체에 toString function 추가시 arr객체 내부\n\n    ![](Array객체에toString추가.png)\n\n\n# 2-3 객체 전용 메서드의 예외사항\n\n* Object.prototyp에 추가한 메서드의 접근\n    ```js\n    Object.prototype.getEntries = function(){\n        var res = [];\n        for (var prop in this){\n            if(this.hasOwnProperty(prop)){\n                res.push([prop, this[prop]]);\n            }\n        }\n        return res;\n    }\n\n    var data = [\n        ['object', {a: 1, b: 2, c:3}],\n        ['number', 345],\n        ['string', 'abc'], \n        ['boolean', false],\n        ['func', function(){}],\n        ['array', [1,2,3,4]]\n    ];\n\n    data.forEach(function(d){\n        console.log(d[1].getEntries());\n    })\n\n    ```\n    - 어떤 데이터 타입이건 거의 무조건 프로토타입 체이닝을 통해 getEntries 메서드에 접근 \n\n\n* 스태틱 메서드(객체한정메서드)\n    - 객체만을 대상으로 동작하는 객체 전용메서드들은 부득이 Object.prototype이 아닌 Object에 스태틱 메서드(static method)로 부여할 수 밖에 없다.\n    - 생성자 함수인 Object, 인스턴스 객체 리터럴 사이에는 this를 통한 연결이 불가능\n    - 전용 메서드 처럼 '메서드명 앞의 대상이 곧 this'가 되는 방식대신  \n    this의 사용을 포기하고 대상 **인스턴스를 인자로 직접 주입해야 하는 방식**으로 구현  \n    : 예시 Object.freeze({prop: 42})\n    - Object.prototype.consructor 하위 메서드 & Object.protptype 하위 메서드\n     ![](객체전용메서드&스태틱메서드.jpg)\n\n# 2-4 다중 프로토타입 체인\n* 새롭게 만드는 생성자 함수에 \\_\\_proto__를 연결해서 체인 관계를 만들수 있다.\n* Grade.prototype에 Array instance를 세팅으로 g1(Grade function의 instance)에서 push를 사용할 수 있게 된다.\n\n* Grade 생성자 함수와 인스턴스\n    ```js\n    var Grade = function(){\n        //arguments: 유사배열\n        var args = Array.prototype.slice.call(arguments);\n        for(var i=0; i<args.length; i++){\n            this[i] = args[i];\n        }\n        this.length = args.length;\n    }\n    var g = new Grade(100, 80);\n    g.push(1); //Uncaugh TypeError: g.push is not function\n\n    Grade.prototype = new Array();   //POINT\n    //Grade.prototype = [];   \n    //[].__proto__ === new Array().__proto__\n    //[] instanceof Array // true\n    \n    var g1 = new Grade(10, 20);\n    g1.push(1);\n    console.log(g1);    //Grade(3) [10, 20, 1]\n    g1.shift()\n    console.log(g1);    //Grade(3) [20, 1]\n\n    ```\n    - 도식화 \n    ![](Grade생성자함수에배열proto.jpg)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n","excerpt":"javascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자.  1 프로토타입의 개념 이해 1-…","fields":{"slug":"/prototype/"},"frontmatter":{"date":"Feb 08, 2020","title":"prototype","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다. \n\n\n```js\n\t1 클로저의 의미 및 원리 이해\n\t2 클로저와 메모리 관리\n\t3 클로저 활용사례\n\t\t3-1 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 \n\t\t3-2 접근 권한 제어(정보 은닉)\n\t\t3-3 부분 적용함수\n\t\t3-4 커링함수\n```\n\n\n# 1 클로저의 의미 및 원리 이해\n\n\n## 클로저란?  \n> * 함수형 프로그래밍 언어에서 등장하는 특징  \n> * 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 **실행 컨텍스트가 종료된 이후에도 변수a가 사라지지 안는 현상**\n> * 내부함수를 외부로 전달하는 방법: 함수를 return하는 경우, callback으로 전달\n> * mdn 설명  \n> A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).  \n> In other words, a closure gives you access to an outer function’s scope from an inner function. \n> In JavaScript, closures are created every time a function is created, at function creation time.\n    \n\n## 외부 함수의 변수를 참조하는 내부 함수(1)\n\n```js\nvar outer = function() {\n    var c = 1;\n    var c1\n    var inner = function() {\n        console.log(++c);\n    }\n    inner();\n};\nouter();\n```\n\n* **inner함수 내부에서는 c를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 c를 찾는다.**\n* outer함수의 실행 컨텍스트가 종료되면 LexicalEnvironmentReference에 저장된 식별자들(c, inner)에 대한 참조를 지운다. \n    - 각 <u>주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로</u> **가비지 컬렉터의 수집 대상**이된다.\n* inner function안에서 closure 영역에 있는 변수는 'c' 하나 뿐이다. **c1처럼 변수 선언만 하고 할당하지 않으면 메모리에 올라오지 않는다.** \n\n## 외부 함수의 변수를 참조하는 내부 함수(2)  \nouter 함수의 실행컨텍스트가 종료된 후 inner 함수를 호출하면?\n\n```js\nvar outer = function() {\n    var c = 1;\n    var c1\n    var inner = function() {\n        console.log(++c);\n    }\n    inner();\n};\nvar excuteInnerFunc = outer();\nconsl.log(excuteInnerFunc); // 2\nconsl.log(excuteInnerFunc); // 3\n```\n* inner함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없습니다.\n* outerEnvironmentReferenece에는 inner함수가 선언된 위치의 LexicalEnvironment가 참조복사\n* inner함수는 outer함수 내부에서 선언됐으므로, outer함수의 Lexicalenvironment가 담김\n    - 위 단계로 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환\n    - inner함수의 실행 컨텍스트가 종료\n* excuteInnerFunc를 두번째 호출하게 되면 위 단계를 걸쳐 2->3 으로 증가한다.\n\n* ***주의할점***\n    > inner함수의 실행시점에는 outer함수는 이미 실생 종료된 상태인데 outer함수의 Lexicalenvironment에 어떻게 접근할 수 있는걸까? \n    - 가비지 컬렉터의 동작 방식때문\n    - **가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.**\n    - **언젠가 inner함수의 실행컨텍스트가 활성화 되면 outerEnvironmentReferenece가 outer함수의 Lexicalenvironment를 필요로 할 것이므로 수집 대상에서 제외**\n        - 그래서 inner함수 c 변수에 접근 가능\n\n## return 없이도 클로저가 발생하는 다양한 경우\n\n```js\n(function(){\n    var a = 0 ;\n    var intervalId = null;\n    var inner = function() {\n    \t//CallStack inner에서 clsoure scope: a, intervalId\n        if (++a>9) {\n            clearInterval(intervalId);\n        }\n        console.log(a);\n    };\n    intervalId = setInterval(inner, 1000);\n})()\n\n// clouser & eventListener\n(function(){\n    var count = 0;\n    var button = document.createElement('button');\n    button.innerText = 'click';\n    button.addEventListener('click', function(){\n    \t//callback function CallStack 에서 clsoure scope: count\n        console.log(++count, 'times clicked');\n    });\n    document.body.appendChild(button);\n})()\n```\n![clouser&eventListener](clouser&eventListener.png)\n\n# 2 클로저와 메모리 관리\n* 객체지향, 함수형 모두를 아우르는 중요한 개념\n* 클로저는 메모리 소모가가 있지만 이런 특성을 정확히 이해하고 잘 활용하도록 노력해야한다.     \n\n* closure를 GC가 수거하게 하는 방법\n    - 3장 예시에 POINT 주석 3개 참고   \n    ```js\n        //1번째 예시\n        var outer = function() {\n            var c = 1;\n            var c1\n            var inner = function() {\n\t    \t//Call Stack inner에서 Closure Scope: c (c1은 참조를 안하고 있어 GC에 의해 수집)\n                console.log(++c);\n            }\n            inner();\n        };\n        outer();\n        outer = null;   // POINT: outer실별자의 inner 함수 참조를 끊음\n        \n\n        //2번째 예시\n        (function(){\n            var a = 0 ;\n            var intervalId = null;\n            var inner = function() {\n\t    \t//CallStack inner에서 clsoure scope: a, intervalId, inner(inner식별자의 함수 참조를 끊기위해 참조)\n                if (++a>9) {\n                    clearInterval(intervalId);\n                    inner = null;             // POINT: inner식별자의 함수 참조를 끊음  \n                }\n                console.log(a);\n            };\n            intervalId = setInterval(inner, 1000);\n        })();    \n\n        \n        //3번째 예시\n        // clouser&eventListener\n        (function(){\n            var count = 0;\n            var button = document.createElement('button');\n            button.innerText = 'click';\n\n            var clickHandler = function(){\n                //console.log(++count, 'times clicked');\n\t\t//callback function CallStack 에서 clsoure scope: count, clickHandler(식별자 함수 참조를 끊기위해서 closure영역 clickHandler참조)\n                if( ++count > 9 ){\n                    clickHandler = null;  //POINT: clickHandler 식별자 함수 참조를 끊음\n                }\n            };\n\n            button.addEventListener('click', clickHandler);\n            document.body.appendChild(button);\n        })()\n    ```\n\n# 3 클로저 활용사례\n\n## 3-1 Event Listener(콜백 함수 내부에서 외부 데이터를 사용하고자 할 때)\n\n* event Listener callback function\n    ``` js\n        var colorList = ['red', 'blue', 'white'];\n        var $ul = document.createElement('ul');\n\n        colorList.forEach(function(color){                  //(A)\n            var $li = document.createElement('li');\n            $li.innerText = color;\n            $li.addEventListener('click', function(){       //(B)\n                console.log('your choice: ', color);\n            });\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n    ```\n    * (B)는 color라는 **클로저**가 있다. \n    * (A)는 colorList만큼의 **'실행 컨텍스트가 활성화 됨'**\n    * (B) outerEnvironmentReferenece가 (A)의 LexicalEnvironment참조  \n       -> **(B)함수가 참조할 예정인 변수 color에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능**\n\n\n* event Listener callback function에 bind 사용\n```js\n    var $ul = document.createElement('ul');\n    var colorList = ['red', 'blue', 'white'];\n    var consoleColor = function(color){\n        if(this === window){\n            //POINT3, POINT2\n            console.log('### this is window -> ' + this + \"/// callback function param: \" + color);\n            console.log('### this: ', this);      //Window {}\n            console.log('### color: ', color);     //blue\n            console.log('--------------------')\n        } else {\n            //POINT1\n            console.log('*** this is HTMLElement -> this Value:' + this + \"/// callback function param: \" + color);\n            console.log('*** this: ', this);      //<li>blue</li>\n            console.log('*** color: ', color);     //MouseEvent\n            console.log('====================')\n        }   \n    }            \n    \n    colorList.forEach(function(fruit){\n        var $li = document.createElement('li');\n        $li.innerText = fruit;\n        $li.addEventListener('click', consoleColor);                        //POINT 1: eventListener의 this, 첫번째 파라미터는 각각 '클릭한 dom', 'MouseEvent' 객체들이다.\n        $li.addEventListener('click', consoleColor.bind(this, fruit));      //POINT 2: forEach의 callback function에서 this는 windown!/ fruit는 clousre! \n        $ul.appendChild($li);\n    });\n    document.body.appendChild($ul);\n    \n    consoleColor(colorList[2]);                                             //POINT 3\n```\n    ![](callbackEg_EventListener.png)\n    \n    * POINT1,2,3의 consoleColor function의 console 확인 필요 \n    * POINT1,2의 this, 첫번째 param을 다시 상기 시켜보자.\n    * POINT1\n    \t- eventListener의 callback function에서 this: target dom\n\t- eventListener의 callback function에서 첫번째 param: event 객체\n    * POINT2 제약사항  \n        - **이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점(2번째 param으로 event 객체가 넘어옴)**\n\t- **함수 내부에서의 this가 eventListener callback function에서 가르키는것(target dom)과 달라지는 점은 감안해야한다.**\n\n        \n* event Listener에 고차 함수 사용\n    - 함수형 프로그램밍에서 자주 쓰이는 방식\n\n    ```js\n        var $ul = document.createElement('ul');\n        var colorList = ['red', 'blue', 'white'];\n        var consoleColor = function(color){\n            return function(){\n                console.log(color)\n            }\n        }            \n        \n        colorList.forEach(function(fruit){\n            var $li = document.createElement('li');\n            $li.innerText = fruit;\n            $li.addEventListener('click', consoleColor(fruit));\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n        \n    ```\n\n## 3-2 접근 권한 제어(정보 은닉)\n\n```js\n    var outer = function(){\n        var a = 1;                  //closure\n        var inner = function(){\n            return ++a;\n        }\n        return inner;\n    }\n    var outer2 = outer();\n\n    console.log(outer2());\n    console.log(outer2());\n```\n\n* outer함수는 외부(전역 스코프)로부터 철저하게 격리\n* 외부에서는 외부 공간에 노출돼 있는 outer라는 변수를 통해 outer함수를 실행할 수 있지만  \n, outer함수 내부에는 어떠한 개입도 할 수 없다.\n* **외부에서는 오직 outer함수가 return한 정보에만 접근할 수 있다.** (== return 값이 외부에 정보를 제공하는 유일한 수단)\n\n## 3-3 부분 적용함수\n\n```js\nvar add = function(){\n    var result = 0;\n    for(var i = 0; i < arguments.length; i++){\n        result += arguments[i];\n    }\n    return result;\n};\nvar addPartial = add.bind(null, 1,2,3,4,5);\nconsole.log(addPartical());             //15\nconsole.log(addPartial(6,7,8,9,10));    //55\nconsole.log(addPartical(10));           //25\n\n```\n## 3-4 커링함수\n* 여러 인자를 받은 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성\n\n* curring function eg\n    ```js\n\n    var curryFuncTest = function (func){\n        debugger;\n        return function(a){\n            debugger;\n            return function(b){ // getMaxWith10, getMinWith10 funciton\n                debugger;\n                return func(a,b);\n            };\n        };\n    };\n\n\n    var getMaxWith10 = curryFuncTest(Math.max)(10);\n    console.log(getMaxWith10(8));\n    console.log(getMaxWith10(25));\n\n    var getMinWith10 = curryFuncTest(Math.min)(10);;\n    console.log(getMinWith10(8));\n    console.log(getMinWith10(25));\n\n    ```\n![curryfunciton](curryfunction.png)\n\n* curring function with arrow function\n\n    ```js\n        var curryFuncTestWithArrowFunc = func => a => b => func(a,b);\n        var getMaxWith10WithArrowFunc = curryFuncTestWithArrowFunc(Math.max)(10);\n        console.log(getMaxWith10WithArrowFunc(8));\n        console.log(getMaxWith10WithArrowFunc(25));\n    ```\n\n* curring function 실제 사용 예\n\n    ```js\n    var getInfomation = function(baseUrl){                      // 서버에 요청할 주소의 기본 URL\n        return function (path) {                                // path값\n            return function (id) {                              // id    \n                return fetch(baseUrl + path + '/' + id);        // 실제 서버에 정보 요청\n            };\n        };\n    };\n\n    var getInformation = baseUrl => path => id => fetch(baseUrl + path + '/' + id);\n    var imageUrl = 'http://imgAddr.com/';\n\n    // 이미지 타입별 요청 함수 준비\n    var getImage = getInformation(imageUrl);    //http://imgAddr.com/\n    var getEmoticon = getImage('emoicon');      //http://imgAddr.com/emoticon\n    var getIcon = getImage('icon');             //http://imgAddr.com/icon\n\n    //실제 요청\n    var emoticon1 = getEmoticon(100);       //http://imgAddr.com/emoticon/100\n    var emoticon2 = getEmoticon(200);       //http://imgAddr.com/emoticon/200\n    var icon1 = getIcon(10);                //http://imgAddr.com/icon/10\n    var icon2 = getIcon(20);                //http://imgAddr.com/icon/20\n\n    ```\n\n    * 이런 이유로 최근 여러 프레임워크, 라이브러리 등에서 커링을 상당히 광범위하게 사용하고 있다.\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n","excerpt":"업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다.…","fields":{"slug":"/closure/"},"frontmatter":{"date":"Feb 05, 2020","title":"closure","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n```\n# 목차\n    * call() 정의\n    * call()을 생성자 연결에 사용\n    * call()을 익명함수와 함께 쓰기 \n    * call()호출시 this에 특정 값을 넣어 동작하기\n    * call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n    * call, apply함수의 비교(this에 특정 값 넣어 동작)\n    * bind()\n    * bind()함수 구현 해보기\n    * creating a bound function\n    * Partially applied functions\n    * with setTimeout()\n```\n\n# call() 정의\n> 주어진 this 값, 전달된 인수 와 함께 함수를 호출\n\n```js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\n\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n```\n\n# call()을 생성자 연결에 사용\n> function, method에 속해서 다른 객체를 호출한다.  \n> function, method에 this 값을 전해준다.  \n함수는 한번 쓰고 다른 객체에서 상속 받아 사용한다.(method를 다시 만들 필요 없이)\n``` js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price < 0) {\n    throw RangeError('Cannot create product ' +\n                      this.name + ' with a negative price');\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'food';\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'toy';\n}\n\nvar cheese = new Food('feta', 5);\nvar fun = new Toy('robot', 40);\n```\n\n\n# call()을 익명함수와 함께 쓰기 \n```js\nvar animals = [\n  { species: 'Lion', name: 'King' },\n  { species: 'Whale', name: 'Fail' }\n];\n\nfor (var i = 0; i < animals.length; i++) {\n  (function(i) {\n    this.print = function() {\n      console.log('#' + i + ' ' + this.species\n                  + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n//## 결과 \n//#0 Lion: Kinf\n//#1 Whale: Fail\n```\n\n# call()호출시 this에 특정 값을 넣어 동작하기\n> \n\n```js\nfunction greet() {\n  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n  console.log(reply);\n}\n\nvar obj = {\n  animal: 'cats', sleepDuration: '12 and 16 hours'\n};\n\ngreet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n# call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n> call로 호출될 function 안에 this의 bound는 global object이다  \n> 하지만 use stric을 사용 하용하면 undefined가 나온다. \n```js\nvar sData = 'Wisen';\n            \nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call();  // sData value is Wisen \n\n``` \n\n```js            \n'use strict';\n\nvar sData = 'Wisen';\n\nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call(); // Cannot read the property of 'sData' of undefined            \n```\n\n# call, apply함수의 비교(this에 특정 값 넣어 동작)\n```js\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.call(obj,\"Korea\",\"Seoul\"));\t\n//welcome to Korea in Seoul Jaeyoon\n\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.apply(obj,[\"Korea\",\"Seoul\"]));\t\t\n//welcome to Korea in Seoul Jaeyoon\n```\n\n\n\n\n\n\n# bind()\n> 함수와 객체를 서로 묶는 것이다.  \n> bind()함수는 새 함수를 반환한다.(call, apply는 바로 동작`)\n```js\nfunction f(y) { return this.x + y }    //바인드되어야 하는 함수\nvar o = {x:1};      //바인드될 객체\nvar g = f.bind(o);  //g(x)를 호출하면 o.f(x)가 호출된다.\ng(2)                //=>3\n```\n\n# bind()함수 구현 해보기 \n```js\nFunction.prototype.bind = function(obj){\n  //this와 인자 값을 변수에 저장함으로써 다음의 중첩 함수에서 사용할 수 있다.\n  var me = this, boundArgs = arguments;\n\n  //bind() 메서드의 반환 값은 함수다.\n  return function(){\n  //인자 목록을 작성하는데, 첫 번재 이후의 인자부터\n  //나머지 모든 인자를 이 함수에 전달 한다.\n  var args = [], i;\n  for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);\n  for(i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  \n  //인자들을 포함하여 obj의 메서드로 me를 호출한다.\n  return me.apply(obj, args);\n}\n```\n\n# creating a bound function\n\n```js\nthis.x = 9;    // this refers to global \"window\" object here in the browser\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nmodule.getX(); // return: 81 - The ufnction gets invoked at the module scope\nretrieveX();   // returns 9 - The function gets invoked at the global scope\n\n// Create a new function with 'this' bound to module\n// New programmers might confuse the global var x with module's property x\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n# Partially applied functions\n\n```js\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\nvar result1 = addArguments(1, 2); // 3\n\n// Create a function with a preset leading argument\nvar leadingThirtysevenList = list.bind(null, 37);\nvar list2 = leadingThirtysevenList(); // [37]\nvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n// Create a function with a preset first argument.\nvar addThirtySeven = addArguments.bind(null, 37); \nvar result2 = addThirtySeven(5); // 37 + 5 = 42 \nvar result3 = addThirtySeven(5, 10);// 37 + 5 = 42 , second argument is ignored\n\n```\n\n\n\n# with setTimeout()\n\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  // #POINT\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with '+ this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  \n// after 1 second, triggers the 'declare' method\n```\n","excerpt":"call() 정의 주어진 this 값, 전달된 인수 와 함께 함수를 호출 call()을 생성자 연결에 사용 function, method에 속해서 다른 객체를 호출한다. function, method에 this…","fields":{"slug":"/call(), apply(), bind()/"},"frontmatter":{"date":"Feb 02, 2020","title":"call(), apply(), bind()","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로\n\n```js\n\t1 콜백함수란?\n\t2 제어권\n\t\t2-1 호출시점\n\t\t2-2 인자\n\t\t2-3 this\n\t3 콜백 함수는 함수다\n\t4 콜백 함수 내부의 this에 다른 값 바인딩하기\n\t5 콜백 지옥과 비동기 제어\n```\n\n\n\n# 1 콜백함수란?\n> 다른 코드의 인자로 넘겨주는 함수(제어권도 함께 위임)\n> 콜백함수를 넘겨 받는 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행\n\n\n# 2 제어권\n> 호출시점, 인자, this 예제를 통해서 알아 보자\n## 2-1 호출시점\n> setInterval에 callback function은 '호출주체, 제어권'은 setInterval이다.\n```js\nvar count = 0;\nvar cbFunc = function() {\n    conosl.log(count);\n    if(++count > 3) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n```\n## 2-2 인자\n> 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.\n\n* callback function의 인자 값은 filter에 의해서 정해졌다.\n    ```js\n    var newArr = [1,2,3,4,5].filter(function(idx, val){\n        console.log({'this sceop': this, idx, val});\n        return val > 2;\n    }, {a:1, b:2});     // {a:1, b:2}코드에 대한 설명은 아래 2-3 this설명에서 알 수 있다.\n\n    console.log(newArr);    //[4,5]\n\n    /*\n        this sceop: {a: 1, b: 2}\n        idx: 1\n        val: 0\n        \n        this sceop: {a: 1, b: 2}\n        idx: 2\n        val: 1\n        \n        this sceop: {a: 1, b: 2}\n        idx: 3\n        val: 2\n        \n        this sceop: {a: 1, b: 2}\n        idx: 4\n        val: 3\n        \n        this sceop: {a: 1, b: 2}\n        idx: 5\n        val: 4\n    */\n    ```\n\n## 2-3 this\n\n* Array.prototype.map - 구현    \n    ```js\n    Array.prototype.filter = function(callback, thisArg){\n        var mappedArr = [];\n        for(var i=0; i < this.length; i++){\n            var mappedValue = callback.call(thisArg || window, this[i], i , this);  //POINT\n        }\n    }\n    ```\n    * 주석 POINT 설명\n        * thisArg || window  \n            : callback function에서 this의 scope을 명시적으로 바인딩\n            : 이 코드에 의해 filter의 두번째 param으로 callback의 this를 정해줄 수 있다.\n            : 2-2인자 챕터 코드 참고하기\n        * this  \n            : filter를 호출 한 array(이 내용은 prototype과 관련해서 더 설명할 수 있겠다.)  \n        * this[i]  \n            : 이 코드에 의해서 callback function의 첫번째 param array의 i번째 요소\n        * i  \n            : 이 코드에 의해서 callback function의 두번째 param array의 i번째\n    \n# 3 콜백 함수는 함수다\n* 메서드를 콜백함수로 전달한 경우\n    ```js\n    var obj = {\n        vals: [1,2,3],\n        logValues: function(v, i){\n            console.log(this, v, i);\n        }\n    }\n    \n    obj.logValues(10,20); //{vals: Array(3), logValues: f} 10 20\n\n    [10,20,30].forEach(obj.logValues);\n    /*\n        Window{...} 10 0\n        Window{...} 20 1\n        Window{...} 30 2    \n    */\n    ```\n    * forEach의 callback function은 코드에 의해서 호출된 logValues에서 this는 Window를 가르키고 있다.\n        - callback function으로 obj 객체에 의해서 this가 결정되지 않고 별도로 this를 명시하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 가르친다.\n        \n# 4 콜백 함수 내부의 this에 다른 값 바인딩하기\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (1/3)\n    ```js\n    var obj1 = {\n        name: 'obj1',\n        func: function() {\n            var me = this;             //POINT\n            return function(){\n                console.log(me.name);\n            };\n        }\n    };\n    var callback = obj1.func();\n    setTimeout(callback, 1000);\n    ```\n    * var me = this;는 closure scope에 등록\n    * setTimeout에 의해서 callback function이 호출 될때 me.name은 excute context에서 me.name 변수를 찾는다.\n    ![callback & scope & clousre](callback&scope&closure.png)\n\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (2/3)\n    * 예제1에서 만들었던 함수 재활용하는 방법 - cb2 확인해보자\n    ```js\n\tvar obj1 = {\n\t    name: 'obj1',\n\t    func: function() {\n\t\tvar me = this;              //POINT: closure\n\t\treturn function(){\n\t\t    debugger;\n\t\t    console.log(me.name, this);\n\t\t};\n\t    }\n\t};\n\n\tvar obj2 = {\n\t    name: 'obj2',\n\t    func: obj1.func\n\t};\n\n\tvar cb1 = obj1.func().bind({name: 'cb1'});\n\tsetTimeout(cb1, 1000);\n\n\tvar cb2 = obj2.func().bind({name: 'cb2'});\n\tsetTimeout(cb2, 1500);\n\n\tvar obj3 = { name: 'obj3' }\n\tvar cb3 = obj1.func.call(obj3);        //POINT: obj1.func = function(){ var me this; return function(p1){ console.log() }}\n\tsetTimeout(cb3, 2000);\n\n        /*\n            # 결과\n                * cb1: obj1 {name: \"cb1\"}\n                * cb2: obj2 {name: \"cb2\"}\n                * cb3: obj3 Window {...}\n        */\n    ```\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (3/3)\n    * bind로 this를 명시한 function을 사용\n        ```js\n        var obj1 = {\n                name: 'obj1',\n                func: function() {\n                    console.log(this.name)\n                }\n        };\n        \n        setTimeout(obj1.func.bind(obj1), 1000);\n\n        var obj2 = {name:'obj2'};\n        setTimeout(obj1.func.bind(obj2), 1500);\n\n        /*\n            # 결과\n                * obj1\n                * obj2\n        */\n        ```\n\n\n\n# 5 콜백 지옥과 비동기 제어\n> 콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상\n> 주로 이벤트 처리, 서버통신과 같은 비동기적인 작업을 수행하기 위해서 이런 형태가 등장\n\n* 동기적인 코드\n    - 현재 실행중인 코드가 완료된 후에야 다음 코드를 실행하는 방식\n* 비동기적인 코드\n    - 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다.\n    - CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드 \n* 비동기적인 코드가 필요한 경우   \n    : 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아졌다.\n    - 실행대기(setTimeout)  \n        : 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류\n    - 이벤트처리(addEventListener)  \n        : 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기\n    - 보류(XMLhttpRequest)  \n        : 웹브라우저 자체가 아닌 별도의 대상에 무어가를 요청하고 그에 대한 응답이 왔을때 비로소 어떤 함수를 실행하도록 대기\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n","excerpt":"업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로…","fields":{"slug":"/callback/"},"frontmatter":{"date":"Feb 02, 2020","title":"callback function","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n상황에 따라서 달라지는 this를 정리해보려고 한다. \n```js\n    0 javascripot에서 this\n    1 상황에 따라 달라지는 this\n        1-1 전역 공간에서의 this\n        1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n            함수 vs 메서드\n            메서드 내부에서의 this\n        1-3 함수로서 호출할 때 그 함수 내부에서의 this\n            함수 내부에서의 this\n            메서드의 내부함수에서의 this\n            메서드의 내부 함수에서의 this를 우회하는 방법\n            this를 바인딩하지 않는 함수\n        1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n        1-5 생성자 함수 내부에서의 this\n    2 명시적으로 this를 바인딩하는 방법\n        2-1 call 메서드\n        2-2 apply 메서드\n        2-3 call/apply 메서드의 활용\n            유사배열객체에 배열 메서드를 적용\n            생성자 내부에서 다른 생성자 호출\n            여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n        2-4 bind 메서드\n            name 프로퍼티\n            상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n        2-5 arrow function의 예외사항\n        2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n```\n\n# javascripot에서 this\n* 다른 객제지향 언어와 this의 차이점 \n    * 다른 대부분의 객체지향 언어의 this: 클래스로 생성한 인스턴스 객체\n        * 클래스에서만 사용할 수 있기 때문에 헷갈리지 않거나 많지 않음\n    * 자바스크립트 this: **어디에서나 쓸 수 있음**\n        * 상황에 따라 this가 바라보는 대상이 달라짐\n        * ***문제를 해결하려면 원인을 알아야 하는데, 정확한 작동방식을 이해하지 못하면 원인을 해결하기 어려움***\n\n* this 확인으로 '함수, 객체(메서드)'의 구분할 수 있는 거의 유일한 방법\n\n# 1 상황에 따라 달라지는 this\n> this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정(실행컨텍스트 설명할때 설명됨)  \n> 아래 상황별로 this가 5가지 다른 값을 보여주는 내용을 설명\n\n## 1-1 전역 공간에서의 this\n> 전역 공간에서 this는 전역객체를 가리킨다. \n\n* 전역 변수와 전역객체\n    ```js\n    var a = 1;\n    console.log(a);         //1\n    console.log(window.a);  //1\n    console.log(this.a);    //1\n    ```\n* 위 결과 값이 같은이유는? \n    * 전역변수 선언시 javascrip engine이 전역객체의 프로퍼티로 할당\n    * javascript 모든 변수는 특정 객체의 프로퍼티로 등록되고 동작\n        * 특정객체: 실행컨텍스트의 LexicalEnvironment\n        * 전역컨텍스트의 경우 LexicalEnvironment는 전역객체를 그대로 참조(실행컨텍스트 도식화 그림 참고\n* 전역 변수를 접근하는 과정은? -> scope chain\n    * a에 접근하고자 하면 스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 '전역 스코프'의 LexcialEnvironment(전역객체)에서 해당 프로퍼티를 a를 발견해서 그 값을 반환하기 때문\n\n\n---\n* 전역변수와 전역객체의 차이점\n    * 전역객체의 프로퍼티로 할당한 경우에서는 삭제 o\n    * 전역변수로 선언한 경우에는 삭제 x\n\n        ```js\n        var b = 2;\n        delete b;   //false\n        console.log(b, window.b, this.b) //2 2 2\n\n        window.c = 3;\n        delete window.c;    //true\n        console.log(c, window.c this.c); // Uncaught ReferenceError: c is not defined\n        \n        ```\n\n\n## 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n### 함수 vs 메서드\n* 함수 호출시 this: 전역객체 (아래 예제코드 POINT 주석 참고)\n* 메서드로 호출시 this: 호출한 메서드\n    ```js\n    // 함수로서 호출\n    var obj = {\n        bar: function() {\n            var x = (function(){\n                        return this\n                    })();\n            return x;\n        }\n    };\n\n    obj.bar() === window //true     //POINT\n\n\n\n    // 메서드로서 호출\n    var obj = {\n        bar: function() {\n            var x = (() => this)(); // 주의: use arrow funciton\n            return x;\n        }\n    };\n\n    obj.bar() === obj\t//true\n\n    ```\n\n## 1-3 함수로서 호출할 때 그 함수 내부에서의 this\n### 함수 내부에서의 this\n* this에는 호출한 주체 정보가 담기는데 어떤 함수를 함수로서 호출시 this 지정 안됨\n* 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.\n* **실행 컨텍스트가 지정되지 않은 경우 this는 전역 객체를 바라본다 -> 따라서 함수에서 this는 전역객체를 가리킨다.** \n\n### 메서드의 내부함수에서의 this\n* 실행순서1,2,3의 return value\n    - 실행순서1: {outer: f, outer2: f} === obj1\n    - 실행순서2: window{...}\n    - 실행순서3: {obj2Property: \"obj2Property\", innerMethod: ƒ}\n\n* POINT\n    - innerFunc에 console.log는 B, C에 의해서 호출이 되는데  \n    - B처럼 innerFunc이 함수로 호출될때는 this는 전역 변수를 가르킨다.\n    - C처럼 innerfunc이 메서도로 호출될때는 this는 호출한 대상을 가르킨다.\n        ```js\n        var obj1 = {\n            outer: function() {\n                console.log(this);  //실행순서 1 by A\n                var innerFunc = function(){\n                    console.log(this);  //실행순서 2 by B, 3 by C\n                }\n                innerFunc(); // B\n\n                var obj2 = {\n                    innerMethod: innerFunc,\n                    obj2Property: 'obj2Property' \n                };\n                obj2.innerMethod(); // C\n            },\n\n            outer2: function(){\n\n            }\n        };\n\n        obj1.outer(); // A\n        ```\n\n### 메서드의 내부 함수에서의 this를 우회하는 방법\n### this를 바인딩하지 않는 함수\n> 아래 예제 주석 참고\n* log 결과값\n    * [1]: {outer: f}\n    * [2]: window {...}\n    * [3]: {outer: f}\n    * [4]: window {...}\n    * [5]: {outer: f}\n\n    ```js\n    var obj1 = {\n        outer: function() {\n            console.log(this);  // [1]\n            var innerFunc = function(){\n                console.log(this); // [2]\n            }\n            innerFunc(); \n\n            var me = this;\n            var innerFunc2 = function(){\n                console.log(me);    // [3] POINT 메서드의 내부 함수에서의 this를 우회하는 방법\n                console.log(this);  // [4]\n            }\n            innerFunc2(); \n\n            var innerFunc3 = () => {\n                console.log(this);  // [5] POINT: this를 바인딩하지 않는 함수\n            }\n            innerFunc3();\n\n        }\n    };\n\n    obj1.outer(); \n    ```\n\n\n\n## 1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n> callback function의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정  \n> **특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.**  \n> 콜백 함수에 bind를 사용하여 [2-4 bind](https://happyjy.github.io/this/#상위-컨텍스트의-this를-내부함수나-콜백함수에-전달하기)\n\n\n```js\nsetTimeout(function(){\n    console.log(this);      //window 객체 \n}, 3000);\n\n[1,2,3].forEach(function(v){\n    console.log(this, v);   //window 객체 \n})\n\n//event Callback function 참고\ndocument.body.innerHTML += `<button id=\"a\"> 클릭 </button>`\ndocument.body.querySelector('#a').addEventListener('click', function(e){\n    console.log(this, e);\n})\n\n```\n* \"button click event Callback function this\"과 \"id='a' dom\" 객체 비교 => **같다.**\n\n![](eventCallbackfunction.png)\n\n\n\n* addEventListner function 내부 구현 추측 \n    - addEventListner function this가 'document.body.querySelector('#a')' 이기 때문에  \n    이 값을 callback function을 call메서드를 이용해 명시적으로 this바인딩 할 수 있겠다.\n\n        ```js\n            addEventListener: function(a, callbackFunc){\n                ...\n                callbackFunc.call(this, event);\n                ...\n            }\n        ```\n\n## 1-5 생성자 함수 내부에서의 this\n> 생성자 함수에서 this는 생성될 인스턴스를 참조\n\n```js\nvar Dog = function(name, age) {\n    this.bark = 'RRRR';\n    this.name = name;\n    this.age = age;\n};\n\nvar hs = new Dog('행성', 2);\nvar girl = new Dog('소녀', 3);\nvar universe = new Dog('우주', 1);\n\nconsole.log(hs, girl, universe);\n/*\n    hs: Dog {bark: \"RRRR\", name: \"행성\", age: 2}\n    girl: Dog {bark: \"RRRR\", name: \"소녀\", age: 3}\n    universe: Dog {bark: \"RRRR\", name: \"우주\", age: 1}\n*/\n\nconsole.log({bark: hs.bark, name: hs.name, age:hs.age})\n/*    \n    {bark: \"RRRR\", name: \"행성\", age: 2}\n*/\n\n```\n\n* 위 두 console.log를 확인했을때 Dog에의해서 생성된 instance가 this가 된것을확인 할 수 있다.\n\n# 2 명시적으로 this를 바인딩하는 방법\n> 2 이 목차는 call(), apply(), bind()에 대해서 자세하게 다루도록 위해서 다른 포스트에서 설명하도록한다.\n[call(), apply(), bind()](https://happyjy.github.io/call(),%20apply(),%20bind())\n\n\n## 2-1 call 메서드\n## 2-2 apply 메서드\n## 2-3 call/apply 메서드의 활용\n### 유사배열객체에 배열 메서드를 적용\n### 생성자 내부에서 다른 생성자 호출\n### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n## 2-4 bind 메서드\n### name 프로퍼티\n### 상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\n```js\nvar obj ={\n    outer: function(){\n        console.log(this);               //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);           //{outer: ƒ, outer2: ƒ}\n        }\n        innerFunc.call(this);       //POINT\n    },\n\n    outer2: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          //{outer: ƒ, outer2: ƒ}\n        }.bind(this);               //POINT\n        innerFunc();\n    },\n\n    outer3: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          // window{...}\n        }                            //POINT\n        innerFunc();\n    }\n}\n\nobj.outer();\nobj.outer2();\nobj.outer3();\n\n```\n\n## 2-5 arrow function의 예외사항\n* [this를 바인딩하지 않는 함수 목차 참고](https://happyjy.github.io/this/#this를-바인딩하지-않는-함수)\n\n\n\n## 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n``` js\n    var report = {\n        sum: 0,\n        count: 0,\n        add: function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.forEach(function(arg, idx){\n                debugger;   //idx가 0일때 this -> {sum: 0, count: 0, add: ƒ, average: ƒ}    :report 객체\n                this.sum += arg;\n                ++this.count;\n            }, this);       //POINT\n        },\n        average: function(){\n            return this.sum / this.count;\n        }\n    }\n\n    report.add( 10, 20, 30 );\n    console.log({sum: report.sum, count: report.count, average: report.average()});\n    //{sum: 60, count: 3, average: 20}\n```\n* 만약 위 코드에서 POINT 부분 forEach function에 두번째 parameter \"thisArg\"가 없었다면\nthis.sum += entry;에서 this는 window객체를 가르키기 때문에 console.log 결과는 아래와 같다.\n>{sum: 0, count: 0, average: NaN}\n\n* 콜백함수와 함께 thisArg를 인자로 받는 메서드  \n```js\n    Array.prototype.forEach(callback[, thisArg]);\n    Array.prototype.map(callback[, thisArg]);\n    Array.prototype.filter(callback[, thisArg]);\n    Array.prototype.some(callback[, thisArg]);\n    Array.prototype.every(callback[, thisArg]);\n    Array.prototype.find(callback[, thisArg]);\n    Array.prototype.findIndex(callback[, thisArg]);\n    Array.prototype.flatMap(callback[, thisArg]);\n    Array.prototype.from(callback[, thisArg]);\n    Set.prototype.forEach(callback[, thisArg]);\n    Map.prototype.forEach(callback[, thisArg]);\n```\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"상황에 따라서 달라지는 this를 정리해보려고 한다.  javascripot에서 this 다른 객제지향 언어와 this의 차이점  다른 대부분의 객체지향 언어의 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Feb 01, 2020","title":"this","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["Javascript"]}}},{"node":{"rawMarkdownBody":"\n개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다.\n\n\n```js\n\t1 실행 컨텍스트란? \n\t2 VariableEnvironment\n\t3 LexicalEnvironment\n\t\t3-1 environmentRecord와 hoisting\n            호이스팅 규칙  \n            함수 선언문과 함수 표현식\n      \n\t\t3-2 scope, scope chain, outerEnvironmentReference\n            스코프 체인\n            전역변수와 지역변수\n\n\t4 this\n```\n\n\n# 1 실행 컨텍스트란? \n> * 실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> * 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념  \n> * 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(=호이스팅), 외부환경정보를 구성, this값을 설정  하는 동작 수행    \n-> 이로인해 다른언어에서는 발견할 수 없는 특이한 현상들이 발생\n\n* 코드 실행시 실행 컨텍스트\n    - '동일한 환경'에 있느 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 \n    - 이를 콜 스택에 쌓아올렸다가\n    - 가장 위에 쌓여있는 컨텍스트와 관련 잇는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장\n\n* '동일한 환경'(하나의 실행 컨텍스트)을 구성할 수 있는 방법\n    - 전역공간, evan()함수, 함수 등이 있음\n    - eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것\n\n* javascript engine 역할\n  - 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 '필요한 환경정보들'을 수집해서 실행 컨텍스트 객체에 저장\n  - 이 객체는 javascript engine이 활용할 목적으로 생성(개발자가 코드를 통해 확인할 수 x)  \n  - 담기는 정보 세가지  \n    : 목차 2, 3, 4에서 각각 더 자세하게 설명하도록 한다. \n  ```txt\n    VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. \n                            : 선언 시점의 LexicalEnvironment의 스냅샷 \n                            : 변경 사항은 반영되지 않음\n    LexicalEnvironment  : 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영\n    ThisBinding         : this 식별자가 바라봐야 할 객체\n  ```\n\n* 활성화된 실행 컨텍스트의 수집정보\n\n``` \n  * inner \n      Variableenvironment : environmentRecord(snapshot)/ outerEnvironmentReferenece(snapshot)\n      LexicalEnvironment  : environmentRecord/ outerenvironmentReferenece\n      ThisBindding\n  * outer\n  * 전역 컨텍스트\n```\n  \n# 2 VariableEnvironment\n* LexicalEnvironment와 같지만 최초 실행 시의 스탭 샷을 유지한다는점이 다름\n* 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음,  \n  이를 그대로 복사해서 Lexical environment를 만들어  LexicalEnvironment를 주로 활용하게 된다.\n* Variableenvironment, LexicalEnvironment의 내부는 **environmentRecord와 outerEnvironmentReference**로 구성\n  - 초기화 과정 중에는 사실상 완전히 동일, 이후 코드 진행에 따라 서로 달라짐\n  - 자세한 내용은 LexicalEnvironment를 통해 설명\n\n# 3 LexicalEnvironment\n* 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것 \n\n## 3-1 environmentRecord와 hoisting\n* js engine은 컨텍스트 내부 전체를 처음부터 쭉 훑어나가며 순서대로 수집 = \"호이스팅 개념\"  \n(= 식별자들을 최상단으로 끌어올려놓은 다음 실제코드를 실행-실제로 끌어 올리는 것이 아님, 편의상 끌어올린것으로 간주-)\n  - 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태\n  - 코드가 실행되기 전임에도 불구하고 js engine은 이미 해당 환경에 속한 코드의 변수명들으 모두 알고 있게 된다.\n                                                                \n### 호이스팅 규칙\n* environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다\n* 예시\n  * 함수 선언문으로 선언한 함수는 hoisting 대상\n  * 함수 표현식은 hosisting 대상 x\n\n  ```js\n  function a(){\n      console.log(b);   //ƒ b() {}\n      var b; \n      console.log(b);   //ƒ b() {}\n      function b() {};  //함수 선언문\n      console.log(b);   //ƒ b() {}\n\n      console.log(c);   //undefined\n      var c = function() {}\n  }\n  ```\n\n\n\n### 함수 선언문과 함수 표현식\n* 함수를 정의하는 세가지 방식\n  * 함수 선언문: 반드시 함수명이 정의 돼 있어야 함/ hoisiting이 됨\n  * 함수 표현식: 함수명이 없어도 됨           / hoisiting이 안 됨\n  * 기명 함수 표현식: 함수명을 정의한 함수 표현식\n\n```js\nfunction a() {} //함수 선언문\na();\n\n//상대적으로 긴 코드 속에서 함수 표현식이 안전한다.\nvar b = function() {} //(익명) 함수 표현식\nb();\n\nvar c = function d() {} // 기명 함수 표현식. 변수명: c, 함수명 d\nc(); // 실행\nd(); // error\n\n```\n\n## 3-2 scope, scope chain, outerEnvironmentReference\n* scope: 식별자에 대한 유표범위\n  * ES5까지의 자바스크립트는 특이하게도 전역 공간을 제외하면 오직 함수에 의해서만 스코프가 생성\n* scope chain: 이런 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것\n* outerEnvironmentReference: 스코프체인을 가능하게 하는 것이 바로 Lexicalenvironment의 두번째 수집자료인 outerEnvironmentReferenece\n\n### scope chain\n* outerEnvironmentReferenece는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조\n  - 아래 예시1 scopechain 도식화 참고\n* 과거 시점인 '선언될 당시'는 행위가 실제로 일어 날 수 있는 시점이란?  \n  - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐\n  - 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문\n\n* scope chain 예1\n  1. A함수 내부에 B함수 선언, B함수 내에 C함수 선언\n  2. 함수 C의 outerEnvironmentReferenece는 함수 B의 LexicalEnvironment를 참조 \n  3. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReferenece는 ***다시 함수 B가 선언되던 때*** A함수의 LexicalEnvironment를 참조 \n  4. 이처럼 outerEnvironmentReferenece는 연결리스트 형태를 띤다.\n  5. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것'  \n\n* 위 예시로본 특징 \n  - 예시 3번에서 본것 처럼 각 outerEnvironmentReferenece는 오직 자신이 선언된 시점의 LexicalEnvironment만 침조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능\n  - 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능** \n\n* scope chain 예1 코드\n```js\n/*01*/ var a = 1;\n/*02*/ var outer = function () {\n/*03*/   var inner = function () {\n/*04*/     console.log(a);\n/*05*/     var a = 3;\n/*06*/  };\n/*07*/   inner();\n/*08*/   console.log(a);\n/*09*/ };\n/*10*/ ouer();\n/*11*/ console.log(a);\n```\n* scope chaing 예1 코드 도식화\n    * 그림을 보면서 라인별로 어떤 동작을 하는지 생각해보자\n    ```\n      LE: Lexical Envinronment\n      e: environmentRecord\n      o: outerEnvironmentReference\n    ```\n    ![](context.jpeg)\n\n\n* **전역 컨텍스트 활성화**\n  * 0: LexicalEnvironment, VariableEnvironment, thisBinding\n\n* 전역 컨텍스트 생성/ outer 함수 호출\n  * 1,2: a에 1, outer에 함수 할당\n  * 10: outer 함수호출, 전역 컨텍스트 비활성화\n  * 2: outer실행 컨텍스트 활성화\n\n* outer 컨텍스트 생성/ inner 함수 호출\n  * 3: inner에 함수 할당\n  * 7: inner 함수 호출, outer 실행 컨텍스트 비활성화\n  * 3: inner 실행 컨텍스트 활성화 \n\n* inner 함수 수행\n  * 4: inner의 LE에서 a 탐색 -> undefined 출력\n  * 5: a에 3할당\n\n* inner 컨텍스트 종료 \n  * 6: inner 함수 종료, inner 실행 컨텍스트 제거\n  * 7: outer 실행 컨텍스트 재활성화\n  * 8: outer의 LE에서 a탐색 -> GLOBAL의 LE에서 a 탐색 -> 1출력\n\n* outer 컨텍스트 종료 \n  * 9: outer함수 종료, outer 실행 컨텍스트 제거 \n  * 10: 전역 컨텍스트 재활성화 \n  * 11: GLOBAL의 LE에서 a탐색 -> 1출력\n\n\n* outer컨텍스트 \n\n```js\n\"전역 컨텍스트\": {\n    environmentRecord: 'a, outer function',\n    outerEnvironmentReferenece: null,\n    this: window\n}\n\n\"outer컨텍스트\": {\n    environmentRecord: ['inner function'], \n    outerEnvironmentReferenece: 'GLOBAL LexicalEnvironment',\n    this: window\n}\n\n\"inner컨텍스트\": {\n    environmentRecord: ['a'], \n    outerEnvironmentReferenece: 'outer 컨텍스트',\n    this: window\n}\n```\n\n### 전역변수와 지역변수\n* 전역변수: 전역 공간에서 선언\n* 지역변수: 함수 내부에서 선언\n\n# 4 this\n* 실행컨텍스트의 thisBinding에 this로 지정된 객체가 저장\n* 실행컨텍스 활성 당시 this가 지정되지 않은경우 \"전역객체\" 저장\n* 함수 호출하는 방법에 따라 this가 달라진다.(this에 대해서만 내용을 다룰 예정)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n* 제로초 블로그\n","excerpt":"개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다. 1 실행 컨텍스트란? 실행컨텍스트(execution context…","fields":{"slug":"/Excute-context/"},"frontmatter":{"date":"Jan 24, 2020","title":"실행 컨텍스트","tags":["Javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["Javascript","ES6"]}}},{"node":{"rawMarkdownBody":"\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말할 수 있는 아니었다.\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있어 연예인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴져 멋있었고 떠먹기만 하면 되는 상황에서 감사한 마음이 들었다. 그래서 한편으론 실제로 적용하는 생각 연습과 다른 사람에게 효과적으로 전달 할 수 있는 고민을 하고 싶었다. (그래서 블로그에 자바스크립트 내용을 정리하는 연습을 해보려고 한다. -현재(2020.01 시작) 진행 중-) 그리고 책을 보면서 업무를 하며 익혔던 자바스크립트 내용을 상기하는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\njavascript를 더 깊게 알고 싶은 분에게 추천해주고 싶은 책이다.\n\n\n","excerpt":"이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트후기/"},"frontmatter":{"date":"Jan 20, 2020","title":"코어자바스크립트 후기","tags":["Javascript","독서후기"]}}},{"node":{"rawMarkdownBody":"\n우연한 계기로 이 책을 읽고 신영준, 고영성 작가를 알게 돼서 `꾸준하게` 공부해서 `실력`을 높여야 한다는 것을 깨닫고 2018년 여름 패스트 캠퍼스를 다니기 시작한 여름부터 지금 작성하는 2020년 2월까지 약 1년 8개월 동안 Javascript 개념 정리, 토이프로젝트로 Instagram clone coding, 알고리즘 공부, 코드 스피츠 자바스크립트로 배우는 객체지향, 그리고 이를 이용하는 다양한 디자인 패턴 등 꾸준하게 업그레이드 할 수 있는 계기가 될 수 있었다.\n\n개발 공부를 `교양`으로 생각하고 취미 활동이라고 여기고 있다. 이전에 공부해야 하는데 라고 생각만 했을 때는 공부는 하지 않고 해야 한다고 스트레스만 받고 취미인 운동하러 가기 바빴다. 하지만 지금은 업무 수행하면서 궁금한 것을 기록했다 이후에 찾아서 정리하고, 토이프로젝트도 해보고, 커뮤니티도 참가해보고, 어떻게 하면 좀 더 능동적이고 성장하는 개발자가 되기 위해서 고민하고 있다.\n\n이렇게 터닝포인트가 된 책이기에 아래와 같이 정리하는 계기가 됐다.\n\n\n   \n# 1 믿음 : 공부는 믿는대로 된다.\n## a 자신을 믿지 않을때 잃어버린 믿음 세가지\n* 기대(Expectation)\n* 마인드셋(mindset)\n    1. 자신을 바라보는 사고방식    \n    2. 과제를 수행할 수 있다는 자기 능력에 관한 믿음\n\n## b 믿음, 기대를 되찾는 방법\n* 성공경험\n    - 기대수준을 낮춰 작은 성공에 도전\n* 강점주목\n    - 성적F에 집착 하지 않고 A의 강점을 마음에 품을 때 미래를 낙관적으로 바라 볼 수 있다.\n    - 기대는 강점을 먹고자란다.\n* 의미와 가치부여\n    - 니체는 살아야 할 이유를 아는 사람은 거의 어떠한 상태에서도 겨딜 수 있다.\n* 성장형 사고방식\n    - 실패를 해석하는 관점\n    - 성장형 사고방식을 하는 방법 6가지 항목\n        * 자기관점\n            - 지능과 성격은 변한다고 믿는다.\n        * 도전\n            - 자신을 성장시키는 초석\n            - 도전으로 많은 정보를 얻는다.\n        * 실패\n            - 더 많은 것을 배우고 성장한다.\n        * 노력\n            - 성장은 무조건 따라 오는 것\n        * 비판\n            - 비판으로 성장하고 개선된다고 믿는다.\n        * 다른사람의성공\n            - 다른 사람의 성공을 보며 배울 점을 찾으려고 노력\n\n## c 성장형 사고방식을 형성하는 방법 \n* 뇌의 가소성을 믿는다(뇌는 성장한다는 믿음을 갖는것)\n* 실패에 대한 개념을 바꾸는 것(실패 = 성장을 위한 발판)\n\n## d 자기효능감 \u000b: 어떤 것을 달성할 때 필요한 행동을 조직화하고 시행하는 개인의 능력에 관한 믿음\n* 자기효능감 높이는 방법\n    - 권위 있는 사람이 자신의 잠재력을 믿어 줄 때 자신도 그 잠재력을 믿는다는 것(\"김영훈 상무님\")\n    - 자기 잠재력을 인정해 줄 사람이 없다며 슬퍼하지 말자.\u000b결국, 믿는 주체는 다른 사람이아니라 자기 자신이다.\u000b이책으로 당신의 잠재력이 어마어마하다는 것을 과학적인 근거를 갖고 계속 말 해 줄 것이다.\n    - Eg\u000b고등학교 중퇴한 토드/ 아버지가 공부를 더 하라고/ 부모님은 토드를 믿었다./ 학교생활은 지옥, but 토드가 버틸 수 있었던 것은 부모님의 사랑과 믿음 때문/ 신뢰에 힘 얻어 무엇이든 더 잘할 수 있다는 믿음도 생김/ 더 높은 학위까지 성취\n\n## e 왜공부해야하는가 ?  - 신영준 박사 통찰\n* 소통\n    - 핵심: 서로의 존재를 인정해 주는 것\n    - 존재 = 뇌 = 사고(생각) = 정체성\n    - 존재를 인정해주는 것 = 정체성을 인정해주는 것 \n    - 생각을 온전하게 표현하고 이해하여 제대로 된 소통을 하는 데 가장 밑 받침이 되는 행동이 바로 공부\n* 생존\n    - 멱법칙\n\n* 즐거움\n* 나눔\n\n## f 고영성 작가 심화\n* 공부를 열심히 하면 -> 머리가 좋아진다. 죽을때까지\n* 내 뇌를 믿으며 제대로 된 방법으로 노력해야한다.\n        \n          \n     \n# 2. 메타인지 : 나를 모르면 공부도 없다.\n\n## a 자신이 무엇을 알고 무엇을 모르는지를 알기 때문에 자신의 장점을 극대화하고 자신의 단점을 최소화할 학습 전략(공부법)을 창조할 수 있다.\n\n## b 0.1% 아이들은 하루에 3시간은 개인 공부 시간을 갖는다.\n\n## c 메타인지 종류\n* 메타기억 : <기억> 장에서 다룸\n* 메타이해 : 자신이 언어를 잘 이해하는지를 아는 능력\u000b: 내용을 이해했지만 답변을 못하면 메타이해가 떨어진다고 볼 수 있다.\n    - 메타이해에 관한 질문들 7\n        * 내용을 제대로 이해하지 못했거나 주의를 기울여 읽지 않았음을 알았을 때 그부분을 다시 세심하게 읽는가? \n        * 짧은 단락을 읽고 자신의 말로 요약해 보는가 ? \n        * 책을 읽을 때 요약 정리된 부분이나 연습문제를 꼭 푸는가 ? \n        * 책에 나온 아이디어를 서로 연계시켜 보려고 노력하는가 ? \n        * 자신이 모르는 용어가 나왔을 때 사전이나 검색을 통해 용어를 완전히 이해하려고 노력하는가 ? \n        * 시험 공부를 할 때 자신이 어렵다고 여기는 부분에 더 많은 시간을 할애하는가 ? \n        * 읽은 자료들의 필요성에 대해 평가하고 적절히 분류해서 정리하는가? \n\n## d <메타인지를 높일 수 있는 방법 3>\n* 학습 전략을 배움\n* 자신의 실제 실력을 객관적으로 파악하는 피드백을 경험\n    - 연습문제, 내용요약, 가르쳐보기 -> 무엇을 할고 모르는지 제대로 확인 가능\n* 인간의 인지과정을 알면 메타인지 상승\n    - 나의 인지 과정에 대한 인지 능력(= 우리가 세상을 어떻게 인지하는지를 안다면 메타인지는 향상된다.)\n\n## e <Thinking, Fast and Slow>\n* Thinking Fast \n    - 오래 생각하지 않는 행위\n    - 자동적, 즉각적 노력과 수고가 거의. 들지 x\n* Thinking Slow\n    - 집중 요구(=수고, 노력이 든다)\n* Eg\n    - 시험 범위의 내용을 두세 번 반복해서 읽고 그 내용을 다 이해한 것 처럼 느끼는 시스템1(= fast thinking)의 한계를 알고 시스템2(=fast thinking)연습문제, 가르침을 통해 한꼐를 극복\n\n## f <인지의 한계 9>\n* 메타인지 능력을 향상하기 위해 알아야할 9가지\n* 기억력 착각\n        \n* 소박한 실재론\n    - 자신이 세상을 제대로 보고 있다고 순진하게 믿는것\n* 사후해석 편향\n        \n* 계획 오류\n    - 실향력에 대한 과대평가\n* 정서 예측 오류\n    - 자신의 미래 감정을 잘 못 예측하는 것\n* 평균 이상 효과\n    - 자신의 공부에 대한 노력이나 일을 평균 이상한다고 여긴다.\n* 확증 편향\n    - 자신이 처음 생각했던 주자엥 지지하는 근거만을 찾는 경향\n* 가용성 편향\n    - 내 기여도를 과장하는 것\n    - 가용성 평향에 파묻히면 좋은 팀워크는 지속할 수 없다.\n* 권위자 평향\n    - 권위자의 말이라면 제 생각도 기꺼이 바꾸는 것\n\n## g 신영준 작가의 통찰\n* 연습문제와 씨름 하면서 내 학습 수준을 확인하고 부족하면 다시 더 공부해서 그 내용을 온전하게 소화해 내는 것이 올바를 학습방법\n* 지식의 저주\n    - 상대방이 무엇을 알 고 있으며 어떤 상태이고 어떤 사람인지에 과한 것\n    - 메타 인지가 나에 관한 지식과 관련됐다면 지식의 저주는 타인에 관한 지식과 관련이 있다.\n    - 책: 누구나 처음엔 걷지도 못했다. (지식의 저주 관한 이야기)\u000b\n\n# 3. 기억 : 기억력은 타고나는 것이 아니다.\n\n## a 기억이란 무엇인가 ? \n* 기억이란 ? \n    - 중용한 것은 기술이고, 기억이 작동하는 법을 이해하는 것\n* 공부를 잘하기 위해서 우리가 알아야 할 첫 시작\n    - 집중력!(주의)\n* 주의&전두엽\n    - 전두엽 : 뇌에서 의사결정을 담당하는 CEO역할\n    - 20대 중 후반까지 성장\n    - 전두엽 발달이 미비-> 제대로 된 주의력을 발휘할 수가 없다.\n\n## b 주의에 대한 이해와 멀티태스크의 허구\n* 주의력을 키우는 가장 좋은 방법\n    - 공부를 많이한다.\n    - 공부를 계속하다 보니 주의력, 집중력이 좋아 졌다.\n* 멀티태스크\n    - 한번에 여러가지일 -> 거짓말\n    - 음악 : 가사가 있는 음악(X), 연주곡 (ok)\n\n## c 단기기억은 기억 저장소 인가 ? \n* 정신속에 상호 관련된 정보들을 동시에 유지하면서 '작업(working)' 하고 그것을 적절히 사용하도록 한다\n* 단기기억 = 작업기억\n\n## d 4가지 작업대\n> 음운회로(phonological loop)\u000b  \n> 시공간 메모장(visual-spatial sketchpad)\u000b  \n> 일화완충기(episodic buffer)\u000b  \n> 중앙집행기(central executive)\n\n* 음운회로\n    - 단어를 읽을 때 속으로 이 단어를 소리 내었음을 알 수 있는 것(=하위발성-subvocalization)\n    - 짦은 시간 동안 제한된 수 안에서 활성화\n* 시공간 메모장\n    - 시각과, 공간정보를 처리\n* 일화완충기\n    - 이전 경험들을 해석하고 새로운 문제를 해결하며 미래 활동을 계횓하도록 능동적으로 조작하는곳\n    - 임시 저장 체계, but 여기서 생성된 개념이나 복잡한 심상은 장기기억속에 저장\n* 중앙집행기\n    - 공부 방법 선택, 수학문제를 어떻게 공략할 것인지\n* 법칙\n    - 숫자 암기 => 음운회로\n    - 공간 추리관제 => 시공간 메모장\n    - 독서는 음운회로와 연관\n    - 중앙집행기 언어능력, 읽기이해, 추론능력, 노트 필기 기술 등 공부 전반에 걸쳐 밀접한 관계\n    - 주의력결핍 과잉 행동장애(ADHD)중앙집행기 과제를 잘 수행하지 못한다.\n    - 시공간메모장을 음운회로로 치환하지 않도록 노력한다.\n    - 위대한 과학자, 예술가들은 심상을 통해 대상을 이해하는 겨우가 매우 많았다.\n    - 오히려 말로 설명 하기 힘든것들이 많다.\n\n## e 장기기억이란 무엇인가?\n* 작성대기\n\n## f 강의듣기와 반복 읽기의 허상\n* 1퍼센트의 학생들은 개인 공부 시간을 확보(최소 3시간)\n* 뇌는 해야 할 일을 안하고 있기 때문\n* 강의는 열심히 공부한 것이 아니다.\n* 반복읽기 & 암기\n    - 좋지 않음 \n    - 왜할까 ? \n    - 가장 쉽고 간편\n    - 복습할때 연습문제, 요약/구술 귀찮으니까.\n    - 소화했다는 착각\n\n## g 기억전략 1-5\n* 기억전략1 : 시험 효과\n    - 연습문제 -> 장기기억 상승, 메타인지 상승\n    - 인출이 중요하다!(장기기억으로 가는 최선의 길)\n* 기억전략2 : 인출효과\n    - 시험, 암송, 요약, 토록, 발표, 관련된 글을 쓰는 것\n    - 잊지 말자. 어렵게 공부하면 잊기 어렵다.\n    - 아는 내용이라 할지라도 인출 경험이 없는 질문이 나오면 유창하게 대답을 하지 못한다.\n    - 김영훈이사님이 daily 계획 엑셀을 만들면서 연습하지않았나 생각\n* 기억전략3 : 분산 연습 효과\n    - 연속으로 연습 -> 단기기억이 주로 일을 하게 되면서 내용을 완전히 숙지 한듯 보이지만 실제로 장기기억으로 많이 가지 않게 된다.\n    - 간격을 두고 학습하게 되면 두번째 학습할 때 약간의 어려움을 겪게 된다.\n    - 뇌를 더 적극적으로 활용하면 장기기억으로 갈 활률이 올라간다.\n    - 전문가들은 보통 하루 정도의 간격을 두고 공부할 때 매우 효과적\n* 기억전략4 : 교차효과\n    - 교차로 수학 문제를 풀면 쉽다는 느낌이 덜 들게된다. \n    - 뇌가 더 공새하게 되면서 뇌의 신경섬유 연결이 더 활성화된다.\n* 기억전략 5 : 그외 5가지\n    - 자기 참조효과\n    - 정보를 자신과 관련시킬 때 우리는 더 많은 정보를 기억 할 수 있다.\n    - 맥락 효과\n    - 공부할 때의 맥락과 유사할 때 기억을 잘해낼 수 있다.\n    - 시험을 보는 비슷한 시간, 비슷한 장소에서 비슷한 시험 유형으로 공부한다면 실제 시험에 큰 도움이 된다.\n    - 심상 활용\n    - 이미지 활용\n    - 1-닭 치킨이 담배를 피우는 이미지\n    - 조직화\n    - 분류화(범주화)\n    - 첫 낱자 조홥 기법\n\n## h 신박사의 통찰\n* 임생을 바꾸는 암기의 힘\n    - 예 영어단어 암기\n    - X개 단어암기(기간 측정) -> 시험 -> x개 익숙\n          X개 익숙 -> x+a개 단어암기 -> 시험 ………..\n    - 암기는 운동으로 따지면 기초체력\u000b그 어떤 운동도 기교를 따지기 전에 기초체력이 충분히 쌓여야 한다.\n* 고작가의 심화\n* 플로우(flow): 일에 푹 빠져 있는 상태\n* 무아지경 : 자아에 대한 의식이 사라진다.\n    - 건설적이 일이라면 자존감은 더욱 상승(몰입 이후에 더큰 자아존중감을 느끼게된다.)\n* 몰입-> 행복감 -> 쾌감\n      \n      \n      \n# 4. 목표 : 성공적인 목표 설정은 따로 있다.\n\n## a 목표는 왜 중요한가?\n* 현재 우리가 무엇을 해야 하는지 알려준다.\n* 강력한 동기부여\n    - 성취했을 때 없던 힘도 생기고 노력한다.\n* 준거점이 있을때 현재의 모습을 제대로 볼 수 있다.\n\n## b 성장 목표와 증명목표\n* 성장목표\n    - 노력으로 성장한다는 믿음\n    - 실수,실패 -> 무언가를 배우는 경향\n    - 스스로 질문, 요약등 효과적인 공부 전략을 적극적으로 활용\n* 증명목표\n* 결론\n    - 성장목표의 비중을 높이는 것이 학업성취도뿐만 아니라 행복한 인생에도 무조건 유리\n    - 증명목표 사고를 가진 사람은 겨로가 중심의 사고를 할 수 밖에 없다.\n\n## c 증명 목표의 부작용 1. 편법\n* 원하는 결과를 얻을 수 있지만, 성장은 하지 못한다.\n\n## d 증명 목표의 부작용 2. 회피\n* 어린 신동 > 타고난 능력으로 칭찬 > 고정형 사고 방식을 갖고 증명 목표에 메달릴 가능성 높다.\n* 독창성은 실패를 먹고 자란다.\n* 과감한 시도로 인간은 잠시 자신의 위치를 잃을 수 있다. 그러나과감한 시도가 없으면 인간은 자기 자신을 잃는다. - 쇠란 키르케고르\n* 공부의 궁극적인 이유 \"성장\"\n\n## e BHAG목표: 크고 위험하고 대담한 목표\n* Big Hairy Audacious Goal, 장기목표\n* 사람의 감정을 움직이게 한다.\n* 어떻게 장기 목표에 접근할가 ? \n    - 왜 일하는지 스스로에게 계속 묻자\n    - 당신이 가장 존경하는 사람을 떠올려 보자\n    - 그사람이 어떻게 살아 왔는지 삶을 벤치마킹해보자\n    - 인생의 마지막 때를 생각해 보자.\n    - 어떤한 인생을 살았을까? 무슨 일을 하고 살았을까?\n\n## f BHAG목표의 단점\n* 두가지 환상, 포기\n* 환상 : 상상 속에서만 존재하는 목표를 이용해 환상에 빠진다.\n* 포기 : 도전적이고 멀게 느껴질 때\n* 결론 : 그래서 SMART 목표가 필요\n\n## g SMART 목표\n\n## h 시간관리\n* 통찰 : 목표 달성의 재구성\n* 심화 : 산티아고가 내게 준 선물\n    \n# 5. 동기 : 내게 자유를 달라\n## a 동기를 상실한 사람들\n* 심리적 기능\n    - 행동에 활력\n    - 행동에 방향성\n    - 행동의 지속성\n* 동기부여가 제대로 된 학생들 특징\n    - 학교에 대한 긍정적 태도\n    - 어려운 과제를 포기하지 않음\n    - 정보를 깊은 수준으로 처리하고 학급에서의 학습경험이 뛰어남\n\n## b 내재적 동기와 외재적 동기\n* 내재적 동기가 더 중요\n* 자율성\n    - 미래를 기대, 성장형 사고방식, 자신의 잠재력 믿음, 목적의식을 확고히 하는 것 만큼이나 아주 강력한 내재적 동기를 불러 일으키는 것\n        \n\n## c 자율성과 내재적 동기\n\n## d 자율성과 공부\n* 선택권\u000b80문제중 어떤 과목을 풀지 몇 문제를 풀고 싶은지\n* 권한\u000b결정한 문제의 수만큼만 풀어도 되며 교식을 자유롭게 돌아다닐 수 있는 권한\n* 결과\u000b선택권, 권한을 가진 아이들은 문제를 풀 때 끝까지 집중력을 잃지 않았으며, 무엇보다 문제를 쉽게 느끼고 문제 풀이 자체를 즐거워했다.\n\n## e 동기부여의 임계점 그리고 확산\n* 영어 학원 다녀도 성적이 오르지 않을 때 \n    - 일주일에 500개 외우면\n    - 자녀에게 장학금 지급(=학원비)\n* 동기 = 심장\n    - 심장이 멈출때 외부에서 강력한 전기 충격\n\n## f 자율성\n*  스스로 의사결정 가능\n* 주도성을 갖게 하고 책임감을 느끼게 \n* 스스로 통제할 수 있다는 마음을 갖게 한다.\n* 주도성, 책임감, 통제감은 그 어떤 것보다 내적 동기를 불러일으키기 때문에 더 높은 업무 성과를 내는 것\n      \n# 6. 노력 : 노력은 결코 배신하지 않는다\n## a '1만 시간의 법칙'은 틀렸다?\n\n## b 노력은 절대적이다\n* 성장에 있어서 핵심은 홀로 공부하는 것\n* 최상위 학생들\n    - 하루에 개인적으로 3시간 이상 확보(== 스스로 부딪치는 시간)\n    - 수면을 부족하게 하지 않음(수면부족 = 효율 down)\n* 일이 괴로울때 극복유무\n    - 각 분야에 전문가로 성장할 수 있느냐 없느냐를 가늠\n\n## c 재능 결정론의 허구\n* 임계점 돌파\n    - 초반에는 힘든, 어느 정도 수준만 올라서면 그 일에 능숙해지고 더 잘하게 된다는 사실\n    - 도전하는 사람의 나이, 상황, 환경에 따라서 아마추어때 뒤쳐지지만 전문가가 되어서는 압도적인 성과를 내는 경우도 있다.\n\n## d 자제력의 힘\n* 의지력, 인내력, 버티는 힘, 그릿(절대 포기하지 않는 태도), 성실성, 근면성 등 노력을 이끌어 내는데 자제력이 큰 역할을 한다는 것이 증명되었다.\n* 노력을 지속할 힘\n    - 믿음, 목표, 동기부여\n    - + '자제력' : 장기 보상을 위해 단기 충동을 억제 능력\n\n## e 1만 시간은 법칙을 틀렸다.\n* 제대로 된 방법으로 노력해야한다. (= 의식적인 연습)\n\n## f 재능을 키우는 '의식적인 연습'\n* 훌륭한 방법 = 노력의 효율을 몇배나 올려주기 때문\n* 의식적인 연습의 7가지 특징\n    - 일정 수준 이상 체계적으로 정립된 방법론으로 연습해야한다.\n    - 자신의 능력보다 조금 더 어려운 작업을 지속해서 해야한다.\n    - 구체적이고 명확한 목표로 연습한다.\n    - 신중하고 계획적이다.\u000b(= 개인공부시간을 무조건 많이 늘려야 한다.)\n    - 기초를 충실하게 마스터해야한다.\n        (= 고급으로 가기 위해서는 초급, 중급은 필수)\n    - 심성 모형을 만들어 내는 한편 거기에 의존\n    - 피드백과 피드백에 따라 행동을 변경  \n        \n\n## g 심성 모형을 키우는 3F 효과\n* 심성모형이란?\n      - 메타인지 향상과 장기기억 확장을 통해 양과 질을 향상하는 것\u000b\n      - 자기 자신이나 다른 사람 또는 특정 환경 속에서 상호작용하는 사물에 관해 어떤 모형을 갖는 것\n      - 현재 상태 뿐 아니라 미래 예측까지도 잘할 수 있게 된다.\n      - 바둑고수  \u000b\n        * 수천 판 이상 바둑을 두면서 셀 수 없이 많은 패턴을 외우고 각 수가 가진 의미에 대해서 엄청난 고민을 했던 사람들\n        * 단기기억의 한계를 극복\n        * 바둑판에 놓인 말들의 패턴을 한눈에 파악하는 능력을 지님\n* <u>**마태 효과(Matthew Effect)**</u>\n    - </u>**많이 아는자가 더 많이 아는 상황**</u>\n    - </u>**공부는 하면 할수록 효율이 붙는다는 사실**</u>\n* **의식적인 연습**\n    - 피드백을 통해 현재 내가 무엇을 알고 무엇을 모르는지를 알고\n    - 명확한 계획과 실행이 가능 효과적인 전략도 다시 세울 수 있다.\n* **심성모형을 훌륭하게 키우기 위한 3F**\n    - Focus\n        - 마음가짐, 집중할 수 있는 환경\n    - Feed Back\n        - 연습문제 풀기, 수시로 시험보기, 토론하기, 발표하기를 통해\n        - 자신이 실제로 얼마나 알고 있는지를 확인하는 셀프 피드백\n        - 효과 : 메타인지, 장기기억\n    - Fit\n        - 피드백 \u000b-> 자신의 모습확인\u000b-> 그 조건에 맞게 전략을 수정, 계획을 수정, 행동 수정\n        \n\n## h 노력은 배반하지 않는다!\n* 제대로 된 노력은 결코 당신을 배반하지 않는다.\n      그리고 전문가, 프로의 반열에는 오를 수 있다.\n* 신박사의 통찰(=Y수석의 비밀)\n* 노력 = 제대로 + 꾸준히 = 질문하면서 열심히\n* 전공 서적 한 분기에 1권씩 -> 1년이면 8권\n      \n    \n# 7. 감정 : 감정은 공부의 안내자다\n\n## a 5세 아이의 한글 교육은 득일까?\n* 어린아이 한글교육 주의 점 두가지\n    - 7세 전까지 부모가 많이 읽어주자\n    - 7세 전까지는 문자를 외우는 것이 크게 중요하지 않음\n    - 5세 아이는 듣는데 천재, 읽는데 바보\n        * 듣기 : 효율성 높게, 다양한 어휘와 복잡한 문장을 듣는다.\n        * 읽기 : 효율성 낮게, 알고 있는 어휘와 매우 단순한 문장을 힘겹게 읽는다.\n    - 감정은 학습과 밀접한 관계\n    - 한글 공부는 부모가 교육\n    - 부모는 전문교육자가 아님\n    - 아이가 못할 때 감정적 대응\n    - 아이는 감정이 상한다.\n\n## b 감정과 학습\n* 효율적인 기억력 방법 : 기억 할 때 감정의 자극을 받을수록\n\n## c 부정적 감정 VS 긍정적 감정\n* 긍정적 감정일 때 효율적으로 공부 할 수 있다.\n* 예) 삼곡초 수학시험, 골프 퍼팅\n\n## d 시험 불안 해소하기\n* 불안 잠재우기 방법\n    - 정서명명 : \n    - 불안에 대해 상세히 설명, 글을 쓰는 것(잊으려고 노력하는 것이 아니라)\n    - 지금 느끼는 불안에 대해 이성적으로 설명, 글 -> 자신도 모르게 불안이 잠잠 해짐을 느낀다고 한다.\n* 평소 긍정적 에너지 유지 하는 방법 \n    - 부정적 감정이 들 때마다 그것을 긍정적인 단어로 재정의\n    - 매일 감사 일기\n    - 친한 친구들과 서로에 대한 장점을 이야기 하는 시간\n          \n\n## e 시험과 유전자\n* 콤트 유전자 전사형, 걱정쟁이형, 중간형\n* 도파민 대표적인 동기 부여 호르몬\n* 전사형 > 걱정재이형 : 시험에서 좋은 성적\n* 사소한 것들을 걱정하기에는 인생이 너무 짧다 -19세기 소설가 찰스 킹슬리-\n\n## f 신박사의 통찰(관심이 생겼다면 일단 반은 성공이다!)\n* 어떤 일을 하든 간에 감정에 크게 좌우\u000b-> 어떻게 즐겁게 업무 혹은 공부를 할 것인가에 대한 고민도 꼭 하자\u000b너무 무작정 열심히 하려고만 하지 말고 \n\n## g 고 작가의 심화\n* 행복 : 집단주의 vs 개인주의 -> 개인주의 win\n    - 개인의 가치와 감정을 최대한 존중하고 수용하는 문화가 생복을 만든다\n    - 집단주의는 심리적 자유감이 부족하다.(= 내 마음대로 살다간 비판받기 일쑤)\n    - 행복의 조건중 하나 : 사람(가장큰 사망 요인 = 외로움)\n* 행복 관련 책\n    - 행복의 기원-서은국 교수\n    - 행복의 조건-조지 베일런트\n    - 당신이 지갑을 열기 전에 알아야 할 것들-엘리자베스던과 마이클 노튼\n\n## h 동기부여의 임계점 그리고 확산 \n\n# 8. 사회성 : 함께할 때 똑똑해진다.\n\n## a 진정한 사회적 동물\n* \"아리스토텔레스\" <정치학>\n    - 사회적이 아닌 개체는 하찮은 존재이거나 인간보다 높은 수준의 존재이다. 사회는 본질적으로 개체보다 우위에 있는 어떤 것이다. 공동 생활을 영위할 수 없거나, 혹은 공동생활의 필요성을 느끼지 않을 만큼 자급자족이 가능한, 그래서 사회의 일원이 되지 않는 존재가 있다면, 그것은 짐승이거나 신이다.\n\n## b 외로우면 멍청해진다\n* 외로움은 한 사람의 지적 과제 수행 능력을 떨어뜨린다. 자재력을 끌어내리고, 니능 지수도 낮춘다. \u000b이에 따라 청소년과 대학생들의 내신과 시험 성적 또한 끌어내린다. 뿐만아니라 직장인의 업무 능력도 저하시킨다.\n\n## c 외로우면 건강을 잃는다\n* 외로움을 느끼는 것만으로도 지적 능력이 저하되고 신체 기능마저 나빠진다.\u000b즉 공부에 크나큰 적\n\n## d 우정이 똑똑하고 건강한 사람을 만든다\n* 우정의조건\n    - 익숙함\n    - 물리적 근접성\n    - 유사성\n    - 서로의 비밀\n* 결론\n    - 같은 목적을 가진 사람들과 함께 고웁하며, 서로의 고충을 나누고 격려하고, 더 나아가 서로를 가르치는 행위까지 한다면 외로움도 없애고 기억력도 상승시키는 1석2조의효과를 누릴 수 있다.\n    - 그리고 만약 그 모임이 지속하며 모두에게 소속감까지 준다면 공부 효율은 상상할 수 없을 만큼 올라갈 수 있다.\n\n## e 한줄 요약\n    - 진정한 우정과, 소속감을 느낀다면 똑똑해진다.\n\n## f 대인관계가 성공을 결정짓는다.\n* 대인관계의 중요성을 미리 알고 공부하고 실천하며 살아간다면 일에서뿌만아니라 삶에서 긍정적인 일들을 기대할 수 있기 때문이다.\n* 대인관계에서 가장 중요한 덕목 하나를 뽑으라고하면 '공감능력'이다.\n\n## g 공감능력의 힘과 소설 읽기\u000b: 대인 관계의 기본\n* 공감능력 발달 두가지 방법\n    - 많은 사람과 만남 \n        * 다양한 상황과 여건에서 사람들과 부딛히다 보면 자연스럽게 상대방의 몸짓과 표정을 읽게 되고 상대방의 마음을 헤아리게 된다.\n    - 문학 소성 읽기\u000b\n        * 주인공, 그 인물을 둘러싼 다양한 군상들에 대해 심리를 해석하게 됨으로 타인의 마음을 읽을 수 있는 연습을 할 수 있다.\n\n## h 대인관계를 높이는 7가지 기술\u000b: 대인관계 높이는 기본 -공감능력-\n* 일관성\n    - 관계중 좋은 순위 \u000b긍정적 관계 > 부정적 관계 > 양면적 관계\n    - 양면적 관계가 최악\n        * 이유1 : 상대방이 어떻게 나올지 모르기때문에 불안정감을 느낀다. (사람은 적응을 잘하기때문에 부정적 관계도 적응을 잘할 수 있다.)\n        * 이유2 : 스트레스 지수, 우울증, 삶에 대한 불만이 상대적으로 더 크다는 것\n        * 이유3 : 친한사람은 어떻게 반응할지 안다는 것이다. 그래서 편한다.\u000b\n* 존중\n    - 직장 동료를 존중할때 직장생활이 행복하다고 느낀다.\n    - 존중 받으려면 존중해야한다.\n* 경청\n    - 타인의 말을 진실하게 경청하는 능력이 결합된 인물일수록 동료들에게 신망을 얻는다.\n    - 적극적 듣기 자세 방법\n        * 말하는 사람쪽으로 약간 기울인다/ 눈을 마주친다/ 고개를 끄덕인다.\n* 조언\n    - 성공적으로 임원이 된 사람들은 상사에게 조어을 자주 구한다.\n    - 조언을 구하는 자는 뭘 모르는게 아니다 뭘 좀 아는자다.\n* 겸손\n    - 지위가 낮은 사람일수록 다른 사람의 관점을 잘 읽는다는 연구 결과가 있다.(UC버클리대학의 대처 케트너 교수팀)\n    - 교만 : 타인의 마음을 읽는 능력을 상실\n    - 겸손 : 마음을 헤아리는 능력을 상승\n* 칭찬\n    - 다른 사람에게 인정받는 것 만큼 행복한 것은 없다.\n    - 칭찬이 진심이 아니라는 것을 알면서도 칭찬하는 이를 좋아하는 사람이 있다.(그렇다고 남발하지 말자/ 상황, 사람을 보며 눈치것 하자)\n* 실수\n    - 실수효과\n        * 전문가일때 실수를 할때 더 호감을 살 수 있다.\n        * 대인관계에 이어서 실력이 주는 영향력이 대단하다\n* 마지막 한줄\u000b: 공감능력, 실력이 뒷받침 되는 상태에서 나머지 대인관꺠 기술들을 제대로 연마하게 되면 당신은 당신은 '사,기,캐,릭'이 되고도 남는다.\n      \n* 통찰:가장 어려운 인간관계 하지만 가장 중요한 인간관계\n* '인간관계론'/ 아마존 서점에서 아직도 판매 최상위권/ \n* 예전 경험이지만 이유 사회과학 실험으로 부터 나온 결론과 일치하기때문\n* 심화:대인관계의 신인류:이기적 이타주의자\n* 애덤 그랜트는 사람을 3가지 유형으로 분류\n    - Taker : 자신이 준것보다 더 많이 받기를 바라는 사람\n    - Matcher : 상부상조 원리를 내세워 자기 이익을 보호\n    - Giver : 더 많이 주기를 좋아한다.\n*  애덤 그랜트가 나눈 3가지 유형으로 본 성공할 확률이 높은 사람\n    - GIVER \n    - 이유 \n        * 현대 사회는 조직을 이룬다/조직은 믿을 수 있는 투자자,파트너 필요\n        * 누군가에게 도움을 주면 피드백 속도가 점점 빨라진다.\n* 이기적 이타주의자 \n    - 이기심, 이타심은 매우 독립적이기 때문에 우리는 이 둘을 모두 가질 수 있다.\n    - 성공한 기버들은 강한 동기부여 요소인 이타심과 이기심을 자신 안에 적절히 융합 시켜 일을 추진한다.\n    - 자신의 베푸는 행동이 어떠한 사회적 영향력을 발휘하는지에 대해 잘 안다.\n    - 자신의 희생이 큰 영향력을 발휘한다는 것을 확인하는 것은 최고의 보상이 되기 때문이다.\n        \n    \n  \n# 9. 몸 : 몸은 공부의 길을 안다\n## a 나사는 왜 실패했을까?\n* 아래 문제를 알고도 모든팀이 빡빡한 일정때문에(우주 궤도에 맞춰 미룰 수 없었다.) 뒤로 미뤄두고 해결하지 못하고 프로젝트는 진행 되었다.\n    - 문제\n        * 궤도 진입에는 적적한 속도가 적대적(이 속도는 매우 복잡하고 정밀한 계산)\n        * 궤도에 적절한 속도로 진입하기 위해서는 역추진 엔진 가동 필요\n        * 역주친 엔진이 너무 강력하게 돌앗다.\n        * 역추진엔진 : 영국식측정법/ 중앙처리장치 : 미터법\n\n## b 휴식은 문제 해결의 열쇠\n* 복잡한 문제를 해결, 고민스러운 의사결정을 할때, 아이디어의 샘이 메말랐을때 무의식이 힘을 발휘하도록 우리는 휴식과 여유로운 시간을 가질 필요가 있다.\n\n## c 최고의 공부 전략, 운동\n* 뇌유래신경영양인자(BDNF)\n    - 뇌 시냅스 근처에 잇는 저장소에 모여있다가 혈액이 펌프질할 때 분비되는 단백질로서 새로운 신경세포를 생성하고 기존 신경세포를 보호하며 시냅스의 연결을 촉진(=뇌의 가소성에 핵심적인 역할을 한다.)\n    - 학습과 기억의 가장 중요한 토대를 마련해준다.\n* 세로토닌, 도파민, 노르에피네프린 생성 증가\n    - 이 신경 화학물질들은 집중력, 뇌의 각성 상태, 기분전화을 통한 학습 긍적적 태도 증가, 인내심과 자제력등을 높힌다.\n* 학습에 최적화된 운동\n    - 유산소(뇌 건강에 가장 큰 호전을 가져다 줌 by 쥐 실험)\n* 운동의 최적시기 \n    - 공부하기 전 \n    - 이유 \n        * 운동 중 인지능력의 최상위 역할을 하는 전전두엽에 혈류량이 많지가 않아 집중도 있는 공부가 잘 안됨 / but 운동 후 즉시 전전두엽에 혈류량이 많아져 학습을 위한 최상의 상태에 돌입\n* 운동 횟수\n    - 일주일 4~5회, 30분씩     \n\n## d 수면도 최고의 공부전략\n* 잠을 자는 동안 뇌는 새로운 기억을 기존기억과 통합, 통합된 기억을 다시 분석\n* 성인 권장 수면시간 : 7-9\n\n## e 낮잠, 커피 그리고 설탕\n* 낮잠 추천 시간 : 일어잔후 7~8시간 후/ 30분 이내\n* 커피 추천 양 : 하루 머그잔 기준 두잔 이하\n* 커피 & 피곤함 \n    - 피곤함을 느끼는 이유\u000b\n        * 뇌를 쓰면 아데노신 물질 생김/ 뇌의 수용기(receptor)에 붙는다.\u000b(수용기에 쌓이면 우리 몸은 피곤함을 느낌)\u000b\n        * 커피를 마시면 카페인도 수용기에 붙는다.(즉 아데노신이 수용기에 붙을 수 없다.)\n* 낮참 & 피곤함\n    - 잠을 잘 때 아데노신이 사라지기 때문에 개운해지는 것\n* 명상\n    - 주의력, 집중력, 스트레스 수준을 낮춰줌\n* 기억력/ 문제 해결 능력을 높이는 방법\n    - 다중감각학습\n    - 시각, 청각, 촉각등 두개 이상의 감각을 사용\u000b\n\n## f 통찰 : 공부의 뿌리 : 건강(신박사 통찰)\n* 운동으로 숙면\n* 몸이 가벼워 20~30분 정도 영어공부\n* \"건강한 신체에 건강한 정신이 깃든다.\"\u000b=\"건강한 신체가 공부도 업무도 더 잘하게 해준다\"\u000b\n    \n# 10. 환경 : 공부 효율은 환경 따라 달라진다\n## a 신 박사 + 비닐가방 = 영어회화\n* 영어회화시 불필요한 말을 줄이기 위해서 강력한 화경을 조성\n      \n\n## b 알람을활용하라!\n* 습관은 도도히 그리고 거대하게 흐른 물 같아서 우리의 의지로는 대부분 그 물줄기를 바꾸지 못한다.\n* 습관을 깨기 위한 방법 : 환경설정\n\n## c 눈에띄게 만들기\n* 눈에 띄는 장치로 공부/ 업무 효율을 높일 수 있을 지 고민해보자\n\n## d 데드라인 만들기\n* 성공-> 보상/ 실패-> 벌금\n\n## e 고작가 + 지하철 = 영어 독해\n* 공간을 활용 환경설정\n\n## f 공간이 무의식에 끼치는 영향\n\n## g 몰입을 방해하는 스마트폰\n* 섬엽(insula): 공상, 집중 상태의 전환 기능\n* 자주 사용할수록 피곤함이 증가\n* 스마트폰사용 섬엽 자주 사용 -> 피로도 증가\n* 쉴때 스마트폰을 쓰지 말자\n* 인지자원은 한정 스마트폰을 사용함으로 인지자원을 사용하면 다른곳에 사용할 수 없다.\n\n## h 공부 효율이 떨어지는 뇌\n* 스마트폰/인터넷 사용으로 '전전두엽'사용\n* 전전두엽\u000b\n    - 문제 해결이나 의사결정을 담당하는 부위\u000b\n    - 독서를 할 때는 거의 활성화되지 않는 부위\n* 왜 인터넷으로 글을 읽는데 전전두엽을 사용할까?\u000b\n    - 인지 자원을 콘텐츠에 집중시키지 못하고 다른데에 사용하게 하는 다양한 방해물들이 있기때문\n* 쓸데없는 의사결정, 괄계없는 문제해결, 주의력 분산의 세가지가 집중력이 저하\n* 결론\u000b\n    - 읽기는 공부에서 가장 기본이 되는 능력\u000b\n    - 스마트폰/인터넷으로 읽기 능력을 저하 시키지 말자\n* 마지막 한마디\u000b\n    - 우리가 집을 만들지만, 그 집이 다시 우리를 만든다\u000b\n    - 환경은 우리가 만들지만, 그 환경이 우리를 만든다는 것이다.\u000b\n    - 환경 설정만 잘해도 당신의 공부 효율은 몇 배나 향상 될 수 있다.\n\n## i 통찰 : 결심보다 강력한 것은환경(신박사)\n* 집중을 잘하려면 의지보다 환경설정이 필요\n* 스스로 인생을 발전시키고 싶다면 마음 보다 환경을 바꿔야한다.\n* 올바른 환경 설정이 반이다\n\n## j 심화 : 구글의 스마트한 환경 설정\n    \n\n# 11. 창의성 : 창의성은 지능이 아니라 태도다\n## a 창의성에 대한 오해\n* 스티브잡스 say\u000b   \n    - 창의성은 당지 사물을 잇는 것이다. 창의적인 사람들에게 그토록 괸장한 일을 어떻게 할 수 있었는지 물어보면 약간 죄책감을 느낀다.\u000b(즉 창의성의 첫번째 속정은 '연결' 이다)\n\n## b 연결이 곧 창의성이다.\n* 스티브잡스 say 2\u000b\n    -  뭔가를 한 것이 아니라 그저 본것이기 때문이다. 일단 눈에 띈 후 에는 당연한 것처럼 생각된다. 과거의 경험을 연결하여 새로운 것을 합성하기 때문이다. 그것이 가능한 이유는 경험이 많거나 다른 사람들 보다 자신의 경험에 대해 더 많이 생각했기 때문이다.\n    - 즉 다양한 경험이 있을수록 그 사람은 창의적인 아이디어를 낼 가능성이 커진다. 왜냐하면 연결한 것들이 많으니까.\n\n## c 다양한 경험\n* 노벨상 받은 과학자는 예술을 즐겼다.\n* 여행은 찾선 경험을 축적해주고 그 겨험들은 창의성을 발휘 할 수 있는 귀중한 재료가 된다.\n* 낯선 경험 방법 네가지\n    - 전문 분야와 다른 분야의 취미를 가져보라\u000b: eg)전문분야 : 인문/과학, 취미 : 스포츠 \n    - 해외여행\n        * 이질적인 문화를 몸소 체험하는 것\u000b: 문화를 알려면 보는 것보다 대화를 함께하는것이 좋다고 생각한다.\n    - 다양한 분야의 사람\n    - 다양한 책\n        * 적응 비용으로 다양한 경험 가능\n        * 논리와 지성이 진하게 녹아 있음\n\n## d 도전도많이, 실패도 많이\n\n## e 통찰 : 다시 그리고 또 다시!\u000b\n    * 작성대기\n\n## f 심화 : 창의성과 리스크관리\u000b\n    * 작성대기\n\n    \n# 12. 독서 : 독서는 모든 공부의 기초다.\n\n## a 질문이 사라진 학교\n\n## b 질문 못하는 기자\n* 질문이 없다 -> 의문이 없다 -> '비판적 사고'의 결여\n* 당연한 현상에 '정말 그럴까?' 라는 의문을 던질 수 있을 때 성장과 발전이 있을 수 있다.\n* 미국에서 논문을 쓰는 과정 6가지\n    - 연구주제 찾기\n    - 정해진 연구 주제 답을 도출하기 위해 얻너 방법으로 어떻게 진행할지 연구방법론 및 절차를 설계\n    - 연구와 관련이 있을 만한 각종 자료 및 선행 문헌들을 읽고 분석\n    - 연구 설계에 따른 절차(실험, 개발, 조사, 인터뷰)들을 직접 수행\n    - 연구 결과를 분석\n    - 분석의 결과가 무엇을 의미하는 것인지 해석하고 결론을 도출\n* 한국인은 연구주제찾기, 분석 결과가 무엇을 의미하는 것인지 해석하고 결론도출을 잘 못한다.(나머지는 잘한다)\n* 질문 찾는 방법 -> 독서\u000b\n\n## c 지적인 호기심과 만나다\n* '지식'과 '자식의 부재'가 적절히 균형을 이루었을 때 호기심은 기지개를 켜기 시작한다.\n* 지식이 있을 때 비로소 '지식의 공백'을 느끼게 된다.\n* 독서로 습득한 다양한 지식은 아이러니하게도 지식의 공백을 만들어 우리를 지적 호기심의 세계로 이끈다.\n* 한 그룹은 칸마다 여러 종류의 동물 그림 \u000b: 한칸을 클릭하면 큰 동물의 극히 일부분만\u000b= 검색을 통해 단편적인 정보를 얻거나 대부분 짧은 인터넷 글을 보는 행위\u000b: 책 한 권을 읽는 것은 큰 그림을 보는 것과 같고 더나아가 더 큰 그림이 있음을 알려주기도한다.\n* 세상사를 다 파악했다고 생각하는 속 편한 확신을 떠받치는 것은 자신의 무지를 무시할 수 있는 무한한 능력이다.\n* 무지를 무시할 수 있는 무한한 능력의 소유자\n    - 독서 x(무식해서 확신에 차있다.)\n    - 자신의 전문 분야만 하는 사람(편협함으로 확신에 차있다.)\n* 독서는 ?\n    - 자식을 준다.\n    - 자식의 부재가 있음을 알게 한다.\n    - 자적인 호기심을 갖도록 한다.\n    - 지적인 호기심을 느끼는 당신은 당연히 '잘문'을 던질 수 밖에 없을 것이다.\n\n## d 비판적 사고 그리고 책이라는 것\n* 비판적 사고란 ? \n    - 의문만 품는 것이 아니라 \n    - 증거에 근거해서 결론을 내리는 개인의 능려고가 경향을 포함한다.\n\n## e 처참한 성인 문해력\n* 1~5 등급(높을 수록 문해력이 높다)\n    - 4~5등급으로 문해력 가진 사람은 1등급 문해력을 가진 사람보다 임금은 2.9배, 봉사활동 찬여도 2.5배, 자기신뢰 2.3배, 취업률 2.2배 건강은 2.1배가 높은 것으로 나왔다.\u000b(OECD 평균으로 분석한 것이지만 문해력과 사회경재적 지위 및 성취가 얼마나 높은 상관과계를 맺는지 나타낸다.\n* 우리나라는 평균 2등급\u000b우리 나라 사람은 토론을 잘 못한다.(토론을 원활하게 하기 위해서는 3등급 이상은 되어야하기 때문에)\n* 2등급\u000b\n    - 둘 이상의 정보를 통합할 수 있고, 비교 대조하거나 간단한 추리나 추론을 할 수 있다. 정보에 접근하고 필요한 정보를 식별하기 위해 다양한 디지털 텍스트를 검토할 수 있다.\n* 3등급\n    - 여러 페이지에 걸친 비교적 난해하고 긴 문장을 이해할 수 있다. 텍스트의 구조를 이해하고 여기에 구사한 수사법을 간파하고 해석할 수 있으며 여러곳에서 정보를 얻고 해석하여 적절한 추론을 할 수 있다.\n* 4등급\n    - 복잡하거나 긴 텍스트에서 여러 단계에 걸쳐 체계적으로 정보를 조합, 해석, 축적할 수 있다. 텍스트의 배경에 깔린 주장을 해석 하거나 평가할 수 있으며, 이를 적용하여 복잡한 추론이나 설득을 할 수 있다.\n* 5등급\n    - 다양한 분야을 아우르는 어려운 텍스트에서 정보를 찾고 축적할 수 있다. 또한, 텍스트에서 핵심 아이디어를 추려내고 분류하고 재구성할 수 있으며 증거와 논증에 기반을 두어 평가할 수 있다. 이들은 논리적이고 개념적인 모형을 수립할 수 있으며, 텍스트에서 핵심 정보를 추출하고 객관적으로 그 신뢰도와 타당성을 평가할 수 있다.\n\n## f 다독이 첫 시작이다\n* 초보자\u000b\n    - 편하게 하루 1시간 2~3달 꾸준히  \n    : 그 이후 스스로 정독하고 재독하는 자신을 마주 할 수 있음\n* 다독의 종류\u000b\n    - 계독: 한 분야의 계보에 따라 \u000b\n    - 남독: 다양한 책을   \n        * 지은이 추천 \n            - 계독(관심, 전공 분야에 책을 최소 50~200권 정도 읽어야 준전문가 수준의 식견을 얻는다.)\u000b-> 일하는데 직접적인 도움 & 전문가들을 비평할 정도의 실력을 갖춘 자신을 보며 삶에 큰 자신감\n\n## g 그 외 독서법: 만독, 관독, 재독, 낭독\n* 만독\u000b\n    - 느리게 읽기(=책 한권을 해부)\u000b\n    - 챕터별로 요약(+ 자기 생각을 덧붙이거나 연관된 다른 자료를 함께 적기)\u000b\n    - 블로그, SNS로 자신의 글을 공개해 보자\u000b-> 공기된 글쓰기를 하면 집중도가 배가 될 뿐만 아니라 퇴고도 더 잘하게 되고 무엇보다 대중에게 피드백을 받을 수 있으므로 성장에 있어서 최고의 전략\u000b\n    - 이런 과정 -> 완성된 멋진 글을 쓰는 자기 자신을 만나게 된다.\n* 관독\u000b\n    - 하나의 관점을 갖고 책을 읽는 것\u000b\n    - 예) 공부법 책을 쓰려는 관점으로 다른 책을 바라 봤을때 예전에 큰 의미 없이 넘겼던 내용과 이론들이 공부법과 연계되기 시작한다\u000b\n    - 콘텐츠 제작, 아이디어 발굴에 도움이 된다.\u000b\n    - 특정 관점을 가지고 세상을 바라보면 때로는 많은 것을 놓칠 수 있겠지만, 자신에게 진짜 중요한 것을 얻게 된다.\n* 재독\u000b\n    - 다시 읽기(망각의 강을 건넌 다음에)\u000b\n    - 과거의 자신을 보게 할 뿐만 아니라 변해 버린 현재의 자신을 인지시켜 준다.\u000b\n    - 고작가 say -> 재독 '자아의 시간여행'\n* 낭독\u000b\n    - 소리 내어 읽는 독서법\u000b\n    - 유시만 작가 say \u000b-> 묵독보다 낭독이 말이 되는 글인지 안되는 글인지(좋은 글의 기준)바로 알 수 있다.즉, 퇴고에 매우 유용하다.\u000b\n    - 글의 마지막 투수\n\n## h 독서 습관을 만드는 7가지 방법\n* 스마트폰과 멀어지기\u000b\n    - 비행기 모드로 해 놓고 책보기\u000b\n    - 스마트폰과 멀어질수록 독서는 가까워진다.\n    - 지하철 - 스마트폰을 넣어두고 무조건 책을 읽는다는 마음가짐\n* 인지부조화 이용하기\u000b\n    - 독서를 하기 싫을 때 조차도 그냥 읽어본다.\u000b\n    - 메커니즘 \u000b- 싫은데 계속했을 때 뇌 -> 자기정당화(독서를 하고 있어! 나는 독서를 좋아해!!!)\n* 책을 한꺼번에 많이 사기\u000b\n    - 5-10권을 사고 눈에 띄는 곳으로 => '내가 앞으로 읽을 책들이 저기 많구나...'\n* 독서 모임 \u000b\n    - 책으로 만난 사람들과의 모임은 삶의 질을 향상해 준다.\n* 3~4권 동시에 읽기\u000b\n    - 읽기 싫을 때 -> 그냥 덮고 다른 책을 읽는다.(마음의 반전)\u000b-> 다시 볼때 이미 몇십 페이지 읽음\u000b-> 고지가 좀 더 낮아 보여 저항이 줄어듬\u000bthen, 1~2권은 정말 읽고 싶은 책을 사 놓을 수록 좋다.\n* 다독가를 주변에 두기\u000b\n    - 가슴속에 큰 동기부여\u000b\u000b\n* 통찰 \n    - 독서, 인생 성장자양분(신박사의 통찰)\n* 회사에서 가장 좋은 학습 방법\u000b\n    - 배운 것을 활용해서 내 지식의 깊이를 더하는 것\u000b(똑같은 지식을 간접 적으로 배운 경우 vs 경험을 통해서 배운 경우\u000b=> 겉으로 보기에 아는 것은 비슷 but, 깊이, 검세함 그리고 그 지식에 대한 확신 정도는 비교조차 되지 않는다.)\n* 회사에서 좋은 학습 방법에 적용하기 어려운 이유& 해결책\n    - 적용이 어려운 이유\n        * 축적한 지식의 양이 너무 적거나, 그 깊이가 업무에 적용될 만큼 성숙하지 않을 때\u000b\n        * 지식은 충분히 잇으나 업무가 바뀌어 버리는 경우\n    - 해결책\u000b\n        * 꾸준히 공부 -> 부족한 지식 채움\u000b\n        * 업무가 바뀔때 -> 학습을 통해 새로운 환경에 적응\n* 공부의 핵심\u000b\n    - 독해력 & 요약 능력\u000b\n    - 독해력이 떨어지면 업무파악 어렵\u000b\n    - 오약 능력이 떨어지면 보고하고 소통하는 것이 어렵\n* 독해력 키우는 방법\u000b\n    - 책의 난이도를 서서히 높여간다.\n* 요약 능력 키우는 방법\u000b\n    - 토론, 독서 노트로 요약 능력을 향상\u000b\n    - 건설적으로 해 줄 이야기가 많아진다.\n    \n# 13. 영어 : 이번 기회에 제대로 배우자.\n\n# 14. 일 : 실전처럼 공부하면 실전에서 통한다.\n\n## a 머리가 아니라'몸'으로 공부하기\n\n## b 실질학습의 효과\n\n## c 반복연습과 실전학습의 놀라운 조화\n* 반복연습은 상당한 의지력이 있어야 함은 틀림 없지만 한 사람을 빛나는 천재처럼 보이게 할 정도로 대단하다\n* '반복연습', '실질학습'의 놀라운 조화 실력을 키우는 좋은 방법\u000b\n    - 예) 발표 : 최대한 실전과 비슷하게 반복연습\n\n## d 프로세스를 활용한 의사결정\n\n## e 시뮬레이션의 놀라운 능력\n* 시뮬레이션은 실제로 행동하는 것만큼의 효과는 거둘 수 없다.\u000bbut, 그 다음으로 가장 훌륭한 방법이다.\n* 시뮬레이션으로 익숙한 상황이므로 일을 잘 처리하는 것\n* 시뮬레이션: '미래계획기억'을 형성하는 거의 유일한 방법\n\n## f 디테일을 잊지말자\n* 깨진 유리창은 처음에는 매우 사소\u000bbut, 그 디테일을 놓치게 되면 차 전체가 망가지게 된다.\n* 실수의 미용이 적을 때는 충분히 복구할 수 있으며 실수가 오히려 다음 성공에 큰 밑천\u000bbut, 절대 놓치지 말아야 할 디테일이 있다.(중요한 바이어, 신제품을 출시, 사활이 걸린 행사-두 번째 기회가 없는 일에서 실수란 용납되지 않는다.-)\n* 디테일 != 사소한 것, 디테일 == 막중한 것\n\n## g 통찰1 : 공부의 화룡점정 : 말하기와 발표\n\n## h 심화 : 짐단 의사 결정은 왜 실패하는가?\n\n## i 통찰 2: 회사생활은 왜 이렇게 힘들까?\n*  직급의 역할\u000b\n    - 사원 실무를 잘해야 한다.\u000b\n    - 대리 사원처럼 실무를, 과장 처럼 관리를 잘해야 한다.\u000b\n    - 과장 조직 관리가 되어야 한다.\u000b- 우리 나라에서는 과장의 리더십 가뭄이다.\u000b\n    - 부장 영어로 director = 문제 발생시 방향을 제시할 수 있어야 한다.\u000b\n    - 관리만 잘하는 것은 연차 높은 과장일 뿐\u000b\n    - 진짜로 일이 어떻게 돌아가는지 현장의 온도를 정확하게 파악해야 하기에 사원하고 가장가까운 직급\u000b\n    - 누구보다 더 부지런해져야 한다.(현장감도 잃지 않고 누구보다 더 열심히 해서 끊임없이 새로운 아이템을 발굴해야한다.)\u000b\n    - 임원 \n        * 결정하는 사람(= 막중한 책임이 따른다)\n* 회사가 마음에 안든다.(eg 부조리, 돌아이 상사)\u000b: 공부를 열심히해서 이직을 하면 된다.\n* 이직이 어려운 이유\u000b\n    - 새로운 환경에 다시 적응해야 하기 때문\u000b\n    - 정말 이직을 하고 싶다면 현실적인 답 \n    - '버티면서' 공부해야한다 현실을 무시 할 방법은 없다.\n        * 결국은 공부가 생각보다 많은 것을 해결해 주지만 안타깝게도 많은 사람이 공부하지 앟는다.\u000b\n        * 잊지 말자. 공부가 답이다.\u000b(회사 생활을 시작해도 꾸준히 능동적으로 공부할 마음만 있다면 생각보다 직장 생활은 힘들지 않다)\n","excerpt":"우연한 계기로 이 책을 읽고 신영준, 고영성 작가를 알게 돼서  공부해서 을 높여야 한다는 것을 깨닫고 2018년 여름 패스트 캠퍼스를 다니기 시작한 여름부터 지금 작성하는 2020년 2월까지 약 1년 8개월 동안 Javascript…","fields":{"slug":"/완벽한 공부법/"},"frontmatter":{"date":"Nov 04, 2018","title":"완벽한 공부법","tags":["독서후기"]}}}]}},"pageContext":{}}}