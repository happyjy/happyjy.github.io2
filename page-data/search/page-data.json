{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n# CONDITION\n  * 서버는 최대 5개 요청을 처리 할 수 있다. \n  * topEl: 각 요소의 숫자 이하 중요도를 처리 할 수 있다. \n  * processTarget: 서버가 처리할 대상\n\n# STRATEGY\n  * STRATEGY 0. iterator STRATEGY 2, 2.1 till topEl ARRAY\n  * STRATEGY 1.0 FILTER procesTarget array is filtered by low number of each topEl array element number  \n  * STRATEGY 1.1 SLICE server can process reqeust number (5)\n  * STRATEGY 2.0 DELETE processTarget array elements from ARRAY element of STRATEGY 1.1(variable: filteredTS)  \n              ( [!] NOT ACCEPT dulicated delete => POINT3, 4 )\n  * STRATEGY 2.1 COUNT processed timstamp\n\n# POINT\n  > 아래 코드에 위치 주석 참고 \n\n  ## POINT1\n  * splice에 의해서 첫번째 outer for문에 돌아갔을 때 배열(filteredTS) 값이 바뀐다. \n\n  ## POINT2\n  * 아래 console에서 topEl요소별로 processTarget값이 나오는것이 아니라\n      topEl요소 배열이 모든 process처리 후의 값이 찍히게 되서 \"slice로 shallow clone\"을 이용\n\n  ## POINT3\n  * 위단계에서 splice로 삭제 했기 때문에 array 요소가 하나 줄어 들어 줄어든 요소 순서부터 시작하기 위해서 감소 연산자를 사용했다.(for동작에서 j++가 동작하기 때문에 )\n  * eg) 배열을 순회하는 j가 2번째 요소를 제거하면 배열 2번째 요소 뒤에 있는 요소들이 앞으로 당겨진다. == 3번째 요소가 2번재요소가 된다.  \n  이렇게 되면 j는 순회를 2번째 요소부터 해줘야 한다.\n\n  ## POINT4\n  * checkDupl flag variable  \n  : filteredTS요소를 processTarget 배열에서 제거할때 같은 요소 값을 지우지 않기 위한 flag성 variable  \n  : eg) filteredTS 요소 1을 제거할때 processTarget에 1이 1개 이상이더라도 1개만 제거\n\n\n# CODE\n``` js\n    var processTarget = [3,3,4,9,11,15,28,30];\n    // var processTarget = [3,3,3,3,3,3,3,4,9,11,15,28,30]; // 3*7\n    var topEl = [0,5,5,15];\n    \n    var originProcessTargetArray = processTarget.slice(0);\n    var filteredTS = [];\n    var processedNumber = 0;\n    //STRATEGY 0\n    topEl.forEach( v => {\n      //STRATEGY 1.0, 1.1\n      filteredTS = processTarget.filter( v2 => v2 < v ).sort((a, b) => b-a).slice(0, 5);\n      //count process number\n      processedNumber += filteredTS.length;\n      \n      //STRATEGY 2.0, 2.1\n      var afterDelProcessTargetArray = [];\n      for (var i=0; i < filteredTS.length; i++){\n        var checkDupl = false;\n        for (var j=0; j < processTarget.length; j++){\n          if(!checkDupl && filteredTS[i] === processTarget[j]){\n            //POINT1\n            processTarget.splice(j,1);\n\n            //POINT2\n            afterDelProcessTargetArray = processTarget.slice(0);            \n\n            //POINT3\n            j--;  \n            checkDupl = !checkDupl;\n          }\n        }\n      }\n\n      //* afterDelProcessTargetArray: topEl 요소 별로 processTarget Array\n      //* filteredTS: topEl 요소 별로 server가 처리할 value\n      console.log({originProcessTargetArray, afterDelProcessTargetArray, filteredTS, topEl: v, processedNumber});\n    });\n```\n\n# 결과\n![](serverProcessRequestByPriority_01.png)\n\n","excerpt":"CONDITION 서버는 최대 5개 요청을 처리 할 수 있다.  topEl: 각 요소의 숫자 이하 중요도를 처리 할 수 있다.  processTarget: 서버가 처리할 대상 STRATEGY STRATEGY 0. iterator STRATEGY…","fields":{"slug":"/serverProcessRequestByPriority/"},"frontmatter":{"date":"Jan 19, 2020","title":"server process request by priority","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# Moving the mouse: mouseover/out, mouseenter/leave 에대해서 설명할 예정입니다.\n\n","excerpt":"Moving the mouse: mouseover/out, mouseenter/leave 에대해서 설명할 예정입니다.","fields":{"slug":"/Moving the mouse(mouseoverout, mouseenter,leave)/"},"frontmatter":{"date":"Jan 17, 2020","title":"first contents","tags":["undefined"]}}}]}},"pageContext":{}}}