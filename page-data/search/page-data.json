{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["javascript","event"]}}},{"node":{"rawMarkdownBody":"\n# 계기\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 si 회사에서 폴리머로 프런트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말 할 수 있는 아니였다..\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있었는데 저자의 연애인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴졌고 나는 떠먹기만 하면 되는 상황에서 정말 감사한 마음이 들었다. 그리고 정리된 내용을 보고 나서 업무를 하며 익혔던 내용을 다시 한번 생각해 보는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\nJavascript만의 특징을 알고 싶은 분이 있다면 추천해주고 싶은 책이다.\n\n\n","excerpt":"계기 이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 si 회사에서 폴리머로 프런트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","독서후기"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6","set","filter","reduce"]}}},{"node":{"rawMarkdownBody":"\n# CONDITION\n  * 서버는 최대 5개 요청을 처리 할 수 있다. \n  * topEl: 각 요소의 숫자 이하 중요도를 처리 할 수 있다. \n  * processTarget: 서버가 처리할 대상\n\n# STRATEGY\n  * STRATEGY 0. iterator STRATEGY 2, 2.1 till topEl ARRAY\n  * STRATEGY 1.0 FILTER procesTarget array is filtered by low number of each topEl array element number  \n  * STRATEGY 1.1 SLICE server can process reqeust number (5)\n  * STRATEGY 2.0 DELETE processTarget array elements from ARRAY element of STRATEGY 1.1(variable: filteredTS)  \n              ( [!] NOT ACCEPT dulicated delete => POINT3, 4 )\n  * STRATEGY 2.1 COUNT processed timstamp\n\n# POINT\n  > 아래 코드에 위치 주석 참고 \n\n  ## POINT1\n  * splice에 의해서 첫번째 outer for문에 돌아갔을 때 배열(filteredTS) 값이 바뀐다. \n\n  ## POINT2\n  * 아래 console에서 topEl요소별로 processTarget값이 나오는것이 아니라\n      topEl요소 배열이 모든 process처리 후의 값이 찍히게 되서 \"slice로 shallow clone\"을 이용\n\n  ## POINT3\n  * 위단계에서 splice로 삭제 했기 때문에 array 요소가 하나 줄어 들어 줄어든 요소 순서부터 시작하기 위해서 감소 연산자를 사용했다.(for동작에서 j++가 동작하기 때문에 )\n  * eg) 배열을 순회하는 j가 2번째 요소를 제거하면 배열 2번째 요소 뒤에 있는 요소들이 앞으로 당겨진다. == 3번째 요소가 2번재요소가 된다.  \n  이렇게 되면 j는 순회를 2번째 요소부터 해줘야 한다.\n\n  ## POINT4\n  * checkDupl flag variable  \n  : filteredTS요소를 processTarget 배열에서 제거할때 같은 요소 값을 지우지 않기 위한 flag성 variable  \n  : eg) filteredTS 요소 1을 제거할때 processTarget에 1이 1개 이상이더라도 1개만 제거\n\n\n# CODE\n``` js\n    var processTarget = [3,3,4,9,11,15,28,30];\n    // var processTarget = [3,3,3,3,3,3,3,4,9,11,15,28,30]; // 3*7\n    var topEl = [0,5,5,15];\n    \n    var originProcessTargetArray = processTarget.slice(0);\n    var filteredTS = [];\n    var processedNumber = 0;\n    //STRATEGY 0\n    topEl.forEach( v => {\n      //STRATEGY 1.0, 1.1\n      filteredTS = processTarget.filter( v2 => v2 < v ).sort((a, b) => b-a).slice(0, 5);\n      //count process number\n      processedNumber += filteredTS.length;\n      \n      //STRATEGY 2.0, 2.1\n      var afterDelProcessTargetArray = [];\n      for (var i=0; i < filteredTS.length; i++){\n        var checkDupl = false;\n        for (var j=0; j < processTarget.length; j++){\n          if(!checkDupl && filteredTS[i] === processTarget[j]){\n            //POINT1\n            processTarget.splice(j,1);\n\n            //POINT2\n            afterDelProcessTargetArray = processTarget.slice(0);            \n\n            //POINT3\n            j--;  \n            checkDupl = !checkDupl;\n          }\n        }\n      }\n\n      //* afterDelProcessTargetArray: topEl 요소 별로 processTarget Array\n      //* filteredTS: topEl 요소 별로 server가 처리할 value\n      console.log({originProcessTargetArray, afterDelProcessTargetArray, filteredTS, topEl: v, processedNumber});\n    });\n```\n\n# 결과\n![](serverProcessRequestByPriority_01.png)\n\n","excerpt":"CONDITION 서버는 최대 5개 요청을 처리 할 수 있다.  topEl: 각 요소의 숫자 이하 중요도를 처리 할 수 있다.  processTarget: 서버가 처리할 대상 STRATEGY STRATEGY 0. iterator STRATEGY…","fields":{"slug":"/serverProcessRequestByPriority/"},"frontmatter":{"date":"Jan 19, 2020","title":"server process request by priority","tags":["algorithm","javascript"]}}}]}},"pageContext":{}}}