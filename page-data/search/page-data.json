{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n2015년 11월 SI회사에 입사하고 나서 2년반 동안 회사업무만 했다. \n공부할 생각은 있었지만 평일에는 야근으로 늦게 퇴근, 주말에는 배드민턴에 빠져서 살았다.(레슨/대회에 참여할정도록 푹빠졋다.) \n\n그렇게 시간을 보내면서 계기가 있었다. 회사 독서 동아리로 매달 하나씩 책을 사서 보는데 2018년 3월쯤 신영준, 고영성 작가님의 `완벽한 공부법` 책을 알게 되고 `꾸준하게` 공부해서 `실력`이 있어야 한다는 깨달음을 얻었다. 같은시기 회사 특성상 `지방 파견`을 지속적으로 다녀야 하는데 그 동안 파견생활 경험으로 지쳐있던 나는 그동안 하지 않았던 개발공부를 시작했다.  \n\n2018년 여름 8주 동안 캐스트 캠퍼스에서 vue 수강을 시작으로 \n2018년 12월 이직했고 \n\n2019년 instagram clone coding1, instagram clone coding2, Javascript core정리\n\n2020년 코드스피츠의 자바스크립트 객체지향을 통해서 MVVM 구현을 통해서 디자인패턴을 학습하고 있다. \n\n앞으로도 typescript, 디자인패턴, 설계, css, animation, 웹 표준, 성능, 보안, git, 백앤드학습으로 개인 개인블로그부터 시작해 product level 웹 서비스 만들어보기등 지속적으로 공부하며 블로그(글쓰기)를 통해서 스스로 동기부여를 하면서 모르는것도 학습해서 문제 해결하는 능력이 높은 개발자가 되고 싶다.","excerpt":"2015년 11월 SI회사에 입사하고 나서…","fields":{"slug":"/개발공부와블로그를시작하게된계기/"},"frontmatter":{"date":"Mar 01, 2020","title":"개발 공부와 블로그를 시작하게 된 계기","tags":["생각정리"]}}},{"node":{"rawMarkdownBody":"\n# 목표 \n객체지향을 가지고 이것 저것 만들어 볼 예정인데 그중 `MVVM`을 을 만들어 본다. 그리고 다음시간에는 이것을 가지고 서비스를 만들어 볼 예정입니다. \n\n# MVVM\n* Model, View, ViewModel의 약자 \n* MS의 pwf에 적용 되어 있는 \b아키텍쳐(ms가 원조)\n* 핵심적인 내용 몇가지 차용 간단한 모델 만들고 객체지향으로 만들어 볼예정\n\n\n# MVC\n* Model View Controller\n* 두가지가 있다. \n\n## MVC 첫번째 \n\n![](./2회/MVC1.png) \n\n### Back-end에서의 MVC\n* Model을 Controller가 가져와 View가 소비할 수 있는 데이터를 가공해서 View한테 준다. \n* Controller는 Model도 알고 있고 View도 알고 있다\n* Controller가 Model 의해서 받은 데이터를 적절히 가지고 가공해서 뒤로 넘겨 주면 주는 그 받은 데이터를 가지고 화면을 그립니다. \n\n### Front-end에서의 MVC\n* View는 User의 interaction 받아들어 Model을 갱신한다.\n    - View는 User의 interaction 받아드리고 그에 따라서 Model을 갱신한다.\n    - View는 어떤 Model을 갱신 시켜야 되는지 Model에대한 의존성을 알고 있다.\n\n* 그런데 View가 Model과 의존성이 있는데 문제가 있다?! \n    - Model과 View가 바뀌는 원인은 다름\n        * Model은 비즈니스가 변경이 바뀌었을때 달라지고 \n        * View는 웹에서 User 인터랙션이 변경이 되었을 때 바뀐다.\n    - **클라이언트에서는 Model과 View가 바뀌는 원인은 다른데 서로 의존성이 있다는 것이 문제다**\n    \n### 결론\n* MVC는 주로 백엔드에서 서버에서 사용\n    - 대표적으로 스프링\n    - 이유\n        * **Model을 Controller에 넘기고 데이터를 가공해서 주는 View를 만들고 response로 던져버리면 끝난다.** 그 다음에 View가 Model을 참고해서 변경시키는 그런 과정이 없기 때문이다.\n        * **서버에서는 View와 Model을 연결짓는 의존성이 없다**. Model -> Controller -> View 이렇게 단방향으로 처리하기 때문에 서버에서는 MVC 패턴이 괜찮다.\n\n* 클라이언트에서는 MVC 패턴을 사용하기 어렵다 \n    - **View에서 인터랙션이 일어나면 Model을 바꾸는 경우가 있어 너무 밀접한 관계를 가지고 있어 이것이 문제다.** \n* 클라이언트 쪽에서는 MVC 패턴을 잘 사용하지 않는데 MVC 패턴을 사용한 백본은 망했다\n\n## MVC 두번째 \n![](./2회/MVC2.png)\n* 제왕적 MVC Model\n* 이 구조에서는 View가 Model의 의존구조가 없어졌지만, **Controller의 의존이 더 강해졌다.** \n    - View, Model의 변화를 모두 처리해줘야 한다. -> Container의 유지 보수가 너무 힘들다 \n* 그래서 점차 사용하지 않는 추세이다.\n\n\n# MVP\n![](./2회/MVP.png)\n> 4세대 language에서사용(비쥬얼 베이지, 파워 빌더, MFC, 안드로이드)   \n\n* visual basic으로 예를 들면 editor에 버튼 끌어다 놓으면 버튼을 제어 할 수 있는 property가 이미 있다. view에 interface를 노출하는게 아니라 프로그래밍으로서의 인터페이스로서 getter, setter를 노출하고 있다. (하나의 컴포넌트에 설정을 할 수 있는 getter, setter가 있다. )\n\n* presenter 역할\n    * **presenter는 view에 getter, setter로 접근한다.** \n        - view는 Model에 대한 지식이 하나도 없다 \n        - 원래 DOM 객체, native 객체로 보이는게 아니라 getter, setter를 가지고 있는 인터페이스로 보이게 된다. \n    * mvc처럼 Model을 던져 view를 제어하는게 아님.\n\n* 사용하는 이유\n    - **View에대한 Model의 의존성 완전히 제거**로 첫번째 MVC패턴에서 보여준 View, Model의 관계를 끊어 버린다.\n    - Presenter, Model만 개발하면 된다.\n\n* MVC를 탈피하기 위해서 MVP를 많이 사용한다. \n    - **View가 rednering 재량권을 다 잃어 버리고, Presenter가 getter, setter통해서 통제하는 방법으로 바꿔 주면된다.** \n    - **하지만 View단에 getter, setter를 다 만들어줘야 한다.** (= view가 무거워진다.) \n\n* 단점\n    - View에 getter, setter를 만들어줘야하는 부담이 있다.\n    - 가볍게 어플리케이션을 만들기 부담\n\n* 결론 \n    - FW에서 MVP를 지원했을때 사용한다. \n\n\n# MVVM\n![](./2회/MVVM.png)\n\n* 핵심\n    - `Binder`, `ViewModel`  \n    - **Binder를 통해서 ViewModel은 View에대한 의존성을 없앴다.**\n    - ViewModel은 순수객체로 이루어져있다.\n\n* **MVVM이 View를 변경하는 방법**\n    1. ViewModel의 순수한 객체를 갱신으로 View를 바꾼다.\n    2. Binder에게 그려달라고 요청  \n    3. Binder는 연결되어 있는 ViewModel을 해석해서 관련된 View를 갱신\n\n* `ViewModel`\n    - view다! 하지만 진짜 그림을 그리는 view가 아니라 **인메모리 객체로써의 순수한 data view(view를 대신하는 객체**)이다. \n    - view를 대신하는 순수한 데이터 구조체 그래서 Model에서도 ViewModel을 갱신 할 수 있다. 그래서 node에서도 ViewModel 변경으로 View를 변경할 수 있다. \n\n* View\n    - view는 viewModel이 변경되면 이에 맞게 View를 조작하면 된다. \n\n* `Binder`\n    - Binder는 observe에 의해서 ViewModel의 속성을 모두 알고 있고 변하면 View에게 알려준다. \n    - 양방향 바인딩은 view, binder에 observe를 적용해서 구현한다.\n        * ember, angular는 양방향 바인딩\n        * 안드로이드의 양방향 data binding은 양방향 바인딩을 걸수도 안걸수도 있다.\n\n## observe -> call로 대체 \n* MVVM의 핵심인 observe를 구현하기 어렵기 때문에 ViewModel이 변경되면 변경되었다고 Bidner에게 call 해서 따로 알려주는 방식으로 변경한다.\n*  수동으로 알려주는call의 장점 \n    : observe는 자동으로 viewModel변경을 감지해서 10번 변경이 일어나면 View에게 전달해주는 반면에 수동으로 call하는 방식은 10번 변경이 일어나도 한번 변경이 일어났다고 알려주는 장점도 있다. \n\n\n# TypeCheck\n구현에 들어가 먼저 Type을 Check를 알아봅시다. \n\n**Javascript는 compile언어가 아니기 때문에 runtime에 throw하지 않으면 무조건 오류가 전파됩니다. 그래서 좋은 전략은 throw로 멈추면 된다.**\n\n* ==, ===차이 \n    - === 은 \b두개의 작동이 들어 있다. type일치 검사를하고 ==검사를 한다. \n\n* react에서도 typeCheck를 이런방식으로 하고 있다.\n\n```js\nconst type = (target, type) => { \n    if(typeof type == \"string\"){\n        if(typeof target != type) throw `invaild type ${target} : ${type}`;\n    } else if(!(target instanceof type)) throw `invaild type ${target} : ${type}`;    \n    return target;\n};\n\ntype(12, \"number\");                 // 12\ntype(\"abc\", \"string\");              // \"abc\"\ntype([1,2,3], Array);               // [1,2,3]\ntype({}, Object)                    // {}\ntype(new Set, Set);                 // Set(0) {}\ntype(document.body, HTMLElement);   //<body>...</body>\n```\n\n## typeCheck 사용방법 \n* 인자가 순차적으로 해석된다.\n    - es6에서 첫번째 인자값이 그 이후에 오는 인자값에서 알수 있습니다. \n\n```js\nconst test = (arr, _ = type(arr, Array)) => {\n    console.log(arr)\n}\n\ntest([1, 2, 3]) //(3) [1, 2, 3]\ntest(123)       //Uncaught invaild type 123 : function Array() { [native code] }\n\n\nconst test2 = (a, b, c, _0 = type(a, \"string\"), _1 = type(b, \"number\"), _2 = type(c, \"boolean\"))=> { \n    console.log(a, b, c);\n};\n\ntest2(\"abc\", 123, true);        //abc 123 true\n```\n\n# View hook & bind\nbind에 View를 그냥 연결 시켜줄 수 없다.  \n그래서 View에는 어떤 ViewModel과 연결 시켜줄 Hook해주는 과정이 필요하다.\n\n![](./2회/viewHookAndBind.png)\n\n* hook\n    - 위 View(template)이 하나의 ViewModel과 연결이 된다. \n그래서 각 el은 어떤 ViewModel의 어떤 키와 매칭 될것인지 지정하는 해야 한다. \n그 방법을 template의 dataset을 사용해서 hook 해줄 수 있다. \n\n* el에 있는 data-viewmodel property value와 viewModel과 bind\n    - data-viewmodel property의 value \"wrapper\", \"title\", \"contents\"은 나중에 bind에 의해서 ViewModel 속성에 매칭 될 것이다. \n\n* bind가 하는 일 \n    - **view에 있는 스캔하면서 data-viewmodel을 hook해서 ViewModel과 연결해서 나중에 viewModel은 view에 반영해주게 된다.** \n\n* dataset\n     - html5 spec에 따르면 dataset 속성은 w3chtml5 validator를 통과하게 되어 있다. 왜냐하면 custom 속성을 마음대로 분리할 수 있는 속성이기 때문이다. \n     - angular에서 사용하는 template에서 사용하는 custom 속성들은 validation을 돌리면 다 깨진다. \n\n  \n# Role Design\n* MVVM에서의 핵심은 `Binder`에 있다. \n\n* Binder, View, ViewModel의 관계\n    - Binder가 View를 scan해서   \n        특정 ViewModel에 넘기고   \n        ViewModel이 변하면   \n        Binder는 변한 ViewModel을 가지고 sacan했던 View에 그린다.   \n        (ViewModel은 View를 모르기 때문에 Binder에게 시킨다.)\n\n## binding의 두가지 방법\n* template의 tag를 scan하는 방법: angular, vueJs\n* **template에 자기 ViewModel을 연결해서 만드는 방법: react** \n    - react는 state, property를 이용해서 자기 view를 자기가 소유(view를 scan하지 않는다.)\n* 장단점 \n    - angular에서는 ViewModel, view를 나눠서 관리하기 쉽다. \n    - **react는 state, view가 동시에 들어 있다. (component방식)**\n\n## Scanner\n![](./2회/Role_Design_Scaner.png)\n- **Scanner 존재의 역할**\n    1. Binder가 HTMLElement의 dataSet property를 Scan한다.  \n    2. Scanner로 부터 Binder를 알게 된다.   \n    3. 결국 Binder는 HTMLElement를 모르게 된다.   \n- **Scanner를 만드는 이유** \n    * **우리는 객체마다 바뀌는 이유를 하나로 만들어야 한다. (SRP 원칙-Single Responsibility(단일책임))**\n    * 원인에 따른 변화율이다 \n        * 코드를 바꾸는 이유가 같은가 다른가? \n            - **Binder는 ViewModel을 이용해서 view를 그릴때**\n            - **Scanner는 HTMLElement를 해석(Scan)하는데 방법이 바뀔때** \n    * 그래서 Binder에서 Scaner를 빼내서 관리한다. \n\n* BinderItem\n![](./2회/Role_Design_BinderItem.png)\n    - Binder안에 각 el에 해당하는 BinderItem을 만들어서 넣어주게 되어 있다.\n    - 위 예시에서 wrapper, title, contents의 hook이 items가 되고 이것을 BinderItem에 끼워준다.\n\n* 결론 \n    - ViewModel, Binder, BinderItem, Scanner를 만들것이다 \n    - 완성하면 HTMLElement로부터 hook을 생성한 통해서 생성한 BinderItem을 만들어 내고 \n    - 만들어낸 BinderItem을 소유한 Binder가 만들어진다. \n    - ViewModel을 만들어서 Binder에게 던져서 그려줘! 하면 Binder가 Scanner를 이용해서 그려줄 것이다. \n    - 그러면 결국에는 ViewModel을 갱신해서 Binder에게 그려달라고 하면 view가 변하는 것을 볼 수 있다.\n\n# 구현  \n> ViewModel, Binder, Scanner, client 이 네가지를 구현해볼 것입니다. \n\n## ViewModel\n* 순수한 인메모리 객체이기 때문에 구현하기 가장 쉽다.\n* 목적\n    - ViewModel이 View의 dom객체를 표현\n* 특징\n    - ViewModel을 만듬으로서 단위테스트를 짜기 편해짐\n        - 이유는 dom을 직접가지고와서 표현할 필요가 없기때문이다 \n        - *viewModel만 테스트하면되고 만약 잘못되면 binder(그림그리는 복잡한 로직)가 잘못된 것* \n            * **이 의미는 IOC가 성립된다는 것을확인 할 수 있다.** \n\n* MVVM Pattern 도식화   \n![](./2회/mvvmPatternDiagram.png)\n\n```js\nconst ViewModel = class{\n    //POINT1\n    static #private = Symbol(); // Static private field\n    static get(data){\n        return new ViewModel(this.#private, data); \n    }\n    //POINT2\n    styles = {}; attributes = {}; properties = {}; events = {}; \n    constructor(checker, data){\n        //POINT1\n        if(checker != ViewModel.#private) throw \"use ViewModel.get()!\"; \n        //POINT3\n        Object.entries(data).forEach(([k, v])=>{\n            switch(k){\n                case\"styles\": this.styles = v; break;\n                case\"attributes\": this.attributes = v; break;\n                case\"properties\":  this.properties = v; break;\n                case\"events\": this.events = v; break;\n                default: this[k] = v;\n            }\n        });\n        Object.seal(this); \n    }\n};\n```\n* POINT1\n    * private constructor 첫번째 param\n        - 외부에서는 constructor에 첫번째 parameter에 ViewModel.#private 인자를 넘길 수 없다.  \n        -> **오직 내부에서만 ViewModel 인스턴스를 생성할 수 있다.**\n        - 외부에서 생성을 하는것을 막는다. 오직 static get을 통해서만 인스턴스를 만들고 싶다.  \n        \n        - \"#\" 문법\n            * [참고: Class field declarations proposal](https://poiemaweb.com/es6-class#5-class-field-declarations-proposal)\n            * 최신 브라우저(Chrome 72 이상) 또는 최신 Node.js(버전 12 이상)에서 정상 동작\n            * Javascript의 새로운속성 private 속성은 \"#\" 으로 시작 \n            * 외부, 내부에서 대괄호 구문으로 접근안되고, dot notaion으로만 접근가능\n            * 클래스 내부에서 밖에 쓸 수 없다. \n    * this는 viewModel을 가르킨다. \n* POINT2\n    - dom 객체를 대신하는 인메모리객체이기 때문에 dom에 있는 정보를 뽑아 냈다. \n* POINT3\n    - constructor에서 받은 data를 ViewModel instance에 POINT2에서 선언한 속성에 세팅한다.\n* POINT4\n    - 더 이상 this객체에 key를 추가하지 못하고 writable일때 변경만 가능하다\n    - [seal mdn 참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)\n    - [freeze mdn 참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n\n## BinderItem && Binder\n* Binder는 native View를 있다. 그래서 ViewModel이 Binder에게 viewModel객체를 넘겨 view를 변경한다.\n* BinderItem class 생성시 설정되는 것은?  \n-> 참고: 실제 코드에서 선언되 html 코드 \n    - navtive element \n    - view에서 hook된 key값(data-viewmodel property value)\n\n### BinderItem\n* html을 하나하나 item으로 인식하기 위해서 element의 hook되어 있는 key로\n* Binder가 scan할때 알수 있는건 \"문자열, wrapper, title, content\" 뿐이다.  \nBinder가 어떤 viewModel과 결함해서 그릴지 모르기때문에 나중에 lazy Binding를 하기 위함이다.  \n그래서 hook해서 key만 가지고 있고 실제로 그림그릴때 ViewModel속성과 매칭(Binding)하기 위해서 key만 가지고 있는 것이다. \n \n* MVVM Pattern 도식화   \n![](./2회/mvvmPatternDiagram.png)\n\n```js\nconst BinderItem = class{\n    el; viewmodel;\n    \n    //POINT\n    constructor(el, viewmodel, _0=type(el, HTMLElement), _1=type(viewmodel, \"string\")){\n        this.el = el;\n        this.viewmodel = viewmodel;\n        Object.freeze(this);\n    } \n};\n\n//POINT1\nnew BinderItem(section, \"wrapper\"); \nnew BinderItem(h2, \"title\");\nnew BinderItem(section2, \"contents\");\n```\n\n```html\n<section id=\"target\" data-viewmodel=\"wrapper\">\n  <h2 data-viewmodel=\"title\"></h2>\n  <section data-viewmodel=\"contents\"></section>\n</section>\n```\n\n* POINT\n    - constructor param\n        * el: view의 elements\n        * viewmodel: hook의 key값(data-viewmodel의 value)\n        * _0, _1: el, viewmodel이 어떤 type인지 확인 할 수 있다. \n    - freeze로 BinderItem은 변할 수 없도록 한다. \n* POINT1\n    - 실제로 BinderItem은 **Scanner class의 checkItem에서** BinderItme을 설정한다.  \n      (new BinderItem(el, vm)코드 호출)\n    - new BinderItem으로 선언된 3개는 아래 html 코드와 관련된 내용이다. \n    \n\n\n### Binder\n* 객체지향은 identifier context를 지향한다. (메모리 기반으로 데이터를 구분)\n    - 객체 container는 언제나 \"set\"이다. (영상이 잘안들림...)\n\n* MVVM Pattern 도식화   \n![](./2회/mvvmPatternDiagram.png)\n```js\nconst Binder = class{\n    //POINT1\n    #items = new Set;\n    add (v, _ = type(v, BinderItem)) {this.#items.add(v);} \n    //POINT2\n    render (viewmodel, _ = type(viewmodel, ViewModel)){\n        this.#items.forEach(item=>{\n            const vm = type(viewmodel[item.viewmodel], ViewModel), \n            el = item.el; \n            Object.entries(vm.styles).forEach(([k, v])=>el.style[k] = v); \n            Object.entries(vm.attributes).forEach(([k, v])=>el.setAttribute\n            (k, v)); \n            Object.entries(vm.properties).forEach(([k, v])=>el[k] = \n            v); \n            Object.entries(vm.events).forEach( ([k, v])=>el[\"on\" + k] \n            = e =>v.call(el, e, viewmodel) );\n        }); \n    }\n};\n```\n* POINT1(add)\n    - Scanner class의 checkItem에서 호출을 통해서 설정된다.\n    - add를 통해서 #items는 BinderItem 인스턴스를 가지고 있겠다.\n    - \"#item\"은 add를 통해서만 설정가능하다.\n\n* POINT2(render)\n    - 실제로 el을 render하는 과정이 있다.\n    - client에서 호출한다.\n    - render객체를 받고 있다.\n    - forEach \n        * \"#items\"을 순회하니까 Binderitems 인스턴스가 하나씩 순회하겠다.\n        * item.viewmodel은 hook의 key값이므로 viewmodel객체에서 유무를 확인한다. \n        * item.el은 natvie element를 가지고 있다.\n        * **e => v.call(el, e, viewmodel)) 의미**\n            - event객체 설정시 call을 통해서 this를 el객체로 element, e는 event 객체, viewmodel을 넘긴다.\n            - this가 설정되는 element이기 때문에 event객체로 e.target으로 확인하지 않아도 된다. \n\n        * [Object.entries mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n    - <u>el = tiem.el</u> 코드에 분기문이 없이 validation 가능한 이유.\n        * this.#items, viewmodel은 각각 BinderItem, Binder class에서 type체크를 하고 있기 때문에 \n\n## Scanner\n* 역할\n    - Scanner가 HTMLElement Dom을 읽어와 Dom에 hook과 관련된 property(여기에선 data-datamodel)를 읽어온다.\n    - 읽어온 hook 하나에 BinderItem을 만들어 Binder에 넣어준다.\n\n* dom 순회하는 코드를 만든다! \n\n* MVVM Pattern 도식화\n![](./2회/mvvmPatternDiagram_Scanner표시.png)\n\n```js\nconst Scanner = class{\n    scan(el, _ = type(el, HTMLElement)){\n        //POINT1\n        const binder = new Binder; \n        //POINT3\n        this.checkItem(binder, el);\n\n        //POINT2 - dom 순회\n        const stack = [el.firstElementChild];         \n        let target;\n        while(target = stack.pop()){\n            //POINT3\n            this.checkItem(binder, target);\n            if(target.firstElementChild) stack.push(target.firstElementChild); \n            if(target.nextElementSibling) stack.push(target.nextElementSibling);\n        }\n        //POINT1\n        return binder;\n    }\n    //POINT3\n    checkItem(binder, el){\n        const vm = el.getAttribute(\"data-viewmodel\"); \n        if(vm) binder.add(new BinderItem(el, vm));\n    } \n};\n```\n* POINT1\n    - **Binder를 만들어서 binder를 반환합니다.**\n \n* ***POINT2: dom순회***\n    - 재귀적으로 돌기 싫으면 stack Loop를 \u001d사용하게 된다 \n        - 재귀적으로 함수를 반복적으로 호출해서 문제를 해결하면 stack이 계속 쌓이기 때문에 \"stack over flow\"가 걸리게 된다. \n        - 재귀적인 문제를 해결하기위해서는 배열로 stack 역할을 하게 별도의 메모리 공간에 만들고 file을 돌면서 처리하면 됩니다. \n            * stack.pop(): 동적 게입법(동적으로 배열에 있는 것을 빼가면서 처리) \n            * stack.push 코드 두개를 보면 firstElementChild, nextElementSibling을 통해서 dom을 순회하기 때문에 stack에는 모든 dom 객체들이 쌓일 것이다.\n* POINT3\n    - **Scanner를 분리하게된 이유코드** \n        * el.getAttribute(\"data-viewmodel\");\n        * 이 코드가 binder와 무관하다.\n        * 이 코드를 바꿔주면 html의 spec을 바꿔 줄 수 있다(hook 할 html property)\n\n## client\n* MVVM Pattern 도식화   \n![](./2회/Role_Design_Scaner.png)\n![](./2회/mvvmPatternDiagram.png)\n\n```js\n//POINT1\nconst viewmodel = ViewModel.get({\n    wrapper: ViewModel.get({\n        styles: { width: '50%', background: '#ffa', cursor: 'pointer'}\n    }),\n    title: ViewModel.get({\n        properties: { innerHTML: 'Title' }\n    }),\n    contents: ViewModel.get({\n        properties: { innerHTML: 'Contents' }\n    })\n});\n\nconst scanner = new Scanner;\n//POINT2\nconst binder = scanner.scan(document.querySelector(\"#target\"));\n//POINT3\nbinder.render(viewmodel);\n```\n\n* POINT1\n    - render할대 필요한 viewmodel 객체 생성\n    - ViewModel.get 함수를 보면 ViewModel 인스턴스를 반환한다.\n* POINT2\n    - \"#target dom을 순회해서 binder 인스턴스를 반환한다.\n    - binder는 dom을 순회하면서 각dom에 BinderItem \"#item\" private variable에 세팅한다.(Set 객체)\n* POINT3\n    - render를 한다.\n\n## client개선\n- 배경 색을 계속 바꾸도록 변경하고 반뀌는 곳을 클릭하면 배경 바뀌는것이 멈춘다.\n\n```js\nconst scanner = new Scanner();\nconst binder = scanner.scan(document.querySelector('#target'));\n\nconst getRandom = () => parseInt(Math.random() * 150) + 100\nconst viewmodel = ViewModel.get({\n    isStop: false,\n    //POINT1\n    changeContents () {\n        this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`;\n        this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '');\n        binder.render(viewmodel);\n    },\n    wrapper: ViewModel.get({\n        styles: { width: '50%', background: '#fff', cursor: 'pointer' },\n        events: { click(e, vm) { vm.isStop = true } }\n    }),\n    title: ViewModel.get({\n        properties: { innerHTML: 'Title' }\n    }),\n    contents: ViewModel.get({\n        properties: { innerHTML: 'Contents' }\n    })\n})\n\nconst f = () => {\n    //POINT1\n    viewmodel.changeContents();\n    binder.render(viewmodel);\n    if (!viewmodel.isStop) requestAnimationFrame(f);\n}\n\nrequestAnimationFrame(f);\n```\n\n* POINT1\n    - viewmodel을 바궈 render하게 되면 binder가 viewmodel객체를 가지고 rendering 한다.\n\n\n# 최종 코드 \n- client코드는 개선된 코드를 사용(background색이 계속 변함)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <section id=\"target\" data-viewmodel=\"wrapper\">\n        <h2 data-viewmodel=\"title\"></h2>\n        <section data-viewmodel=\"contents\"></section>\n    </section>\n    <script>\n        const type = (target, type) => { \n            if(typeof type == \"string\"){\n                if(typeof target != type) throw `invaild type ${target} : ${type}`;\n            } else if(!(target instanceof type)) throw `invaild type ${target} : ${type}`;    \n            return target;\n        };\n\n\n        const ViewModel = class{\n            //POINT1\n            static #private = Symbol(); // Static private field\n            static get(data){\n                return new ViewModel(this.#private, data); \n            }\n            //POINT2\n            styles = {}; attributes = {}; properties = {}; events = {}; \n            constructor(checker, data){\n                //POINT1\n                if(checker != ViewModel.#private) throw \"use ViewModel.get()!\"; \n                //POINT3\n                Object.entries(data).forEach(([k, v])=>{\n                    switch(k){\n                        case\"styles\": this.styles = v; break;\n                        case\"attributes\": this.attributes = v; break;\n                        case\"properties\":  this.properties = v; break;\n                        case\"events\": this.events = v; break;\n                        default: this[k] = v;\n                    }\n                });\n                Object.seal(this); \n            }\n        };\n\n        const BinderItem = class{\n            el; viewmodel;\n            //POINT\n            constructor(el, viewmodel, _0=type(el, HTMLElement), _1=type(viewmodel, \"string\")){\n                this.el = el;\n                this.viewmodel = viewmodel;\n                Object.freeze(this);\n            } \n        };\n\n        const Binder = class{\n            //POINT1\n            #items = new Set;\n            add (v, _ = type(v, BinderItem)) {this.#items.add(v);} \n            //POINT2\n            render (viewmodel, _ = type(viewmodel, ViewModel)){\n                this.#items.forEach(item=>{\n                    const vm = type(viewmodel[item.viewmodel], ViewModel), \n                    el = item.el; \n                    Object.entries(vm.styles).forEach(([k, v])=>el.style[k] = v); \n                    Object.entries(vm.attributes).forEach(([k, v])=>el.setAttribute\n                    (k, v)); \n                    Object.entries(vm.properties).forEach(([k, v])=>el[k] = \n                    v); \n                    Object.entries(vm.events).forEach( ([k, v])=>el[\"on\" + k] \n                    = e =>v.call(el, e, viewmodel) );\n                }); \n            }\n        };\n\n        const Scanner = class{\n            scan(el, _ = type(el, HTMLElement)){\n                //POINT1\n                const binder = new Binder; \n                //POINT3\n                this.checkItem(binder, el);\n\n                //POINT2 - dom 순회\n                const stack = [el.firstElementChild];         \n                let target;\n                while(target = stack.pop()){\n                    //POINT3\n                    this.checkItem(binder, target);\n                    if(target.firstElementChild) stack.push(target.firstElementChild); \n                    if(target.nextElementSibling) stack.push(target.nextElementSibling);\n                }\n                //POINT1\n                return binder;\n            }\n            //POINT3\n            checkItem(binder, el){\n                const vm = el.getAttribute(\"data-viewmodel\"); \n                if(vm) binder.add(new BinderItem(el, vm));\n            } \n        };\n\n\n        const scanner = new Scanner();\n        const binder = scanner.scan(document.querySelector('#target'));\n\n        const getRandom = () => parseInt(Math.random() * 150) + 100\n        const viewmodel = ViewModel.get({\n            isStop: false,\n            //POINT1\n            changeContents () {\n                this.wrapper.styles.background = `rgb(${getRandom()},${getRandom()},${getRandom()})`;\n                this.contents.properties.innerHTML = Math.random().toString(16).replace('.', '');\n                //binder.render(viewmodel); 없어도됨 -> 아래 f 함수에서 해주고 있다. \n            },\n            wrapper: ViewModel.get({\n                styles: { width: '50%', background: '#fff', cursor: 'pointer' },\n                events: { click(e, vm) { vm.isStop = true } }\n            }),\n            title: ViewModel.get({\n                properties: { innerHTML: 'Title' }\n            }),\n            contents: ViewModel.get({\n                properties: { innerHTML: 'Contents' }\n            })\n        })\n\n        const f = () => {\n            //POINT1\n            viewmodel.changeContents();\n            binder.render(viewmodel);\n            if (!viewmodel.isStop) requestAnimationFrame(f);\n        }\n\n        requestAnimationFrame(f);\n    </script>\n</body>\n</html>\n```\n* 크롬에서 그림그리는데 역량을 많이 쓰고 있다. binder.render는 거의 부하에 영향이 가지 않는다 \n    * binder.render는 viewmodel을 loop돌면서 걸린애들만 dom조작이 일어난다. \n\n\n# 결론\n## 결론1 - MVVM을 쓰는이유\n* **제어의 역전으로 view제어를 Binder에 모두 작성했다.**\n    - view를 Control하는 Code(\u001fview의 style, attribute, event 등)는 없다. \n    - Binder.render에서 viewmodel을 가지고 view를 update 한다. \n    - view를 조작하는 코드를 없앨수 있다. \n* 단위테스트를 viewmodel만 검사하면된다. \n* view를 조작하는 오류를 줄일 수 있다. \n\n## 결론2 - MVVM으로 해결한 문제 \n* MVVM을 구축하는 과정 보다 **MVVM 프레임워크자체의 객체 구조를 이해하는 것이 객체를 관리하는 것에 도움이 됨**\n* Model이 바뀔 때 마다 View가 영향을 받는 의존성 문제\n* View 마다 View를 그리는 로직들을 다 MVC에서 하나하나 만들어야 하는 문제\n* 어떻게해야 View마다 View를 그\u001f리는 로직을 다 없앨까?\n    * **제어 역전을 통해서(Binder에게 위임)**\n    * **View를 직접적으로 알지 못하게 하는 모델을 만듬**\n\n## 결론3 - 의존성에 문제가 있다. \n* 위 scanner내용에서 SRP내용 참고  \n* [scanner](https://happyjy.github.io/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_2/#scanner)","excerpt":"목표 객체지향을 가지고 이것 저것 만들어 볼 예정인데 그중 을 을 만들어 본다. 그리고 다음시간에는 이것을 가지고 서비스를 만들어 볼 예정입니다.  MVVM Model, View, ViewModel의 약자  MS의 pwf…","fields":{"slug":"/객체지향 자바스크립트_2/"},"frontmatter":{"date":"Feb 29, 2020","title":"객체지향 자바스크립트 2회차(MVVM 구현)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* H-Index를 구하라!\n* H-Index란? \n    - 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다.\n\n        \n# 해결 방법 \n* 논문이 \"**h번 이상 인용된 논문이 h편 이상**이고 나머지 논문이 h번 이하\" 이것이 포인트!\n* 아래처럼 h번이 의마하는 것을 생각해보면 배열을 내림차순으로 정렬하고 순환하며 h를 구할 수 있겠다.\n    - h번 이상인용된 논문: 배열의 요소\n    - h번 이상인용된 논문이 h편 이상: 배열 indx\n\n# STEP\n* STEP1: 내림차 순으로 정렬\n* STEP2: 순환하면서 hIndex를 구하고, 순환 유무 flag를 통해서 순환 제어\n\n# CODE\ncitation: 인용구\n```js\nfunction solution(citations) {\n    var hIndex = 0;\n    var iteratorFlag = true;\n    citations.sort((a, b)=> b-a).forEach((citation, idx) => {\n        if(citation > idx && iteratorFlag) {\n            ++hIndex;\n        } else {\n            iteratorFlag = false;\n        }\n    });\n\n    return hIndex;\n}\n\nconsole.log(solution([3, 0, 6, 1, 5]));\nconsole.log(solution([6, 6, 6, 6, 6]));\nconsole.log(solution([6, 6, 6, 6, 6, 6]));\nconsole.log(solution([6, 5, 4, 3, 2, 1]));\nconsole.log(solution([6, 0, 0, 0, 0, 0]));\nconsole.log(solution([4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6]));\n```\n\n# 결과\n3\n5\n6\n3\n1\n6\n","excerpt":"문제 H-Index를 구하라! H-Index란?  어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다. 해결 방법 논문이 \"h번 이상 인용된 논문이 h…","fields":{"slug":"/Hindex/"},"frontmatter":{"date":"Feb 25, 2020","title":"정렬_교수의 논문 인용단위 HIndex 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하라\n```\n예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면\narray의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.\n1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.\n2에서 나온 배열의 3번째 숫자는 5입니다.\n```\n\n# 제한사항\n```\narray의 길이는 1 이상 100 이하입니다.\narray의 각 원소는 1 이상 100 이하입니다.\ncommands의 길이는 1 이상 50 이하입니다.\ncommands의 각 원소는 길이가 3입니다.\n```\n\n# 해결 방법 \n* map을 이용해 주어진 배열을 가공해 새로운 배열을 만든다.\n* 주어진 배열을 자르기 위해서, k번째 있는 수를 얻기위해서 \"slice\", 정렬을 위해서 \"sort\"를 사용해서 문제를 해결 할 수 있겠습니다.\n\n# STEP\n* STEP1: map을 이용해서 주여진 배열을 가공해 새로운 배열을 만듭니다.\n* STEP2: slice이용해 배열을 자른다.\n* STEP3: sort를 이용해 정렬한다.\n* STEP4: slice를 이용해 원하는 k번째 있는 수를 구한다. 또는 배열 요소에 접근해서 k번째 요소를 찾는다.\n\n\n# CODE\n```js\nvar arr = [1, 5, 2, 6, 3, 7, 4];\nvar commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3] ];\n\nfunction solution(array, commands) {\n    return commands.map( v => {\n        return slicedSorted = array.slice(v[0]-1, v[1]).sort((b,c) => b-c).slice(v[2]-1, v[2])[0];\n        \n    });\n}\n\nconsole.log(solution(arr, commands));\n```\n\n# 결과\n[5, 6, 3]\n\n","excerpt":"문제 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하라 제한사항 해결 방법 map을 이용해 주어진 배열을 가공해 새로운 배열을 만든다. 주어진 배열을 자르기 위해서, k…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 25, 2020","title":"정렬_배열 자르고 K번째 수","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다\n\n# STEP\n* STEP1: 배열의 숫자형을 문자형으로 변환\n* STEP2: 문자형변환후 배열 요소를 자리를 바꿔가며 숫자 크기를 비교(문자열x)\n\n# CODE\n```js\nvar a = [3, 30, 34, 5, 9];\nvar b = [6, 10, 2];\n\nfunction solution(numbers) {\n    var answer = numbers.map(v => v + '')\n        .sort((a, b) => (b + a)* 1 - (a + b)*1)\n        .join('');\n\n    return answer[0] === '0' ? '0' : answer\n}\n```\n\n# 결과\n![](result.png)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다 STEP STEP…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 25, 2020","title":"정렬_배열로 조합할 수 있는 수중 가장 큰 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# Readme\nCloning Instagram with Python django + React\n\n# github\n[github 주소](https://github.com/happyjy/yoonGram)\n\n# 정리 노트 \n[notion 주소](https://www.notion.so/happyjy0109/2019-Node-js-Express-ReactJS-Prisma-201910-2019XX-df8d226e12f74f63a4118df9570e75c4)","excerpt":"Readme Cloning Instagram with Python django + React github github 주소 정리 노트 notion 주소","fields":{"slug":"/instagram clone coding/"},"frontmatter":{"date":"Feb 24, 2020","title":"INSTAGRAM CLONE CODING","tags":["TOYPROJ"]}}},{"node":{"rawMarkdownBody":"\n# README\nInstagram clone with Express + Prisma + React\n\n# github\n[Front End(React)github 주소](https://github.com/happyjy/prismagram-frontend)  \n[Back End(Express, Prisma)github 주소](https://github.com/happyjy/prismagram)\n\n# 정리 노트 \n[notion 주소](https://www.notion.so/happyjy0109/2019-Node-js-Express-ReactJS-Prisma-201910-2019XX-df8d226e12f74f63a4118df9570e75c4)","excerpt":"README Instagram clone with Express + Prisma + React github Front End(React)github 주소 Back End(Express, Prisma)github 주소 정리 노트 notion 주소","fields":{"slug":"/instagram clone coding_2/"},"frontmatter":{"date":"Feb 24, 2020","title":"INSTAGRAM CLONE CODING_2","tags":["TOYPROJ"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n```\n    숫자 야구 게임이란 2명이 서로가 생각한 숫자를 맞추는 게임입니다. \n\n    각자 서로 다른 1~9까지 3자리 임의의 숫자를 정한 뒤 서로에게 3자리의 숫자를 불러서 결과를 확인합니다. \n    그리고 그 결과를 토대로 상대가 정한 숫자를 예상한 뒤 맞힙니다.\n\n    * 숫자는 맞지만, 위치가 틀렸을 때는 \"볼\"\n    * 숫자와 위치가 모두 맞을 때는 \"스트라이크\"\n    * 숫자와 위치가 모두 틀렸을 때는 \"아웃\"\n    \n    예를 들어, 아래의 경우가 있으면\n    A : 123\n    B : 1스트라이크 1볼.    //123 중 2개 숫자, 1개는 자리까지 맞음\n    A : 356\n    B : 1스트라이크 0볼.    //3XX확신 (위숫자에서 겹치는게 3뿐이라서)/ 1,2숫중 1개는 볼\n    A : 327\n    B : 2스트라이크 0볼.    //32X확신 (3은 두번째서 고정, 그렇다면 첫,두번째에서 1개 볼인데 겹치는수가 2)\n    A : 489\n    B : 0스트라이크 1볼.    //마지막자리 빼고 확정이기 때문에 이런 경우 첫번째 두번째 자리숫자가 볼의 대상이된다. 그래서 324, 328이 답이된다. \n    이때 가능한 답은 324와 328 두 가지입니다.\n\n    질문한 세 자리의 수, 스트라이크의 수, 볼의 수를 담은 2차원 배열 baseball이 매개변수로 주어질 때, 가능한 답의 개수를 return 하도록 solution 함수를 작성해주세요.\n```\n\n# 제한사항\n* 질문의 수는 1 이상 100 이하의 자연수입니다.\n* baseball의 각 행은 [세 자리의 수, 스트라이크의 수, 볼의 수]를 담고 있습니다.\n\n# 입출력 예\n```\nbaseball\t                                            return\n[[123, 1, 1], [356, 1, 0], [327, 2, 0], [489, 0, 1]]\t2\n```\n\n# 해결 방법 \n* for문 2개\n    - outer for: 예상할 수 있는 3자리 숫자 Array\n    - inner for: 예상 정답 Array\n\n* 가능 정답 찾기 로직\n    - 위 for문을 돌면서 2번 예상 정답 Array안에서 찾기\n    - strike, ball 인경우를 조건문으로 찾는다.\n# STEP\n\n# CODE\n```js\n    function solution(baseball) {\n        var answer = 0;\n\n        // 서로 다른 3개의 수 조합. \n        for(let i=123; i<=987; i++) {\n            let [x, y, z] = (i+\"\").split('');\n\n            // 서로 다른 3개 수 조합을 만들기 위해서 \n            if(x === \"0\" || y === \"0\" || z === \"0\") continue;\n            if(x === y || x === z || y === z) continue;\n\n            for(let j=0; j<baseball.length; j++) {\n                let strike = 0;\n                let ball = 0;\n\n                //query: 던진 숫자\n                //query_s: query_strike\n                //query_b: query_ball\n                const [query, query_s, query_b] = baseball[j];\n                const [query_x, query_y, query_z] = (query + \"\").split('');\n                if(query_x === \"0\" || query_y === \"0\" || query_z === \"0\") break;\n                if(query_x === query_y || query_x === query_y || query_y === query_z) break;\n\n                if(x === query_x) strike++;\n                if(y === query_y) strike++;\n                if(z === query_z) strike++;\n                if(query_s != strike) break;\n\n                if((x === query_y) || (x === query_z)) ball++;\n                if((y === query_x) || (y === query_z)) ball++;\n                if((z === query_x) || (z === query_y)) ball++;\n                if(query_b != ball) break;\n\n                if(j === baseball.length - 1) answer++;\n            }\n        }\n        return answer;\n    }\n    \n    console.log(solution([[123, 1, 1], [356, 1, 0], [327, 2, 0], [489, 0, 1]])); //2\n```\n\n# 정답 \n2\n","excerpt":"문제 제한사항 질문의 수는 1 이상 100 이하의 자연수입니다. baseball의 각 행은 세 자리의 수, 스트라이크의 수, 볼의 수를 담고 있습니다. 입출력 예 해결 방법 for문 2개 outer for: 예상할 수 있는 3자리 숫자 Array…","fields":{"slug":"/숫자야구/"},"frontmatter":{"date":"Feb 24, 2020","title":"완전탐색_모든숫자조합 구해서 소수찾기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n한자리 숫자가 적힌 종이 조각이 흩어져있습니다. \n흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.\n\n# 제한사항\nnumbers는 길이 1 이상 7 이하인 문자열입니다.\nnumbers는 0~9까지 숫자만으로 이루어져 있습니다.\n013은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.\n```\n# 입출력 예\nnumbers\t    return\n17\t        3\n011\t        2\n\n# 입출력 예 설명\n예제 #1\n[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.\n\n예제 #2\n[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.\n\n11과 011은 같은 숫자로 취급합니다.\n```\n\n# 해결 방법 \n* 배열에 있는 숫자를 이용해 만들수 있는 모든 숫자를 만든는 방법이 중요하다\n    - makeAllNumber function\n        - 재귀호출로 구현(아래 코드 주석 POINT)\n\n# STEP\n* 배열에 있는 숫자로 만들수 있는 모든 조합된 숫자 구한다.\n* Prime인지 아닌지 구분한다.\n\n\n# CODE\n```js\nconst isPrime = (n) => {\n  if (n < 2) return false;\n  const sqrt = Math.sqrt(n);\n  for (let i = 2; i <= sqrt; i++)\n    if (n % i === 0) return false;\n  return true;\n}\n\nconst makeAllNumber = (number = null, ...numbers) => {\n    console.log(arguments);\n    if (number === null) return [];\n    if (numbers.length === 0) return [number];\n\n    let arr = [number]; // arr : 조합된 숫자\n    for (const idx in numbers){\n        // * rest : numbers에 idx 요소를 제외한 나머지 index 요소\n        const rest = numbers.filter((v, i) => i !== parseInt(idx, 10));\n        const idxNum = numbers[idx];\n\n        // * number, idxNum type : string \"\"+\"1\" = \"1\"/ \"1\" + \"2\" = \"12\"\n        //   - parseInt(\"1\") -> 1\n        // * rest가 빈배열 일때 까지 '자귀함수가' 반복 (위 filter return type은 array)\n        //POINT\n        arr = [...arr, ...makeAllNumber(number + idxNum, ...rest)];\n        arr = [...arr, ...makeAllNumber(idxNum + number, ...rest)];\n        arr = [...new Set(arr)]; //#POINT2\n    }\n\n    return arr;\n}\n\nfunction solutions(numbers) {\n    numbers = numbers.split('');\n    \n    //#POINT1\n    let makedNumbers = makeAllNumber(\"\", ...numbers).filter(v => v !== '')\n                                                  .map(v => parseInt(v));\n    makedNumbers = [...new Set(makedNumbers)];\n    console.log(\"#모든숫자: \", makedNumbers);\n\n    return makedNumbers.map(isPrime).filter(v => v === true).length;\n}\n\n\nsolutions(\"123\");\n```\n\n# 정답 \n5\n","excerpt":"문제 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. \n흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.\n각 종이 조각에 적힌 숫자가 적힌 문자열 numbers…","fields":{"slug":"/모든숫자조합 구해서 소수찾기/"},"frontmatter":{"date":"Feb 24, 2020","title":"완전탐색_모든 숫자조합 구해서 소수찾기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 학생 3명이 있고 각각 찍는 방법이 각각 다르고 그중 누가 제일 잘찍는지 확인하는 문제 \n        \n# 해결 방법 \n* 학생3명 찍는 방법 배열과 정답 리스트를 비교하면서 학생마다 맞힌 정답 배열길이를 새로운 배열에 push\n* 그 결과를 Math.max함수를 사용 제일 큰수(제일 많이 맞힌갯수) 구한다.\n* 위 두정보를 가지고 제일 많이 맞힌 학생을 구한다.\n\n\n# STEP\n* STEP1: 학생별 찍어서 맞은 정답 arr\n* STEP2: Math.max\n* STEP3: map, filter 함수를 적절하게 사용하여 제일 잘 찍은 학생을 구한다.\n\n# CODE\n```js\nfunction solution(answerList) {\n    let answer = [];\n\n    const stdPick1 = [1,2,3,4,5];\n    const stdPick2 = [2,1,2,3,2,4,2,5];\n    const stdPick3 = [3,3,1,1,2,2,4,4,5,5];\n\n    //STEP1\n    let std1Result = answerList.filter((v,i) => v === stdPick1[i%stdPick1.length]);\n    let std2Result = answerList.filter((v,i) => v === stdPick2[i%stdPick2.length]);\n    let std3Result = answerList.filter((v,i) => v === stdPick3[i%stdPick3.length]);\n\n    const stdResult = [];\n    stdResult.push(std1Result.length);\n    stdResult.push(std2Result.length);\n    stdResult.push(std3Result.length);\n\n\n    //STEP2\n    const maxValue = Math.max(...stdResult);\n    if(maxValue === 0){\n        answer = [0,0,0];\n    } else {\n        //STEP3\n        answer = stdResult.map((v,i) => { return {std: i+1, score: v} })\n                            .filter(v=> v.score === maxValue)\n                            .map(v=>v.std)\n                            .sort();\n    }\n\n    return answer;\n}\n\nconsole.log(solution([1,2,3,4,5]));\nconsole.log(solution([1,3,2,4,2]));\nconsole.log(solution([3,3,1,1,2,2,4,4,5,5,3,3,1,1,2,2,4,4,5,5]));\n```\n\n# 정답 \n[1]\n[1,2,3]\n[3]\n\n","excerpt":"문제 학생 3명이 있고 각각 찍는 방법이 각각 다르고 그중 누가 제일 잘찍는지 확인하는 문제 \n     해결 방법 학생3명 찍는 방법 배열과 정답 리스트를 비교하면서 학생마다 맞힌 정답 배열길이를 새로운 배열에 push 그 결과를 Math.max…","fields":{"slug":"/모의고사/"},"frontmatter":{"date":"Feb 24, 2020","title":"완전탐색_누가 더 잘찍을까?","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n# INTRO\n* 목표\n    - 객체 지향을 자바스크립트로 해보자.\n    - 디자인 패턴과 함께 알아보자.\n    - 오늘 배운 이론 남은 4개 강의에서 활용.\n        * SOLID(SRP, OCP, LSP, ISP, DIP)\n        * Message, 의존성, DI, IOC, \n\n# Value Context, Identifier Context\n> value Context: 함수형 프로그래밍에서 사용  \n> identifier Context: 객체지향 프로그래밍에서 사용\n\n권장 하나의 context만 사용하자 특별한 사항을 제외하고 \n\n```js\nconst a = { a:3,b:5 };\nconst b = { a:3,b:5 };\nconsole.log(a === b);   //identifier context\nconsole.log(JSON.stringify(a) === JSON.stringify(b));   //value context\n```\n\n* 객체 지향의 기본: 메소드 인자, return value, 메소드가 만드는 무언가가 모든 객체만 사용한다임.\n* 객체지향에서 사용할수 있는 value context는 생성자 인자\n\n## value특징\n1. 끝없는복사본 \n    - value값은 변하지 않으면서 복사본을 계속해서 사용한다. \n2. 상태 변화에 안전?\n    - 1번 특징으로 값이 변하지 않음으로 상태에 변화에 안전하다 \n    - 3 + 1 연산에서 3이 4로 바뀌는게 아니라 4가 새로 생기는 것 \n    - 불변하는 값을 계속 만들어서 이것도 관리한는게 힘들다 => 그래서 `함수형 프로그래밍`이 탄생\n3. 연산을 기반으로 로직을 전개(수학적 프로그래밍)\n    - 수학적 프로그래밍은 '확정', '간단'한 로직은 어울린다. \n    - 구현하기 어려운 도메인을 복잡한 연산으로 구현하기 어렵다.\n        - 복잡한 것을 도메인을 수학적 프로그래밍으로 정교하게 구현해도 교체 하는 비중이 너무 커서 깨지기 쉽다 \n    - 넷플릭스에서 어울림 동영상 스트리밍 하는 것만 연산 하면 된다.\n\n## identifier 특징\n1. 하나의원본\n    - 값이 mutable\n    - 상태가 일관적이지 않음\n2. 상태 변화를 내부에서 책임짐 \n    - 내부 상태에서 책임지는 객체를 만드는게 힘들다.\n3. 메세지를 기반으로 로직을 전개\n    - 우리가 배울 테마 \n    - 구현하는데까지 만들고 다른 놈에게 위임 할 수 있다. \n\n## 정리 \n* 객체 지향에서 제일 중요한것은 value Context를 사용하지 않는것 \n\n\n# Polymorphism\n> Polymorphism 대체가능성 + Polymorphism 내적일관성  \n> 객체 지향 프로그래밍은 Polymorphism을 지원해야 한다.\n\n## polymorphism of Prototype\n\n```js\n    const Worker = class{ \n        run(){ console.log(\"working\") }\n        print(){ this.run(); } \n    };\n    const HardWorker = class extends Worker{ \n        //overriding\n        run(){ console.log(\"hardWorking\") }\n    };\n    const worker = new HardWorker(); \n    \n    // substitution\n    console.log(worker instanceof Worker); //true -> Polymorphism의 대체가능성\n    // internal identity\n    worker.print();                        //hardWorking -> Polymorphism의 내적일관성\n```\n\n## Polymorphism의 대체가능성(substitution)\n> 확장된 클래스(자식클래스)는 확장할 대상 클래스(부모클래스)를 대체할 수 있다.\n* worker instanceof Worker 결과 값은 true이다. 아래 도식화 참고\n\n\n## Polymorphism의 내적일관성(internal identity)\n> 태어났을때 원본 클래스를 유지하는 속성 \n* worker.print() 동작시 this.run()이 호출한 곳에서 가까운 Worker class의 run funtion이 호출되는게 아니라 **print를 호출한 대상 worker instance에서 가까운 run 함수를 호출하도록 하자 정한 것을 `내적일관성`**이라고 한다.  \n\n## Polymorphism의 장점 \n*  확장된 객체는 원본으로 대체 가능\n*  생성 시점의 타입이 내부에 일관성 있게 참조됨.\n\n## Polymorphism of Prototype\n* javascript prototype, prototype chain을 통해서 `대체가능성`, `내적일관성`을 구현했다.\n* [프로토타입체인 참고](https://happyjy.github.io/prototype/#2-2-프로토타입-체인)\n\n\n## 대체가능성 설명 도식화 \n![](1회/polymorphismOfPrototype1.png)\n![](1회/polymorphismOfPrototype2.png)\n* worker instanceof Worker 설명\n\t- 첫번째 사진에서 HardWorker class instance인자 확인 아니기 때문에 두분째 사진처럼 Worker class instance인지 확인\n\n## 내적일관성 설명 도식화 \n![](1회/polymorphismOfPrototype.png)\n    - 위코드에서 worker.print()가 'hardWorking'이 호출되는 것을 설명 할 수 있다.\n\n## 대체가능성, 내적일관성 설명 도식화 코드로 확인\n```js\n\nworker.__proto__ === HardWorker.prototype;           //true\nworker.__proto__.__proto__ === Worker.prototype;     //true\n\nworker.__proto__.constructor === HardWorker;         //true\nworker.__proto__.__proto__.constructor === Worker;   //true\n\nHardWorker === HardWorker.prototype.constructor;     //true\nWorker === Worker.prototype.constructor;             //true\n\n``` \n\n\n# 객체의 본질이란 ?\n> Maintenance of State(state 관리=> 데이터은닉)  \n> Encapsulation of Functionality(기능의 캡슐화)  \n> Isolation of change(격리)\n\n\n```js\nconst EssentialObject = class {\n    // 데이터은닉(hide state): 내부의 상태를 감춤\n    #name = '';\n    #screen = null;\n\n    constructor(name) { this.#name = name };\n    camouflage(name) { this.#screen = (Math.random() * 10).toString(16).replace('.', '') };\n\n    // 캡슐화(encapsulation): 안에서 무슨 일이 일어나는지 노출하면 안됨\n    get name(){ return this.#screen || this.#name };\n}\n```\n\n## 데이터 은닉(hide State)\n> 내부 상태(데이터)를 감춰야 한다.\n* 객체지향에서 데이터 은닉은 필수(= 상태를 외부에 보여주지 않는다. = private) \n* 객체 지향은 메모리 참조로 움직여야 하는데 속성이 공개되는 순간 속성을 값으로 취득해서 쓰기때문에 value context가 프레임 전체에 관여 -> 객체지향은 무너진다. \n\n\n## 캡슐화(encapsulation)\n> 메소드를 추상화 시켜야 한다.\n* 메소드 안에서 무슨일이 일어나는지 노출하면 안된다(=밖에서는 추상화로 인식해야 한다.)\n    - 예시 ATM에서 돈뽑는 것: 돈달라는 인터페이스만 노출, but 실제로 카드인증, 신용인증, 보안인증 트렌젝션 준비, 확인, 데이터 연산등이 있다. \n* 안좋은예\n    - setAge() 함수가 있다고 하자. 이 함수는 캡슐화가 된게 아니다. 왜냐하면 age 필드를 날로 노출했으니까. 그렇다면 본질적으로 왜 setAge하는지 알아야 한다. **더 생각해서 setAdult setChild 메소드로 만들고 그안에 나이 조건이 있고 이 나이에 따라서 컨텐츠를 구분해야 한다. 이런식으로 더 깊이 생각해야한다.** 이렇게 직접노출하지 않고 기능의 캡슐화가 가능하다 \n\n```\n데이터 은닉, 캡슐화 대상 비교\n* 데이터 은닉: 데이터 대상\n* 캡슐화: 기능 대상 \n```\n\n## Isolation of change\n> 격리: 해당 변화가 일어났을때 그곳에만 변화가 일어나고 다른곳에 여파가 오지 않게 하는 것 \n\n* 소프트웨어는 '당연하게' 요구사항이 계속 변함으로 같이 계속 변한다.\n* 우리는 변화를 막을 수 없기 때문에 Isolation 하는 것이 목표다.\n* 객체지향에서 '변질'을 막고 다른곳으로 퍼지지 못하게 하는것이 이것 밖에 없다.(그래서 본질로 생각한다.)\n\n\n\n# 알려진 기본 설계 요령\n> SOLID원칙  \n> DI(의존성주입), DRY(중복방지), Hollyworld Principle(의존성 부패방지), Law of demeter(최소지식)\n\n## SOLID 원칙 \n* SRP Single Responsibility(단일책임)\n* OCP Open Closed(개방폐쇄)\n* LSP Liskov Substitusion(업캐스팅 안전)\n* ISP Interface Segregation(인터페이스분리\n* DIP Dependency Inversion(다운캐스팅금지)\n\n### SRP Single Responsibility(단일책임)\n> 수정하는 원인이 하나가 되도록 만드는 것\n* 이를 지키지 못했을때 산탄총 수술(shotgun surgery)가 필요하다 \n* [SRP(SOLID중 1개: Single Responsibility(단일책임))를 준수하는 객체망이 문제를 해결](https://happyjy.github.io/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%94%BC%EC%B8%A0%2086%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%201%ED%9A%8C%EC%B0%A8/#srpsolid%EC%A4%91-1%EA%B0%9C-single-responsibility%EB%8B%A8%EC%9D%BC%EC%B1%85%EC%9E%84%EB%A5%BC-%EC%A4%80%EC%88%98%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%A7%9D%EC%9D%B4-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0)\n\n### OCP Open Closed(개방폐쇄)\n* open\t\n\t- extends, implements를 할 수 있게 만드는 것 \n* closed\n    - 수정이 필요하면 기존 class를 만드는게 아니라 다른 extends, implemtns class를  만들어서 문제를 해결하는 것(=새로운 객체를 만들어서 해결)\n    - 문제의 공통점을 인식해서 추상화에 성공해서 그 다음에도 추상화를 이어 받아서 새로운걸 해결 할 수 있는 것이다. \n\n### LSP Liskov Substitusion(업캐스팅 안전)\n> 추상층의 정의가 너무 구체적이면 구상층 구현에서 모순이 발생\n* 아래 예제1 '추상층'에서 다리로 이동한다. 라는 정의때문에 구상층 '아메바, 독수리, 고래'에서 위배된다. 그래서 예제2를 다시 확인해보자 \n\n[예제1]\n```\n* 추상층 - 생물\n    - 숨을 쉰다. \n    - 다리로 이동한다.\n* 구상층(구현)\n    - 사람, 타조: OK\n    - **아메바, 독수리, 고래: NO**\n```\n\n* 아래 예제2를 보면 추상층을 두개로 나눴다. \n    - 생물 class, 다리이동 interface  \n\t\n[예제2]\n```\n* 추상층 - 생물(숨을 쉰다), 다리이동(다리로 이동한다)\n\n* 구상층(구현)\n    - 사람, 타조: \"생물\", \"다리이동\" -> OK\n    - 아메바, 독수리, 고래: \"생물\" -> OK\n```\n\n### ISP Interface Segregation(인터페이스분리)\n> 위 원칙 LSP가 성림하지 않았기 때문에 ISP(예제1 -> 예제2)작업이 있었다.\n\n* ISP 필요대상 \n\t- 아래 위임, 인터페이스로 해결하는 방법을 소개하겠습니다.\n![](ISP-1회/필요대상.png)\n\n* 위임으로 해결하는 방법  \n![](ISP-1회/위임.png)\n    - 위임(소유): 인터페이스로 분리하지 않고 처리하는 첫번째 옵션\n    - 모듈A, B, C 바라볼 객체를 만들어서 객체별로 A,B,C를 상대하도록 만들어 준다\n\n* 인터페이스로 해결하는 방법  \n![](ISP-1회/interface.png)  \n    - 객체를 만들때 처음부터 인터페이스 A, B, C 세개를 가져와서 인터페이스에 맞게 메소드를 오버라이드한다. \n    - 그래서 외부에서 볼때는 객체를 보는게 아니라, 객체가 구현한 인터페이스를 보게 된다. \n\n### DIP Dependency Inversion(다운캐스팅금지)\n> `의존성 역전`의 법칙이라고도함  \n> 의존성은 언제나 부모쪽으로 흘러야 한다. \n* 다운캐스팅을 안하면 나머지 SOLID원칙이 다 지켜지는것이기 때문에 어려운 항목이다. \n* 고차원의 모듈은 저차원의 모듈에 의존하면 안된다. **이 두 모듈 모두 추상화된것에 의존해야 한다.**\n    - 고차원: extends를 더 많이 한 것(자식 쪽)\n* 추상화 된 것은 구체적인 것에 의존하면 안된다. **구체적인 것이 추상화된 것에 의존해야한다.**\n\n## 기타 \n### DI(Dependency Injection, 의존성주입) \n* IoC(Inversion of control, 제어역전)의 일부, 구현체 중에 하나 \n\n### DRY(Don't Repeat YourSelf)(중복방지)\n\n### Hollyworld Principle(의존성 부패방지)\n* 요구하지 말고 요청 또는 기다려 내가 요청할께 \n* 액션이 처리할 사람이 거꾸로 연락하게 하는 패턴  \n* 은닉화, 캡슐화가 지켜지지 않은 경우\n\n### Law of demeter(최소지식)\n* classA.methodA의 최대지식한계 \n    - classA의 필드 객체\n    - methodA가 생성한 객체\n    - methodA의 인자로 넘어온 객체\n* 이 법칙이 지켜지지 않으면 **열차전복(train wreck)**가 일어난다. \n\n\n# Message\n> 다른객체에게의뢰하는것=다른객체에게메세지를보내는것  \n> 객체지향은 Message를 통해서 문제를 해결한다. \n\n\n## SRP(SOLID중 1개: Single Responsibility(단일책임))를 준수하는 객체망이 문제를 해결\n[SRP Single Responsibility(단일책임)](https://happyjy.github.io/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%94%BC%EC%B8%A0%2086%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%201%ED%9A%8C%EC%B0%A8/#srp-single-responsibility%EB%8B%A8%EC%9D%BC%EC%B1%85%EC%9E%84)\n* 책임이 상세하게 분리 \n\t- 각자의 역할만하고 다른놈에게 넘겨서 문제를 해결  \n\t: 마치 data structure에 linked-list처럼  \n\t: 이것이 객체지향이 문제를 해결하는 방법이다.\n    - 이렇게 문제를 해결하지 않고 쭉 코드를 짜면 수정하는 원인이 한가지가 아니라 여러가지 이다.  \n* 설계라는것은? \n    - 어디까지 나눠야할지 말아야할지 결정하는 것이다. \n    - 변화가 많이 일어나면 더 상세하게 나눠야 한다. \n* **단일 책임 원칙을 준수하는 객체에게 책임 이상의 업무를 부여하면?**\n    1. **만능 객체가 되려한다.** \n    2. **다른 객체에게 의뢰한다.**\n* **Message를 보낸다의 의미**\n    - **다른객체에게의뢰하는것 = 다른객체에게메세지를보내는것**\n\n### 메세지, 오퍼레이션, 메소드 용어 정리 \n1. `메세지`-의뢰할내용\n2. `오퍼레이션` - 메세지를 수신할 객체가 제공하는 서비스 \n    * 오퍼레이터\n        - 메세지를 수신 하는 역할을 한다. \n        - 실제로 잘동하지 않는다. \n        - 대외적으로 공개된 채널로 내부적으로 매핑(`런타임`구성)에 따라서 하나의 메소드를 실행시칸다. \n        - 위 worker.run()을 예를 들어서 생각해보자. \n            - run()이라는 `오퍼레이터`는 Wokrer, HardWorker 둘중 어느것을 수행할지는 worker.run()을 수행할 때 `런타임`이 정해져 어떤 run을 수행할지 정해진다. 이를 `동적바인딩`이라고 한다. 이렇게 javascript는 `prototype`에 의해서 동적 바인딩을 지원한다. \n\t\t\t- [prototype게시글-2 프로토타입 체인](https://happyjy.github.io/prototype/#2-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8)\n3. `메소드` - 오퍼레이션이 연결될 실제 처리기\n\n### 추상클래스, 인터페이스를 상속하게 하는 이유는?\n    - **오퍼레이션, 메소드를 분리해서 런타임에 원하는 애를 바뀌기 위해서**\n    - 결국 **SRP통해서 OCP(SOLID중 1개: Open Closed(개방폐쇄))를 만들어 낸다**\n\n\n# Dependency \n> 의존성은 가장 중요한 격리의 문제\n\n* 우리가 진짜 원하는 얘기\n* 격리가 되지 않는 이유?\n    - **문제가 되고 있는 객체를 의존해서**\n* 설계의 어려운 이유 \n    - SRP(위 대chapter Message-srp)설명할때는 책임을 상세하게 나누라고 했는데 여기서는 난눈 개체가 문제가 생기면 격리가 안되서 문제라고 한다. \n    - 그래서 이 둘(SRP, Dependency)을 고민해서 설계해야 한다.  \n    : 적당하게 의존성을 가지고 있어야한다.  \n* 의존성 다소의 차이\n    * 의존성이 많을때는 객체가 각자의 역할이 정해져있다. \n    * 의존성이 적을때는 한개의 객체가 많은 역할을 수행한다.\n\n## 의존성의 종류 \n> 두가지가 있다. \n> 1. 객체의 생명주기 전체에 걸친의존성 \n> 2. 각 오퍼레이션 실행 시 임시적인 의존성 - 의존(dependency)\n1. **객체의 생명주기 전체**에 걸친의존성 \n    * 상속(extends)\n        - **강력한 의존성으로 부모객체와 합체 된 개념으로 부모의 변화가 있으면 자식의 변화를 감수해야한다.** \n        - 그래서 상속이 안좋다고 하는 이유입니다. \n    * 연관(association)\n        - 필드의 그 객체 타입을 알고 있다. \n        - **예를 들어 A클래스에 B라는 멤버를 생성해서(소유), 생성한 B멤버 클래스는 클래스A인스턴스가 만들고 없어질때까지 B멤버 클래스와 연관이 있는것이다.** \n\n2. 각 **오퍼레이션 실행 시** 임시적인 의존성 \n    * 의존(dependency)\n        * 오퍼레이션 실행시에만 수행된다. \n        * 메소드 단위로만 의존성이 생겼다 없어지고 메소드를 한번도 호출하지 않으면 의존성이 없기도하다.\n\n### 의존성 문제를 해결하기 위해서 우리가 '지향'해야할 방법\n> 상속 -> 연관 -> 의존 단계로 우리는 지향해야 한다. \n* 상속 -> 연관\n    - 상속을 소유로 바꾼는 것 \n* 연관 -> 의존\n    - 연관도 빡시면 **의존 단계에서 연산에서 처리**하지 꼭 필드에서 참조할 객체를 잡아야 하냐에서 시작\n    - 필드가 없다는건 상태가 없다는 것 -> 객체가 없다는건 함수를 쓰라는 것(이것이 `함수형프로그래밍`)\n    \n* 객체지향에서는 연관 -> 의존 단계로 바꾸기 어렵다. 왜? \n    - **객체지향에서는 '상태'를 유지하고 있기 때문** \n        - 수정 여파 규모증가\n        - 수정하기 어려운 구조 생성 -> 순환의존성\n    - **그런데도 객체지향 클래스들도 함수들을 쓰려고 하는 이유가 의존성을 낮추기 위해서다** \n\n### 의존성이 높으면? \n1. 수정 여파 규모증가\n2. 수정하기 어려운 구조 생성\n3. 순환의존성 \n    - A, B 둘 사이 의존성 없다. \n    - A -> C -> D 이렇게 알고 있다.\n    - 그런데 여기서 D -> B를 알게 되면 A가 B를 알게 되는 경우가 생긴다.  \n    : A -> C -> D -> B\n    - 그래서 B를 고쳤는데 A가 문제가 생기는 이유가 된다. \n\n# 객체지향을 배우는 이유\n> `격리구간`을 세우고 `의존성`을 관리하기 위해서  \n>  \t\t- 의존성은 `변화에 대한 격리를 위해서`관리한다\n\n* 위 쳅터 \"Message-SRP\", \"Dependency\"에서 설명\n\n# Dependency Inversion\n> [DIP Dependency Inversion(다운캐스팅금지)](https://happyjy.github.io/%EC%BD%94%EB%93%9C%EC%8A%A4%ED%94%BC%EC%B8%A0%2086%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%201%ED%9A%8C%EC%B0%A8/#dip-dependency-inversion%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85%EA%B8%88%EC%A7%80)\n\n* Polymorphism\n> 어떠한 경우에도 다운캐스팅은 금지  \n> 폴리모피즘(추상인터페이스) 사용\n\n```js\nconst Worker = class{ \n    run(){ console.log(\"working\") }\n    print(){ this.run(); } \n};\nconst HardWorker = class extends Worker{ \n    run(){ console.log(\"hardWorking\") }\n};\n\nconst Manager = class { \n    #workers; \n    constructor(...workers) {\n        if(workers.every(w=>w instanceof Worker)) this.#workers = workers;\n        else throw \"invalid workers\"; \n    }\n    doWork(){ this.#workers.forEach(w=>w.run()) }; \n};\n\nconst manager = new Manager(new Worker(), new HardWorker()); \nmanager.doWork();\n```\n\n* **아래 나오는 다음 3가지 설명으로 OCP, DIP를 통해서 객체지향을 느끼는 초석을 다지는데 좋은 설명이였다.**\n    - \"OCP를 위 예제 코드를 통해 설명\", \"DIP(의존성 역전의 법칙)를 위 예제 코드를 통해 설명\", \"Manager class 기준으로 OCP, DIP를 설명\" \n    \n1. OCP를 위 예제 코드를 통해 설명 \n    * **worker 사상 검증시 Worker class기준으로 했다.** 이 의미는 HardWorker는 추상클래스로 본것이다.(폴리모피즘을 이용해서 대체가능성을 이용해서 추상클래스로 본것이다.) 하위 클래스를 인식하지 않음으로써 더 많은 하위 클래스 xxxWorker만들어도 Worker패밀리리면 다 받아준다는 의미이다. 그래서 Worker클래스를 확장해서 xxxWorker 클래스들을 많들어도 된다. \n        - 그래서 Manager class constructor에서 workers 사상검증시(instanceof 키워드를 통해서)Worker를 기준으로하고 있다.\n        - Worker 클래스를 확장한 xxxWorker 클래스들을 Manager class constructor에서 검증할때 constructor를 변경할 필요가 있을까? -> NO\n        - worker로 부터 더 많은 extention을 만들 수 있따 -> ***\"Open extend\"(확장이 열려있다)***\n        - 그럼에도 불구하고 Manager class constructor를 수정할 필요가 없다 -> ***변화에 \"Closed\"***\n    * OCP를 달성하면 자연스럽게 **의존성 역전**이 달성된다. \n\n2. DIP(의존성 역전의 법칙)를 위 예제 코드를 통해 설명\n    - Manager class constructor에서 의존성을 무엇으로 가지고 있는가? \n        - ***구상클래스(Hardworker) 가지고 있지 않고 추상클래스(Worker)로 가지고 있다.*** \n    - 그래서 Manager class에 doWork 함수에서는 run이 사용될 수 있는것인가? \n        - 추상클래스(Worker)에 run 함수가 있기 때문이다.\n        - 왜냐하면 Manager class contsructor에서 Worker 클래스로 사상검증 했기 때문이다. \n\n3. Manager class 기준으로 OCP, DIP를 설명\n    - constructor에서 `OCP`를 표현하고 싶고 Worker class level에서 instance를 인식할 것이니까 Manager class에서는 Worker level의 메서드를 쓸것이다.(`DIP`) 라고 해석 할수 있다. (HardWorker의 함수를 사용하지 않는다.)\n\n* OCP가 안되면 DIP가 될 수 없다.(OCP, DIP는 깊은 연관을 가지고 있다.)\n\n\n# Inversion of Control\n> 객체지향에서 가장 마지막으로 도달해야 할 지점   \n> DIP 조차도 IOC의 재료   \n> IOC에 도달하면 객체지향에 도달했다고 생각해도된다.   \n\n## **Inversion의 쉬운 설명**\n* 제어를 안한다는 의미가 아니라 **내가 직접하지 않고 위임 하겠다 라는 의미**\n* <u>예를 들어 내가 운전을 못하지만 운전잘하는 사람의 차를 타면 밖에서 볼때 운전 잘하는 사람? 으로 보일 것이다. 오 이게 Inversion of Driving...이라고 말할 수 있겠네...😅</u>\n\n## 제어역전의 개념과 필요성\n    1. Control = flow control(흐름제어) \n    2. 광의에서흐름제어 = 프로그램실행통제 \n    3. 동기흐름제어, 비동기 흐름제어 등\n\n## 문제점\n> 동적알고리즘(Dynamic Programing)에서 iterator를 돌면서 조건이 바뀌기 때문에 흐름제어가 어렵다. \n    1. 흐름 제어는 상태와 결합하여 진행됨\n    2. 상태 통제와 흐름제어 = 알고리즘\n    3. 변화에 취약하고 구현하기도 어려움\n        - 제어문이 많아질수록 유지 보수가 어렵다.  \n\n## 대안\n    1. 제어를 추상화하고\n        - 일반화라는 관점이 필요\n        - 제어들을 모으려면 공통된 부분, 다른 부분을 filter하는 게 필요하다. (`연역적추리`)\n        - 연역적 추리가 되면 원리를 뽑아내서 `귀납적 상황`을 만들어서 연역적 내용들을 모두 처리 할 수 있게 된다. \n        - 귀납적추리, 연역적추리\n            - 귀납적추리(Indcution): 원리를 가지고 현상을 예측하는 것\n            - 연역적추리(Deduction): 현상으로 원리를 깨닫는 것 \n    2. 개별 제어의 차이점만 외부에서 주입받는다.\n\n\n# 예제 소스 \n```js\n// POINT1\n// Renderer: base element에 view가 주는 element를 집어 넣어서 그림을 그리는 녀석 \nconst Renderer = class {\n    #view = null;\n    #base = null;\n    \n    constructor (baseElement) {\n        this.#base = baseElement;\n    }\n    set view (v) {\n        if(v instanceof View) this.#view = v;\n        else throw `invalid view: ${v}`;\n    }\n    render (data) {\n        const base = this.#base;\n        const view = this.#view;\n\n        if(!base || !view) throw 'no base or no view';\n        let target = base.firstElementChild;\n        //POINT2\n        //base안 element를 제거한다. \n        do base.removeChild(target);\n        while (target = target.nextElementSibling);\n        //POINT3\n        //view.getElement은 render function에 의해서 받은 data에 합당한 el을 반환 \n        //아래 renderer.view에 상속받아 구현함.\n        base.appendChild(view.getElement(data));\n        view.initAni();     //애니메이션 초기화 \n        view.startAni();    //애니메이션 시작해\n    }\n}\n\nconst View = class {\n    getElement (data) { throw `override!` };\n    initAni () { throw 'override!' };\n    startAni () { throw 'override!' };\n}\n\n//특정뷰를 받아서 그리는 역할 \nconst renderer = new Renderer(document.body)\n//POINT4\n//* new class extends View\n//  :익명클래스처럼 view를 상속받는 class를 하나 만들고 인스턴스를 만드는 코드 \nrenderer.view = new class extends View {\n    #el\n    //POINT5\n    //data에 의해서 받은 데이터로 dom을 생성해 본인(View를 상속받은 class)필드 '#el'에 집어 넣고 반환 \n    getElement (data) {\n        this.#el = document.createElement('div');\n        this.#el.innerHTML = `<h2>${data.title}</h2><p>${data.description}</p>`;\n        this.#el.style.cssText = `width:100%;background:${data.background}`\n        return this.#el;\n    }\n    initAni () {\n        const style = this.#el.style;\n        style.marginLeft = '100%';  //화면 밖 오른족으로 쭉 밀어버린다.\n        style.transition = 'all 0.3s';  //0.3이후에 오라고 transition 검 \n    }\n    startAni () {\n        //한프레임 건너뛰고 람다에서 style에 margin 0을 넣는건 마진 100%에서 왼쪽으로 쫚들어온다.\n        requestAnimationFrame(() => this.#el.style.marginLeft = 0);\n    }\n\n    \n}\n\nrenderer.render({ title:\"title test\", description:\"contents.......\", background:\"#ffffaa\"});\n```\n\n## 핵심1: Renderer, View Class 설명\n* Renderer class render 함수 레시피가 개별 View마다 만들어지지 않고 render에만 집중되어 있다. \n* Renderer class render 함수 레시피가 바로 제어문!\n    * 어떤 제어냐? \n        - 내용을 지우고 새로운 객체를 만들어서 내 자신을 만들어서 애니메이션을 처리 할꺼야 라는 레시피가 render안에 있다. \n        (== 제어문이 이 안에 있다라는 의미)\n* 그럼 이제 모든 뷰를 만들어 낼때 제어는 Renderer class의 render가 하고 제어에 해당하는 각각 부속물을 공급하는 역할을 view객체를 공급해주면 된다. \n* 그러면 앞으로 모든 뷰를 등장시킬때 render작업을 두번다시 할까? \n    - 안한다!    \n* Renderer class render 함수는 data에 맞는 view를 그리고 있다. \n\t- 그리고 제어부분이 집중되어 있고 개별뷰(set view)에는 제어부분이 없어진다. \n\t- 개별뷰(set view)에 있는 제어문은 render쪽에 모여 있다. \n* view가 가져야 할 제어를 render쪽으로 역전시켜서 한군데에만 있는 제어를 사용하고 이 제어에 부속(Veiw)으로써가 개별 공급해야할 내용들만 공급해준다는 의미\n* **제어의 역전**이 일어나고 있다.\n\t- <u>\"내가 view를 여러번 만들다 보니 계속 반복되는 내용을 render에다가 몰아 넣고 view는 필요한 부품만 render에 몰아 넣으면 될것 같다.\"라고 판단해 만든것이 Render class에 set view, render와 같다.</u>\n* **제어의 역전이 일어나니 \"의존성 역전\"(추상클래스를 받으니까)이 일어나고 \"OCP\"도 자동** \n\n\n## 핵심2: renderer.view객체 (View를 상속받은 instance 객체)\n* 뷰에대한 애니메이션 초기화와 애니메이션 동작은 각각 view에 대한 클래스에서 책임지고 있다. \n    - 전체적인 흐름은 Renderer class의 render가 한다. \n* 제어 역전에 들어가는 부속들은 일부 부속들(renderer.view가 가지고 있는 instance의 getElement, initAni, startAni)거기에 대한 일부 재료들만 제공만하고 실제 제어 부분은 빠지게 된다. 제어를다 중앙(Render class에 render)\n* 그래서 우리가 애니메이션 절차에 대해서 수정하고 싶으면 Render class의 render만 수정하면 된다. \n\n## 핵심3: 제어역전 코드(Renderer class의 render) & 제어역전에 대한 설명\n* Render class의 render쪽에 제어가 몰려 있고 공급되는 View들은 일부만 공급하게 된다 \n* 제어부분이 마음에 아니들면 renderer에서만 계속 고치면된다. 다른 애들은 '제어'에 대한 책임이 해제된다. 그래서 제어에 대한 부속(getElement, initAni, startAni)에만 관심을 갖게 되고 실제 제어는 renderer class의 render가 가져간다. \n* 스프링 프레임워크도 \"제어의역전\"을 사용하고 있다. 큰 프레임워크를 사용할때 사용하는 객체들은 controller들을 모은다. 그리고 web application이 움직이는건 '제어의역전'프레임워크가 해주는것이다. \n    - 제어의 역전의 의미\n    : 누군가 router태워서 필요한 컨트롤에 로딩해서 컨트롤에서 모델받아서 매칭되어 있는 뷰를 뿌려주는 이 과정 \n\n* 프레임워크, 라이브러리 차이 \n    - 프레임워크: 제어 역전이 있다.(IOC가 되어야 프레임워크가되는것이다)\n    - 라이브러리: 제어에 대한 책임 없음\n\n* IOC가 되어야 프레임워크는 받는 뷰를 요구한다.\n    - 나의 lifeCycle, 나의 미리 상속되어 있는 메소드들 일부만 구현에서 나에게 주기만하면 이를 제어해줄게이게 IOC 프레임워크이다. \n* 안드로이드 앱을 만들때 activity를 만들어야 하고 이 activity가 할수 있는 건 os에서 지정해놓은 메소드들만 구현한것이고 언제태어나고, 언제 만들어지고, 언제 앱이 뜨는지는 OS가 한다  \n\n\n# 제어역전 실제 구현\n\n* `전략패턴 & 템플릿 메소드 패턴` < `컴포지트 패턴` < `비지터 패턴` \n    - 오늘쪽으로 갈수록 넓은 범위의 제어 역전을 실현함\n    - 가장 소극전인 제어역전을 구현하고 있는 패턴은?   \n    : `전략패턴 & 템플릿 메소드 패턴` \n        - 전략패턴: 소유를 통한 제어의 역전 \n        - 템플릿메소드패턴: 상속을 통한 제어의 역전\n    - 위 예제 Renderer class는 `비지터 패턴`이다.\n\n## 추상팩토리 메소드 패턴\n* `비지터패턴`(위 예제 Renderer class)은 이미 만들어진 객체의 행위를 제어역전에 참여시킬 수 있지만 참여 할 객체 자체(View class)를 생성할 수 없음. 참여할 객체를 상황에 맞게 생성하고 행위까지 위임하기 위해 `추상팩토리 메소드 패턴`을 사용함.\n* 예를 들어 \n내가 피벗 테이블을 만들때 중간에 그래프, 플러그인이 끼워져 있으면 이것을 중간에 만들면서 셀을 만들고 싶다. 이미 주어져 있는 객체를 메소드 호출해서 만드는게 아니라 중간에 만들면서 끼워 넣고 싶다. 이렇게 만드려면 만들어주는 팩토리가 필요 \n* 그래서 `추상팩토리 메소드 패턴`은 `비지터 패턴`과 결함한다. \n    - 만드는것만 제공하는게 아니라 만들어진 메소드도 호출 가능하다 \n    - 그래서 `제어역전`을 구현하게 되면 `추상팩토리 메소드 패턴`을 사용 가능하게 되는 것이다. \n\n\n# 마무리 \n* 이번에 등장한 모든 디자인패턴들은 모두 `제어역전패턴`과 관련된 패턴이다.\n* 객체지향에서 `제어역전`을 궁극적으로 목표로 삼는 이유는 많은 버그를 제어문이 가지고 있어 제어를 한군데에서 하기 위함이다. \n* 앞으로 이어지는 4개의 강의는 샘플앱을 만들고 점진적으로 발전시켜가면서 제어역전, SOLID이 지켜지는지 확인하며 refactoring하고 기능을 붙여나갈 예정 \n","excerpt":"INTRO 목표 객체 지향을 자바스크립트로 해보자. 디자인 패턴과 함께 알아보자. 오늘 배운 이론 남은 4개 강의에서 활용. SOLID(SRP, OCP, LSP, ISP, DIP) Message, 의존성, DI, IOC,  Value Context…","fields":{"slug":"/객체지향 자바스크립트_1/"},"frontmatter":{"date":"Feb 23, 2020","title":"객체지향 자바스크립트 1회차(객체지향이란? with design Pattern)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n\njavascript Core를 정리하겠다고 마음먹고 제일 먼저 작성한 목록 입니다.\n뭘 정리해 할지 한눈에 보기 편해 정리하는데 확실한 동기부여가 돼서 공유합니다.\n\n\n![JavascriptRoadMap](JavascriptRoadMap.png)\n\n- 참고  \n코어 자바스크립트 - 위키북스","excerpt":"javascript Core를 정리하겠다고 마음먹고 제일 먼저 작성한 목록 입니다.\n뭘 정리해 할지 한눈에 보기 편해 정리하는데 확실한 동기부여가 돼서 공유합니다.  참고 코어 자바스크립트 - 위키북스","fields":{"slug":"/JavascriptRoadMap/"},"frontmatter":{"date":"Feb 16, 2020","title":"Javascript RoadMap","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\nsetTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래 3개를 직접 그리며 개념을 정리했다.\n\n\n# 이벤트 루프 설명 시 주요 용어\n    - 호출스택\n    - 백그라운드\n    - 테스크큐\n    - 이벤트 루프\n\n# 이벤트 루프 설명 예시\n```js\n\nconsole.log('Hi');\n\nsetTimeout(function(){\n    console.log('CB');\n}, 3000)\n\nconsole.log('bye');\n\n```\n* 위 코드 결과는 Hi, bye, CB 순서로 로그가 남게 된다. 아래 설명을 참고\n* 만약 setTimeout이 0초로 설정하게 된다면 로그는 어떻게 출력이 될지 아래 설명을 보면서 생각해보자 \n\n## 이벤트 루프 예시 도식화/ 설명\n![](eventLoop1.jpg)\n* 상태 \n    - console.log('Hi')가 수행되어 콘솔에 찍히고 `호출스택`에서 빠진 상태\n* 설명\n    1. setTimeout이 수행되어 setTimeout callback function이 `백그라운드`로 이동된 상태\n    2. setTimeout callback function이 `백그라운드`로 이동\n    3. 3초후에 setTimeout callbakc function이 수행 되도록 설정 되어 있기 때문에 3초 이후 `태스크 큐`로 이동\n\n![](eventLoop2.jpg)\n\n* 설명\n    4. `호출 스택`실행이 끝나면 \n    5. `이벤트루프`는 태스크 큐의 callback function을 `호출 스택`으로 올린다.\n\n![](eventLoop3.jpg)\n* 설명  \n    6. run(setTimeout callback function)이 `호출 스택`에서 실행 되고 비워지게 된다.  \n    7. `이벤트루프`는 `태스크 큐`에 callback function이 들어올 때까지 대기\n\n\n# 추가 설명\n* setTimeout 0초는 4ms 지연 시간을 갖고 있어 hi, bye, CB 순서대로 로그가 남게 된다.\n* 백그라운드에서 3초를 설정했음에도 3초 후에 실행되지 않는경우 \n    - 호출 스택에서 많은 일을 하게 되면 이벤트루프가 태스크 큐에 쌓이 콜백함수들을 호출스택으로 끌어 올리지 못하기 때문\n* 백그라운드 사용하는 작업\n    - setTimeout, setInterval\n    - ajax 요청\n    - event Listener  \n        : 참고  http://latentflip.com/loupe/\n    - File Reader\n    - Javascript 기본제공 메소드 중 콜백 함수를 사용하는 메소드는 백그라운드를 사용하는 경우가 많다.\n\n# 참고 \n* 1. 제로초\n* 2. JSConf\n    - https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title","excerpt":"setTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래…","fields":{"slug":"/eventLoop/"},"frontmatter":{"date":"Feb 16, 2020","title":"eventLoop","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n\n예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source를 사용하려면 당연히 사용 할수 없습니다.  \n(**스크립트 읽기가 지금 당장 시작되더라도 실행은 함수가 종료되고 난 후에야 실행되므로 스크립트는 ‘비동기적으로’ 실행되었다고 할 수 있습니다.**)\n\n이렇게 비동기 적으로 실행되고 있는 문제를 해결하기위해서 callback기반 비동기 프로그램 방법으로 해결 할 수 있습니다.  \n(**무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공** -> script load를 보장 하는 loadScript function capter)\n\n하지만 callback기반 비동기 프로그램은 callback hell이라는 단점이 있고 이런 문제를 해결 할 수 있는 방법이 'promise, Async, awiat'fksms 개념이 있습니다. -> callback hell capter\n\n\n\n# callback function \n## script load를 보장 할 수 없는 loadScript function\n* document객체에 생성한 script객체를 추가해주면 추가한 script 주소를 통해서 원하는 파일을 받을 수 있다.\n* `loadScript` 구현\n    ```js\n    function loadScript(src) {\n        // creates a <script> tag and append it to the page\n        // this causes the script with given src to start loading and run when complete\n        var script = document.createElement('script');\n        script.src = src;\n        document.head.append(script);\n    }\n    ```\n\n    ```js\n    loadScript('/my/script.js'); // the script has \"function newFunction() {…}\n    newFunction(); // no such function!\n    ````\n* sciprt.js에 newFunction() 이 있다고 하자 loadScript를 통해서 받은 script.js파일에 선언한 newFunction()을 호출 하면 호출하지 못 한다.\n* 이유는 브라우저가 script.js 파일을 받기 전에 newFunction을 호출 했기 때문이다.\n* 그래서 **파일을 받고 function을 호출 시키는 보장해주는 코드를 추가 해야한다.**\n\n## script load를 보장 하는 loadScript function\n* 위 load를 보장하지 못하는 코드와 달라진점은 `callback` function 을 parameter로 전달해주고 loadScript는 전달 받은 param을 script onload property에 추가해줬다.\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(script);   // 기능 개선한 부분\n\n        document.head.append(script);\n    }\n    ```\n\n### script laod를 보장하는 예제\n* load를 보장하는 기능이 개선 된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n        script.onload = () => callback(script);       //POINT\n        document.head.append(script);\n    }\n\n    loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n        console.log(`Cool, the script ${script.src} is loaded`);\n        console.log( _ ); // function declared in the loaded script\n    });\n    ```\n* 결과 \n    - loadScript callback function을 확인해보면 콘솔 로그가 두개 있는데. script.src에 추가한 loadScript 첫번째 param loadash cdn 주소를 포함한 문자열과 load한 lodash lib의 _ 객체를 확인 할 수 있다.\n    - **callback function은 받고 싶은 파일을 로드한뒤 사용할 수 있는 공간이다.**(loadScript callback callback function으로 넘어 갔기 때문)\n\n* 정리 \n    - **이런 방식을 `콜백 기반(callback-based)` 비동기 프로그래밍이라고 합니다. 무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공해야 합니다.**\n\n# callback in callback \n* 위 예제 처럼 callback으로 하나의 파일만 로드할 뿐만 아니라 여러개도 load하고 싶을 것이다. \n* 아래 예제와 같이 구현 할 수 있을 것이다.\n    ```js\n    loadScript('/my/script.js', function(script) {\n\n        loadScript('/my/script2.js', function(script) {\n\n            loadScript('/my/script3.js', function(script) {\n            // ...continue after all scripts are loaded\n            });\n\n        })\n\n    });\n    ```\n\n# Handling errors \n* error 처리를 할 수 있는 기능이 개선된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(null, script);\n        script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n        document.head.append(script);\n    }\n    ```\n* 에러 처리 기능이 개선된 laodScript 를 사용하는 방법\n    - callback function에 2개의 param을 설정한다.\n        - 첫번째 parameter: error 객체\n        - 두번째 parameter: loadScript로 받고 싶은 script src string 객체\n    ```js\n    loadScript('/my/script.js', function(error, script) {\n                if (error) {\n                    // handle error\n                } else {\n                    // script loaded successfully\n                }\n    });\n    ```\n\n# callback hell\n* callback을 사용해서 비동기 처리가 유용해보인다. 하지만 callback in callback capter에서 확인해볼 떄 callback 안에 callback을 사용함으로 아래 코드와 같이 가독성이 떨어지는 결과를 가지고 옵니다.\n\n* callback hell 예제\n    ```js\n    loadScript('1.js', function(error, script) {        // 첫번째 callback\n\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', function(error, script) {    // 두번째 callback\n                if (error) {\n                    handleError(error);\n                } else {\n                    // ...\n                    loadScript('3.js', function(error, script) {    // 세번째 callback\n                        if (error) {\n                            handleError(error);\n                        } else {\n                            // ...continue after all scripts are loaded (*)\n                        }\n                    });\n\n                }\n            })\n        }\n    });\n    ```\n\n* 이를 해결하기 위해서 아래와 같이 **중첩하는 callback function**으로 callback hell을 만들지 않고 function을 top-level로 나눠 조금더 가독성이 쉽게 구현 할 수 있습니다. \n    ```js\n    loadScript('1.js', step1);\n\n    function step1(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', step2);\n        }\n    }\n\n    function step2(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('3.js', step3);\n        }\n    }\n\n    function step3(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...continue after all scripts are loaded (*)\n        }\n    };\n    ```\n* 하지만 step1, 2, 3과 같은 function은 연쇄 작용하는 코드 밖에서 사용할 수 없는 단점이 있습니다. 그래서 이런 점과 callback hell을 피할 수 있는 \"promise, Asynch/await\" 개념을 정리해보겠습니다.\n\n\n# 참고 \n- javascript.info  \nhttps://javascript.info/callbacks#callback-in-callback","excerpt":"예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source…","fields":{"slug":"/callback,Promise,async&await_1/"},"frontmatter":{"date":"Feb 16, 2020","title":"callback","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\npromise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다.\n\n# promise chaing 방법 두가지 \n## promise chaining 첫번째 방법(1/2)\n\n* promise객체의 하나에 then을 여러개 연속으로 연결해서 사용하는 방법으로 사슬고리처럼 연결되어 있어 다음 then에 value를 넘겨 줄 수 있습니다.\n    ```js\n        new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000); // (*)\n        }).then(function(result) { // (**)\n            alert(result); // 1\n            return result * 2;\n        }).then(function(result) { // (***)\n            alert(result); // 2\n            return result * 2;\n        }).then(function(result) {\n            alert(result); // 4\n            return result * 2;\n        });\n    ```\n\n\n## promise chaining 두번째 방법(1/2)\n* then을 선언할때마다 promise를 사용해서 선언하게 되면 모든 선언한 then에 pomise의 결과가 전달이 됩니다.\n    ```js\n        var promise = new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000);\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n    ```\n\n# 프로미스 반환하기 \n* 아래 예제 설명 \n    - 예시에서 첫 번째 .then은 1을 출력하고 new Promise(…)를 반환((*))합니다.  \n    - 1초 후 이 프라미스가 이행되고 그 결과(resolve의 인수인 result * 2)는 두 번째 .then으로 전달됩니다. \n    - 두 번째 핸들러((**))는 2를 출력하고 동일한 과정을 반복합니다.\n* **프라미스를 반환하는 것도 비동기 작업 체인을 만들 수 있다.**\n\n    ```js\n    new Promise(function(resolve, reject) {\n        setTimeout(() => resolve(1), 1000);\n    }).then(function(result) {\n        alert(result); // 1\n        return new Promise((resolve, reject) => { // (*)\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) { // (**)\n        alert(result); // 2\n        return new Promise((resolve, reject) => {\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) {\n        alert(result); // 4\n    });\n    ```\n\n# 예제: loadScript callback function 해결하기 \n\n    ```js\n    loadScript(\"/article/promise-chaining/one.js\")\n        .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n        .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n        .then(script => {\n            // 스크립트를 정상적으로 불러왔기 때문에, 스크립트 내의 함수를 호출할 수 있습니다.\n            one();      //...one.js에 있는 function \n            two();      //...two.js에 있는 function \n            three();    //...three.js에 있는 function\n        });\n    ```\n\n# fetch와 함께 체이닝 함께 응용하기 \n\n* 프론트 단에선, 네트워크 요청 시 프라미스를 자주 사용합니다. \n* 예시에선 메서드 fetch를 사용해 원격 서버에서 사용자 정보를 가져오겠습니다. \n* fetch는 promise객체를 반환 하기 때문에 fetch로 원하는 정보를 가지고 오고 promise에서 설명한 것 처럼 then을 통해서 후처리를 할 수 있습니다.\n\n    ```js\n    fetch('/article/promise-chaining/user.json')\n        // 원격 서버가 응답하면 .then 아래 코드가 실행됩니다.\n        .then(function(response) {\n            // response.text()는 응답 텍스트 전체가 다운로드되면\n            // 응답 텍스트를 새로운 이행 프라미스를 만들고, 이를 반환합니다.\n            return response.text();\n        })\n        .then(function(text) {\n            // 원격에서 받아온 파일의 내용\n            alert(text); // {\"name\": \"iliakan\", isAdmin: true}\n        });\n    ````\n\n# 참고 \n- javascript.info  \nhttps://javascript.info/promise-chaining","excerpt":"promise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다. promise chaing 방법 두가지 promise chaining 첫번째 방법(1/2) promise객체의 하나에 then…","fields":{"slug":"/callback,Promise,async&await_3/"},"frontmatter":{"date":"Feb 16, 2020","title":"Promise chaning","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n* javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다.\n\n```\n목차 \n# excutor: promise\n# 소비자: then, catch, finally\n# 예시: loadScript\n```\n\n# excutor: promise\n\n* \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // executor (제작 코드, \"가수\")\n    });\n    ```\n    - excutor는 아래 콜백 중 하나를 반드시 호출해야 합니다. \n        - resolve(value): 성공적으로 끝난 경우 결과를 value param으로 전달하며 resolve 호출\n        - reject(error): 에러 발생시 에러 객체를 error param으로 전달하며 reject 호출\n\n* new Promise(executor)의 callback 'resolve(value)', 'reject(error)'의 state, result 상태 \n* new Promise 생성자가 반환하는 promise 객체는 다음과 같은 내부 프로퍼티를 갖습니다.\n    - state: 처음엔 \"pending\"(보류)이었다 resolve가 호출되면 \"fulfilled\", reject가 호출되면 \"rejected\"로 변합니다.\n    - result: 처음엔 undefined이었다, resolve(value)가 호출되면 value로, reject(error)가 호출되면 error로 변합니다.\n\n\n* 성공일때 예제(resolve) \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 프라미스가 만들어질 때 executor 함수는 자동으로 실행됩니다.\n\n        // 1초 뒤에 일이 성공적으로 끝났다는 신호와 함께, result가 'done'이 됩니다.\n        setTimeout(() => resolve(\"done\"), 1000);\n    });\n    ```\n\n* 실패일때 예제(reject)\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 1초 뒤에 에러와 함께 실행이 종료되었다는 신호를 보냅니다.\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    ```\n\n* resolve/reject 함수 호출 규칙\n    - excutor에 의해서 끝난일은 resolve, reject중 첫번째로 오는 것만 수행됩니다.\n    - 나머지는 무시\n    \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      resolve(\"done\");\n\n      reject(new Error(\"…\")); // 무시됨\n      setTimeout(() => resolve(\"…\")); // 무시됨\n    });\n    ```\n\n\n# 소비자: then, catch, finally\n> 프라미스 객체는 executor(‘제작 코드’ 혹은 ‘가수’)와 결과나 에러를 받을 소비 함수(‘팬’)를 이어주는 역할을 합니다. 소비함수는 .then, .catch, .finally 메서드를 사용해 등록(구독)됩니다.\n\n\n## then\n> excutor가 성공, 실패 한경우를 모두 handling 할 수 있다. \n> then parameter에 두개를 전달해줄 수 있는데 첫번째는 param에 성공 handling function, 두번째는 param에 실패 hanlding function을 전달할 수 있다.\n\n* excutor가 성공적으로 수행한 경우\n    - POINT 주석 참고\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      setTimeout(() => resolve(\"done!\"), 1000);\n    });\n\n    // POINT: resolve 함수는 .then의 첫 번째 함수(인수)를 실행합니다.\n    promise.then(\n        result => alert(result), // 1초 후 \"done!\"을 출력      \n        error => alert(error) // 실행되지 않음\n    );\n    ```\n    - 아래 와 같이 성공했을때는 작성 가능하다 \n        - then function에 parameter 한개만 전달해주면 된다.\n        ```js\n        var promise = new Promise(resolve => {\n            setTimeout(() => resolve(\"done!\"), 1000);\n        });\n\n        promise.then(alert); // 1초 뒤 \"done!\" 출력\n        ```\n\n* excutor가 에러로 필해한 경우\n    - POINT 주석 참고 \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    // POINT: reject 함수는 .then의 두 번째 함수를 실행합니다.\n    promise.then(\n        result => alert(result), // 실행되지 않음\n        error => alert(error) // 1초 후 \"Error: 에러 발생!\"를 출력\n    );\n    ```\n\n\n## catch\n> excutor 수행 결과 중 error만 다루고 싶을 때 사용\n\n* 예시\n    - POINT 주석 참고\n    - .catch(f)는 문법이 간결하다는 점만 빼고 .then(null,f)과 완벽하게 동일\n    \n    ```js\n    var promise = new Promise((resolve, reject) => {\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    // POINT\n    // .catch(f)는 promise.then(null, f)과 동일하게 작동합니다\n    promise.catch(alert); // 1초 뒤 \"Error: 에러 발생!\" 출력\n    ```\n\n## finally\n> try... catch에 finally가 있는 것 처럼 promise에도 finally가 있다.\n\n\n* finally 예1  \n    : finally 이후 then을 통해 resolve 결과를 then으로 전달\n    ```js\n    new Promise((resolve, reject) => {\n        setTimeout(() => resolve(\"result\"), 2000)\n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .then(result => alert(result)); // <-- .then에서 result를 다룸\n    ```\n\n* finally 예2  \n    : finally 이후 cath를 통해 \n    ```js\n    new Promise((resolve, reject) => {\n        throw new Error(\"에러 발생!\");\n        // setTimeout(()=>{ reject(new Error('error'))}, 1000); // excutor 처리 시점만 조금 다르고 같은 결과 \n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .catch(err => alert(err)); // <-- .catch에서 에러 객체를 다룸\n    ```\n\n# 예시: loadScript\n* callback에서 loadScript 설명에서 callback hell을 해결 할 수 있는 방법이 promise라고 했는데 그 방법을 소개하겠다.\n\n* promise로 구현한 loadScript\n    ```js\n    function loadScript(src) {\n        return new Promise(function(resolve, reject) {\n            var script = document.createElement('script');\n            script.src = src;\n\n            script.onload = () => resolve(script);\n            script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));\n\n            document.head.append(script);\n        });\n    }\n    ```\n\n* 사용 방법\n    ```js\n    var promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\n    promise.then(\n        script => alert(`${script.src}을 불러왔습니다!`),\n        error => alert(`Error: ${error.message}`)\n    );\n\n    promise.then(script => alert('또다른 핸들러...'));\n    ```    \n    - 설명\n        - loadScript(script)로 스크립트를 읽고, 결과에 따라 그다음(.then)에 무엇을 할지에 대한 코드를 작성하면 되죠.\n    - 비교 \n        - 콜백으로 구현시에 loadScript(script, callback)를 호출할 때, 함께 호출할 callback 함수가 준비되어 있어야 합니다.  \n          loadScript를 호출하기 이전에 호출 결과로 무엇을 할지 미리 알고 있어야 했다.\n    \n\n# 참고 \n- javascript.info  \nhttps://javascript.info/promise-basics\n","excerpt":"javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다. excutor…","fields":{"slug":"/callback,Promise,async&await_2/"},"frontmatter":{"date":"Feb 16, 2020","title":"promise","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# 개발자로 어떻게 살 것인가? \n > 2020년 2월 4년 3개월차 개발자의 고민 작성 \n\n* 개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년 8개월이 지났다. 늦게 시작한 만큼 효율적으로 **목적을 정해두고 목표를 세워 시간을 만회하고 싶어** 작성하기 시작했다.\n\n\n\n# 목적 \n> fw/lib 익혀 비즈니스 개발에만 그치지 않고 CTO 성향을 가진 개발자  \n> 인문학도 공부하며 커뮤니케이션에 원활한 사람  \n> 사회/정치에도 관심을 두면서 개발자로서 그사이에 내가 해야 할 일을 고민하기  \n\n* FW/LIB 익혀 비즈니스 개발에 그치지 않고 원리를 알고 개발하며 나아가 **'설계, 성능, 보안, 설계에 관심을 두고, product level로 만들 수 있는 능력, 문제가 있을때 어디가 통찰력 있게 해결할 수 있는 능력, 지식 습득을 교양을 쌓는다고 여기며 꾸준하게** 할 수 있는 개발자가 되고 싶다. \n\n* 위 능력을 갖추면서 \"이슈\"가 생겼을 때 **먼저 나서서** 처리 할 수 있는 능력을 갖추고 싶다.\n\n\n# 목표 \n> 지속적으로 작성 계획\n\n## javascript개념을 정리하게된 계기\n* 그동안 공부해온 것을 정리하고 그다음으로 넘어가고 싶었다. \n    한 언어를 깊게 공부하고 싶었다. \n    - 이유는   \n    : 다른 언어를 배우더라도 내가 아는 개념과 뭐가 다르고 같은지 비교/생각해가며 공부하면 더 재밌고 수월할 것 같다고 생각했기 때문이다.  \n    : react, node를 사용해 toy project를 진행하며 Javascript를 느낄 수 있을 정도로 알고 싶었다.  \n    : 이슈 해결을 수월하고 더 재미있는 개발, 더 좋은 퍼포먼스를 낼 수 있을 거라고 느꼈다.\n    : Javascript를 정리해야 그다음 단계(설계, lib, fw)로 넘어갈 수 있는 자격이 주어지는 거라고 스스로 생각해서 꼭 해야겠다고 생각했다.\n\n## 그래서 그다음단계는? \n* 코드스피츠에서 front-end 관련해서 design pattern과 view Pattern을 정리/ project 완료하기  \n* react, node로 toy project 한 것 정리/ 확장\n    - 사용한 기술 정리를 통해서 공식 라이브러리 확인하기\n    - 스스로 개발지식을 습득하고 적용하는 연습\n* 알고리즘 문제를 풀면서 생각하는 연습을 지속해서 연습\n\n","excerpt":"개발자로 어떻게 살 것인가? 2020년 2월 4년 3개월차 개발자의 고민 작성  개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년…","fields":{"slug":"/개발자로 어떻게 살 것 인가/"},"frontmatter":{"date":"Feb 12, 2020","title":"개발자로 어떻게 살 것 인가?","tags":["생각정리"]}}},{"node":{"rawMarkdownBody":"\n자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.\n\n\n```js\n\t1 클래스와 인스턴스의 개념 이해\n\t2 자바스크립트의 클래스\n\t3 클래스 상속\n\t\t3-1 기본 구현\n\t\t3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n\t\t3-3 constructor 복구 하기 \n\t\t3-4 상위 클래스에 접근 수단 제공\n\t4 ES6의 클래스 및 클래스 상속\n\n```\n# 1 클래스와 인스턴스의 개념 이해\n* 클래스\n    - **공통 속성, 기능 정의한 추상적 개념**\n    - 클래스를 바탕으로 인스턴스를 만들 때 비로소 어떤 객체가 클래스의 속성을 지닌다.\n    - 어떤 인스턴스가 다양한 클래스에 속할 수는 있지만 이 클래스들은 모두 인스턴스 입장에서는 '직계존속'\n    - 다중상속을 지원하는 언어이든 그렇지 않은 언어이든 결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐일 수 밖에 없기 때문\n\n* 인스턴스\n    - 클래스에 속한 객체 \n\n* static member(static method, static properties)\n    - 클래스 자체에서만 동작\n* prorotype method\n    - 인스턴스에서 활용 가능\n\n# 2 자바스크립트의 클래스\n\n* 생성자 함수 Array를 new연선자와 함께 호출하면 인스턴스 생성 하는 과정을 통한 설명\n    - Array를 일종의 클래스라고 하면, **Array의 prototype 객체 내부 요소들이 인스턴스에 '상속'**된다고 볼 수 있다. \n        - **엄밀하게 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으로 동일하게 동작**\n    - ***한편 Array 내부 프로퍼티들 중 prorotype 프로퍼티를 제외한 나머지 인스턴스에 상속되지 않는다.***  \n    (=== static member: static method, static properties)\n\n    - 인스턴스에 상속되는지(인스턴스가 참조하는지) 여부에 따라 **\"static member\"(상속불가능)**와 **\"instance member\"(상속가능)**로 나뉜다.\n        - 이 분류는 다른 언어의 클래스 구성요소에 대한 정의를 차용한것으로 클래스 입장에서 사용대상에 따라 구분한것 \n        - 하지만 **자바스크립트는 다른 언어와 달리 인스턴스에서도 직접 메서드를 정의할 수 있다.**\n        - 그래서 '인스턴스 메서드'라는 명칭은 프로토타입에 정의한 메서드를 지칭하는 것인지 인스턴스에 정의한 메서드를 지칭하는것인지 혼란이 올 수 있다.  \n        따라서 **프로토타입에 정의한 메서드를 프로토타입 메서드라고 부른다.**\n\n\n    - 도식화 - Array constructor function\n    ![](class&instance.jpg)\n\n    - 도식화 - prorotype, \\_\\_proto__, instance\n    ![](class&instance2.jpg)\n\n*  실제 예제\n```js\n    function Person(name, age){\n        this._name = name;\n        this._age = age;\n    }\n\n    Person.getInformations = function(inst){    //Static emthod\n        return{\n            name: inst._name,\n            age: inst._age\n        };\n    }\n    Person.prototype.getName = function(){      //(prototype) method\n        return this._name;\n    }\n    Person.prototype.getAge = function(){       //(prototype) method\n        return this._age;\n    }\n\n\n    var yoon = new Person(\"happyjy\", 30);\n    console.log(yoon.getName());    //happyjy\n    console.log(yoon.getAge());     //30\n\n    console.log(yoon.getInformations(yoon));    \n    //에러! yoon.getInformations is not a function\n    //생성자 함수 property(getInformations)에는 인스턴스가 직접 접근하지 못한다.\n    //생성자 함수 property는 인스턴스로 상속할 수 있는 프로퍼티로 만들지 않는다.\n    console.log(Person.getInformations(yoon)); //{name: \"happyjy\", age: \"30\"}\n    //생성자 함수 property는 생성자 함수로만 접근이 가능하다.\n```\n\n\n# 3 클래스 상속\n## 3-1 기본 구현\n* 구현 point\n    1. 프로토타입 설정\n    2. contsructor 복구\n\n    ```js\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.name = name || '홍길동(setting by Employee function)';\n        this.age = age || 0;\n        this.position = position || '미정';\n    };\n\n    //1.prorotype 설정\n    Employee.prototype = new Person();      // 이 코드에 의해서 new Employee에 의해서 생성된 인스턴스.__proto__에 Person 인스턴가 세팅된다.\n    //2. constructor 복구\n    Employee.prototype.constructor = Employee;  // prototype에서 다뤘던 내용\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    };\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n- mac의 결과 값\n    - ***문제: mac.\\_\\_proto__에 추상적이어야할 클래스 prorotype 담겨 있는 것***\n    - 만약 delete mac.name이후 mac.getName을 하면 undefined가 return 되어야 하는데 prototype chain에 의해서 홍길동(mac.__proto__ property)이 반환된다.\n    - 그래서 아래 예제 \"prototype\"로 상속 구현하기에 extendClass에 의해서 문제를 해결할 수 있다. \n        - 문제 해결 방법 요약: 상속할때 parent, child class 사이에서 extend해주는 개념이 필요하다  \n        : 아래 3-2, 3-3, 3-4 capter에서 다루도록 하겠다.\n\n    ![](Employee상속.png)\n\n\n\n## 3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **1,2번** 참고 \n\n## 3-3 constructor 복구 하기 \n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **3번** 참고 \n\n## 3-4 상위 클래스에 접근 수단 제공\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **4번** 참고 \n\n* extend Class 구현 개념\n    - 아래 구현 예제 주석 1,2,3,4번 코드 참고\n![](extendClass.jpg)\n\n* extendClass구현으로 prototype상속 구현\n\n    ```js\n    //* es5에서 많이 사용해서 아래와 같이 클래스 상속을 구현 \n    //* 클로저를 생성해서 'Bridge'를 단한번만 사용할 수 있게 함 \n    var extendClass = (function(){\n        function Bridge(){}\n        return function(Parent, Child){\n            Bridge.prototype = Parent.prorotype;  //1번\n            Child.prototype = new Bridge();       //2번\n            Child.prototype.constructor = Child;  //3번\n            Child.prototype.superClass = Parent;  //4번\n        }\n    })();\n\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.superClass(name, age); //4번: 하위 클래스에서 이런 호출로 상위 클래스가 설정한 프로퍼티 세팅 가능\n        this.position = position || '미정'\n    }\n\n    \n    extendClass(Person, Employee);\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    }\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n* 결과 \n![](extendClass적용.png)\n\n* 짚고 넘어가자! - this.superClass에 대해서 \n    - this.superClass는 Parent object이기 때문에 Person constructor function에서 name, age설정\n    - Person constructor function에서 this.name, this.age에 설정 시 this scope은 \"Employee instance object\"라서 위 결과 처럼 name, age가 Employee instance property에 설정 된다.\n\n\n# 4 ES6의 클래스 및 클래스 상속\n* class로 상속 구현하기\n```js\n    class Person {\n        constructor (name, age) {\n            this.name = name || '아무개';\n            this.age = age || '0';\n        }\n\n        getName(){\n            return this.name;\n        }\n\n        getAge(){\n            return this.age;\n        }\n    }\n\n    class Employee extends Person {\n        constructor (name, age, position){\n            super(name, age);\n            this.position = position || '미정';\n        }\n        getPosition(){\n            return this.position;\n        }\n\n    }\n```\n\n\n# 참고 \n* 코어 자바스크립트","excerpt":"자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.…","fields":{"slug":"/class/"},"frontmatter":{"date":"Feb 11, 2020","title":"class","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\njavascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자. \n\n\n```js\n\t1 프로토타입의 개념 이해 \n\t\t1-1 constructor, prototype, instance\n\t\t1-2 constructor 프로퍼티\n\t2 프로토타입 체인\n\t\t2-1 메서드 오버라이드\n\t\t2-2 프로토타입 체인\n\t\t2-3 객체 전용 메서드의 예외사항\n\t\t2-4 다중 프로토타입 체인\n```\n\n# 1 프로토타입의 개념 이해 \n# 1-1 Constructor, prototype, instance\n\n* Constructor\n    - A function that initializes an object\n    - similar to normal javaconstuctor\n* prototype\n    - Constructor의 property\n    - instance의 property \\_\\_proto__과 메모리 공유  \n    : constructor.prototype === instance.\\_\\_proto__\n* instance\n    - Constructor를 new키워드로 호출로 생성한 객체\n\n* prototype 도식\n    ![](프로토타입도식.jpg)\n    * 왼쪽 꼭짓점: Constructor(생성자 함수)\n    * 오른쪽 꼭짓점: Constructor.prorotype 프로퍼티\n    * new를 통해 instance 생성\n    * instance.\\_\\_proto__\n\n* 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출하면\n    * Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성됩니다.\n    * 이때 instance에는 \\_\\_proto__라는 프포퍼티가 자동으로 부여\n    * 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조\n\n* prototype 개념의 핵심: prototype 프로퍼티, \\_\\_proto__라는 프로퍼티\n    * **prototype은 객체**\n    * **이를 참조하는 \\_\\_proto__도 객체**\n    * prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장\n    * 그러면 인스턴스에서도 숨겨진 프로퍼티인 \\_\\_proto__를 통해서 이 메서들을 접근할 수 있게 된다.\n\n    ```js\n    var Person = function(name) {\n        this._name = name;\n    }\n\n    Person.prototype.getName = function(){\n        debugger;\n        return this._name;\n    }\n\n    //---\n    typeof Person                   // function\n    typeof new Person('boa');       // object\n    new Person('boa');              // Person {_name: 'boa'}\n    new Person('boa').__proto__     // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    Person.prototype                // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    //---\n    \n    var boa = new Person('boa');\n    boa.__proto__.getName();    //undefined\n    boa.getName();              //boa\n    /*\n        boa.__proto__에 _name 프로퍼티가 없어 식별자(this._name)를 찾을 수 없다.\n        * boa.__proto__.getName();, boa.getName(); \n            - getName이 호출 돼 scope에 있는 this가 서로 다르다. 그래서 결과 값이 다르다.\n            - boa.__proto__ this -> {getName: f, constructor: f}\n            - boa this ->  Person {_name: 'boa'} \n\n    */\n\n    Person.prototype === boa.__proto__;\n    /*\n        Constructor function의 prototype으로 생성한 instnace 'boa'의 property '__proto__'객체는 Consytructor function의 객체는 메모리를 공유하고 있다.\n\n        이런 특징으로 \n        instance.__proto__ property를 변경하면 Constructor.prototype도 변경이 된다.\n        즉 instance.__proto__, Constructor.prototype 객체는 메모리를 공유하고 있따. \n    */\n\n    var boa = new Person('boa');\n    boa.__proto__._name = 'boa.__proto__';\n    boa.__proto__.getName() =               //Boa__proto__\n    /*\n        * boa.__proto__.getName() 에 의해서 호출된 getName의 this는 boa.__proto__\n        * \n    */\n\n    //---\n    \n    var iu = new Person('iu');\n    iu.getName(); // iu\n    \n    /*\n        iu.__proto__.getName \n        = iu(.__proto__).getName\n        = iu.getName\n    */\n\n\n    //---\n\n    var Constructor = function(name) {\n        this.name = name;\n        console.log(this);\n    }\n\n    Constructor.prototype.method = function(){};\n    Constructor.prototype.prototype1 = 'constructor Prototype property';\n\n    var instance = new Constructor('INSTANCE');\n    console.dir(Constructor);\n    console.dir(instance);\n    /*\n        Constructor.prototype === instance.__proto__\n    */\n\n\n    //--\n    var arr = [1,2];\n    console.dir(arr);\n    console.dir(Array);     //Array: 내장 생성자 함수\n\n    arr.forEach(function(){});  //\n    Array.isArray(arr);         //true\n    arr.isArray()               //TypeError: arr.isArray is not a function\n\n\n    ```\n\n# 1-2 constructor 프로퍼티\n\n```js\n    var arr = [1,2];\n    Array.prototype.constructor === Array;\n    arr.__proto__.constructor === Array;\n    arr.constructor === Array;\n\n    var arr2 = new arr.constructor(3,4);\n    console.log(arr2) //[3,4]\n```\n\n\n```js\nvar Person = function(name){\n    this.name = name;\n}\n\nvar p1 = new Person('인간1');                           //Person {name:\"인간1\"} true\nvar p1Proto = Object.getPrototypeOf(p1);\n\nvar p2 = new Person.prototype.constructor('인간2');     //Person {name:\"인간2\"} true\nvar p3 = new p1Proto.constructor('인간3');              //Person {name:\"인간3\"} true\nvar p4 = new p1.__proto__.constructor('인간4');         //Person {name:\"인간4\"} true\nvar p5 = new p1.constructor('인간5');                   //Person {name:\"인간5\"} true\n\n[p1, p2, p3, p4, p5].forEach(function(p){\n    console.log(p, p instanceof Person);\n})\n\n[constructor]\n[instance].__proto__.constructor\n[instance].constructor\nObject.getPrototypeOf([instance]).constructor\n[Contsructor].prototype.constructor\n\n[Constructor]\n[instance].__proto__\n[instance]\nObject.getPrototypeOf([instance])\n\n```\n\n# 2 프로토타입 체인\n\n# 2-1 메서드 오버라이드\n\n* 예제 \n    - 아래 메서드 오버라이드 전, 후 캡쳐 참고\n        ```js\n        var Person = function(name){\n            this.name = name;\n        }\n        Person.prototype.getName = function(){\n            return this.name;\n        }\n\n        var boa = new Person('보아');\n        boa.getName = function(){\n            return '이 사람은 ' + this.name;\n        };\n\n        console.log(boa);               // Person {name: \"보아\", getName: ƒ}\n        console.log(boa.getName());     // 이 사람은 보아\n\n        console.log(boa.__proto__.getNam());    // undefined\n        Person.prototype.name = '권보아';\n        console.log(boa.__proto__);             // {name: \"권보아\", getName: ƒ, constructor: ƒ}\n        console.log(boa.__proto__.getName());   // 이사람은 권보아\n        console.log(boa.__proto__.getName.call(boa));   // this를 명시적으로 선언\n        /*\n            메서드가 오버라이드된 경우에는 자신으로부터 가장 가까운 메서드에만 접근\n            그다음으로 가까운 __proto__의 메서드도 우회적인 방법을 통해서 접근 가능\n        */ \n        ```\n* 결과\n    - override 하기 전\n    ![](method_override.png)\n    \n                             \n    - override 후\n    \n    ![](method_override1.png)\n\n# 2-2 프로토타입 체인\n* Object의 내부 구조\n\n![](prototypeOfObject.png)\n\n* Array의 내부 구조\n![](prototypeOfArray.png)\n\n\n* Array 내부 도식화\n![](Array내부도식화.jpg)\n    - [1,2]는 Array.prototype, Object.prototype내부의 메서드를 자신의 것처럼 실행 할 수 있다. \n    - .\\_\\_proto__는 생략 가능하다\n    - 예시\n\n        ```js\n        var arr = [1,2];\n        arr(.__proto__).push(3);                            //3\n        arr(.__proto__)(.__proto__).hasOwnProperty(2);      //true\n        ```\n\n* 메서드 오버라이드와 프로토타입 체이닝\n\n```js\nvar arr = [1,2,3];\nArray.prototype.toString.call(arr);     //1,2,3\nObject.prototype.toString.call(arr);    //[object Array]\narr.toString();                         //1,2,3\n\narr.toString = function(){      //결과 아래 캡쳐 참고 \n    return this.join('_');\n};\narr.toString();                         //1_2_3\n```\n\n* arr 객체에 toString function 추가시 arr객체 내부\n\n    ![](Array객체에toString추가.png)\n\n\n# 2-3 객체 전용 메서드의 예외사항\n\n* Object.prototyp에 추가한 메서드의 접근\n    ```js\n    Object.prototype.getEntries = function(){\n        var res = [];\n        for (var prop in this){\n            if(this.hasOwnProperty(prop)){\n                res.push([prop, this[prop]]);\n            }\n        }\n        return res;\n    }\n\n    var data = [\n        ['object', {a: 1, b: 2, c:3}],\n        ['number', 345],\n        ['string', 'abc'], \n        ['boolean', false],\n        ['func', function(){}],\n        ['array', [1,2,3,4]]\n    ];\n\n    data.forEach(function(d){\n        console.log(d[1].getEntries());\n    })\n\n    ```\n    - 어떤 데이터 타입이건 거의 무조건 프로토타입 체이닝을 통해 getEntries 메서드에 접근 \n\n\n* 스태틱 메서드(객체한정메서드)\n    - 객체만을 대상으로 동작하는 객체 전용메서드들은 부득이 Object.prototype이 아닌 Object에 스태틱 메서드(static method)로 부여할 수 밖에 없다.\n    - 생성자 함수인 Object, 인스턴스 객체 리터럴 사이에는 this를 통한 연결이 불가능\n    - 전용 메서드 처럼 '메서드명 앞의 대상이 곧 this'가 되는 방식대신  \n    this의 사용을 포기하고 대상 **인스턴스를 인자로 직접 주입해야 하는 방식**으로 구현  \n    : 예시 Object.freeze({prop: 42})\n    - Object.prototype.consructor 하위 메서드 & Object.protptype 하위 메서드\n     ![](객체전용메서드&스태틱메서드.jpg)\n\n# 2-4 다중 프로토타입 체인\n* 새롭게 만드는 생성자 함수에 \\_\\_proto__를 연결해서 체인 관계를 만들수 있다.\n* Grade.prototype에 Array instance를 세팅으로 g1(Grade function의 instance)에서 push를 사용할 수 있게 된다.\n\n* Grade 생성자 함수와 인스턴스\n    ```js\n    var Grade = function(){\n        //arguments: 유사배열\n        var args = Array.prototype.slice.call(arguments);\n        for(var i=0; i<args.length; i++){\n            this[i] = args[i];\n        }\n        this.length = args.length;\n    }\n    var g = new Grade(100, 80);\n    g.push(1); //Uncaugh TypeError: g.push is not function\n\n    Grade.prototype = new Array();   //POINT\n    //Grade.prototype = [];   \n    //[].__proto__ === new Array().__proto__\n    //[] instanceof Array // true\n    \n    var g1 = new Grade(10, 20);\n    g1.push(1);\n    console.log(g1);    //Grade(3) [10, 20, 1]\n    g1.shift()\n    console.log(g1);    //Grade(3) [20, 1]\n\n    ```\n    - 도식화 \n    ![](Grade생성자함수에배열proto.jpg)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n","excerpt":"javascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자.  1 프로토타입의 개념 이해 1-…","fields":{"slug":"/prototype/"},"frontmatter":{"date":"Feb 08, 2020","title":"prototype","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다. \n\n\n```js\n\t1 클로저의 의미 및 원리 이해\n\t2 클로저와 메모리 관리\n\t3 클로저 활용사례\n\t\t3-1 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 \n\t\t3-2 접근 권한 제어(정보 은닉)\n\t\t3-3 부분 적용함수\n\t\t3-4 커링함수\n```\n\n\n# 1 클로저의 의미 및 원리 이해\n\n\n## 클로저란?  \n  : 함수형 프로그래밍 언어에서 등장하는 특징\n    > 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 **실행 컨텍스트가 종료된 이후에도 변수a가 사라지지 안는 현상**\n    > 내부함수를 외부로 전달하는 방법: 함수를 return하는 경우, callback으로 전달\n    - mdn 설명\n    > A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).  \n    > In other words, a closure gives you access to an outer function’s scope from an inner function. \n    > In JavaScript, closures are created every time a function is created, at function creation time.\n    \n\n## 외부 함수의 변수를 참조하는 내부 함수(1)\n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    outer();\n    ```\n    * inner함수 내부에서는 c를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 c를 찾는다. \n    * outer함수의 실행 컨텍스트가 종료되면 LexicalEnvironmentReference에 저장된 식별자들(c, inner)에 대한 참조를 지운다. \n        - 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 **컬렉터의 수집 대상**이된다.\n    * inner function안에서 closure 영역에 있는 변수는 'c' 하나 뿐이다. c1처럼 변수 선언만 하고 할당하지 않으면 메모리에 올라오지 않는다. \n\n## 외부 함수의 변수를 참조하는 내부 함수(2)  \nouter 함수의 실행컨텍스트가 종료된 후 inner 함수를 호출하면?\n\n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    var excuteInnerFunc = outer();\n    consl.log(excuteInnerFunc); // 2\n    consl.log(excuteInnerFunc); // 3\n    ```\n    * inner함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없습니다.\n    * outerEnvironmentReferenece에는 inner함수가 선언된 위치의 LexicalEnvironment가 참조복사\n    * inner함수는 outer함수 내부에서 선언됐으므로, outer함수의 Lexicalenvironment가 담김\n        - 위 단계로 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환\n        - inner함수의 실행 컨텍스트가 종료\n    * excuteInnerFunc를 두번째 호출하게 되면 위 단계를 걸쳐 2->3 으로 증가한다.\n\n    * ***주의할점***\n        > inner함수의 실행시점에는 outer함수는 이미 실생 종료된 상태인데 outer함수의 Lexicalenvironment에 어떻게 접근할 수 있는걸까? \n        - 가비지 컬렉터의 동작 방식때문\n        - 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.\n        - 언젠가 inner함수의 실행컨텍스트가 활성화 되면 outerEnvironmentReferenece가 outer함수의 Lexicalenvironment를 필요로 할 것이므로 수집 대상에서 제외\n            - 그래서 inner함수 c 변수에 접근 가능\n\n## return 없이도 클로저가 발생하는 다양한 경우\n    ```js\n    (function(){\n        var a = 0 ;\n        var intervalId = null;\n        var inner = function() {\n            if (++a>9) {\n                clearInterval(intervalId);\n            }\n            console.log(a);\n        };\n        intervalId = setInterval(inner, 1000);\n    })()\n\n    // clouser & eventListener\n    (function(){\n        var count = 0;\n        var button = document.createElement('button');\n        button.innerText = 'click';\n        button.addEventListener('click', function(){\n            console.log(++count, 'times clicked');\n        });\n        document.body.appendChild(button);\n    })()\n    ```\n    ![clouser&eventListener](clouser&eventListener.png)\n\n# 2 클로저와 메모리 관리\n* 객체지향, 함수형 모두를 아우르는 중요한 개념\n* 클로저는 메모리 소모가가 있지만 이런 특성을 정확히 이해하고 잘 활용하도록 노력해야한다.     \n\n* closure를 GC가 수거하게 하는 방법\n    - 3장 예시에 POINT 주석 3개 참고   \n    ```js\n        //1번째 예시\n        var outer = function() {\n            var c = 1;\n            var c1\n            var inner = function() {\n                console.log(++c);\n            }\n            inner();\n        };\n        outer();\n        outer = null;   // POINT: outer실별자의 inner 함수 참조를 끊음\n        \n\n        //2번째 예시\n        (function(){\n            var a = 0 ;\n            var intervalId = null;\n            var inner = function() {\n                if (++a>9) {\n                    clearInterval(intervalId);\n                    inner = null;             // POINT: inner식별자의 함수 참조를 끊음  \n                }\n                console.log(a);\n            };\n            intervalId = setInterval(inner, 1000);\n        })();    \n\n        \n        //3번째 예시\n        // clouser&eventListener\n        (function(){\n            var count = 0;\n            var button = document.createElement('button');\n            button.innerText = 'click';\n\n            var clickHandler = function(){\n                //console.log(++count, 'times clicked');\n                if( ++count > 9 ){\n                    clickHandler = null;  //POINT: clickHandler 식별자 함수 참조를 끊음\n                }\n            };\n\n            button.addEventListener('click', clickHandler);\n            document.body.appendChild(button);\n        })()\n    ```\n\n# 3 클로저 활용사례\n\n## 3-1 Event Listener(콜백 함수 내부에서 외부 데이터를 사용하고자 할 때)\n\n* event Listener callback function\n    ``` js\n        var colorList = ['red', 'blue', 'white'];\n        var $ul = document.createElement('ul');\n\n        colorList.forEach(function(color){                  //(A)\n            var $li = document.createElement('li');\n            $li.innerText = color;\n            $li.addEventListener('click', function(){       //(B)\n                alert('your choice: ', color);\n            });\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n    ```\n    * (B)는 color라는 **클로저**가 있다. \n    * (A)는 colorList만큼의 **'실행 컨텍스트가 활성화 됨'**\n    * (B) outerEnvironmentReferenece가 (A)의 LexicalEnvironment참조  \n       -> **(B)함수가 참조할 예정인 변수 color에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능**\n\n\n* event Listener callback function에 bind 사용\n```js\n    var $ul = document.createElement('ul');\n    var colorList = ['red', 'blue', 'white'];\n    var consoleColor = function(color){\n        if(this === window){\n            //POINT3, POINT2\n            console.log('### this is window -> ' + this + \"/// callback function param: \" + color);\n            console.log(this);      //<li>blue</li>\n            console.log(color);     //MouseEvent\n            console.log('--------------------')\n        } else {\n            //POINT1\n            console.log('### this is HTMLElement -> this Value:' + this + \"/// callback function param: \" + color);\n            console.log(this);      //window\n            console.log(color);     //blue\n            console.log('====================')\n        }   \n    }            \n    \n    colorList.forEach(function(fruit){\n        var $li = document.createElement('li');\n        $li.innerText = fruit;\n        $li.addEventListener('click', consoleColor);                        //POINT 1: eventListener의 this, 첫번째 파라미터는 각각 '클릭한 dom', 'MouseEvent' 객체들이다.\n        $li.addEventListener('click', consoleColor.bind(this, fruit));      //POINT 2: forEach의 callback function에서 this는 windown!/ fruit는 clousre! \n        $ul.appendChild($li);\n    });\n    document.body.appendChild($ul);\n    \n    consoleColor(colorList[2]);                                             //POINT 3\n```\n    ![](callbackEg_EventListener.png)\n    \n    * POINT1,2,3의 consoleColor function의 console 확인 필요 \n    * POINT1,2의 this, 첫번째 param을 다시 상기 시켜보자.\n    * POINT2의 제약사항  \n        **- 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라지는 점은 감안해야한다.**\n\n        \n* event Listener에 고차 함수 사용\n    - 함수형 프로그램밍에서 자주 쓰이는 방식\n\n    ```js\n        var $ul = document.createElement('ul');\n        var colorList = ['red', 'blue', 'white'];\n        var consoleColor = function(color){\n            return function(){\n                console.log(color)\n            }\n        }            \n        \n        colorList.forEach(function(fruit){\n            var $li = document.createElement('li');\n            $li.innerText = fruit;\n            $li.addEventListener('click', consoleColor(fruit));\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n        \n    ```\n\n## 3-2 접근 권한 제어(정보 은닉)\n\n```js\n    var outer = function(){\n        var a = 1;                  //closure\n        var inner = function(){\n            return ++a;\n        }\n        return inner;\n    }\n    var outer2 = outer();\n\n    console.log(outer2());\n    console.log(outer2());\n```\n\n* outer함수는 외부(전역 스코프)로부터 철저하게 격리\n* 외부에서는 외부 공간에 노출돼 있는 outer라는 변수를 통해 outer함수를 실행할 수 있지만  \n, outer함수 내부에는 어떠한 개입도 할 수 없다.\n* **외부에서는 오직 outer함수가 return한 정보에만 접근할 수 있다.** (== return 값이 외부에 정보를 제공하는 유일한 수단)\n\n## 3-3 부분 적용함수\n\n```js\nvar add = function(){\n    var result = 0;\n    for(var i = 0; i < arguments.length; i++){\n        result += arguments[i];\n    }\n    return result;\n};\nvar addPartial = add.bind(null, 1,2,3,4,5);\nconsole.log(addPartical());             //15\nconsole.log(addPartial(6,7,8,9,10));    //55\nconsole.log(addPartical(10));           //25\n\n```\n## 3-4 커링함수\n* 여러 인자를 받은 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성\n\n* curring function eg\n    ```js\n\n    var curryFuncTest = function (func){\n        debugger;\n        return function(a){\n            debugger;\n            return function(b){ // getMaxWith10, getMinWith10 funciton\n                debugger;\n                return func(a,b);\n            };\n        };\n    };\n\n\n    var getMaxWith10 = curryFuncTest(Math.max)(10);\n    console.log(getMaxWith10(8));\n    console.log(getMaxWith10(25));\n\n    var getMinWith10 = curryFuncTest(Math.min)(10);;\n    console.log(getMinWith10(8));\n    console.log(getMinWith10(25));\n\n    ```\n![curryfunciton](curryfunction.png)\n\n* curring function with arrow function\n\n    ```js\n        var curryFuncTestWithArrowFunc = func => a => b => func(a,b);\n        var getMaxWith10WithArrowFunc = curryFuncTestWithArrowFunc(Math.max)(10);\n        console.log(getMaxWith10WithArrowFunc(8));\n        console.log(getMaxWith10WithArrowFunc(25));\n    ```\n\n* curring function 실제 사용 예\n\n    ```js\n    var getInfomation = function(baseUrl){                      // 서버에 요청할 주소의 기본 URL\n        return function (path) {                                // path값\n            return function (id) {                              // id    \n                return fetch(baseUrl + path + '/' + id);        // 실제 서버에 정보 요청\n            };\n        };\n    };\n\n    var getInformation = baseUrl => path => id => fetch(baseUrl + path + '/' + id);\n    var imageUrl = 'http://imgAddr.com/';\n\n    // 이미지 타입별 요청 함수 준비\n    var getImage = getInformation(imageUrl);    //http://imgAddr.com/\n    var getEmoticon = getImage('emoicon');      //http://imgAddr.com/emoticon\n    var getIcon = getImage('icon');             //http://imgAddr.com/icon\n\n    //실제 요청\n    var emoticon1 = getEmoticon(100);       //http://imgAddr.com/emoticon/100\n    var emoticon2 = getEmoticon(200);       //http://imgAddr.com/emoticon/200\n    var icon1 = getIcon(10);                //http://imgAddr.com/icon/10\n    var icon2 = getIcon(20);                //http://imgAddr.com/icon/20\n\n    ```\n\n    * 이런 이유로 최근 여러 프레임워크, 라이브러리 등에서 커링을 상당히 광범위하게 사용하고 있다.\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다.…","fields":{"slug":"/closure/"},"frontmatter":{"date":"Feb 05, 2020","title":"closure","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n```\n# 목차\n    * call() 정의\n    * call()을 생성자 연결에 사용\n    * call()을 익명함수와 함께 쓰기 \n    * call()호출시 this에 특정 값을 넣어 동작하기\n    * call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n    * call, apply함수의 비교(this에 특정 값 넣어 동작)\n    * bind()\n    * bind()함수 구현 해보기\n    * creating a bound function\n    * Partially applied functions\n    * with setTimeout()\n```\n\n# call() 정의\n> 주어진 this 값, 전달된 인수 와 함께 함수를 호출\n\n```js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\n\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n```\n\n# call()을 생성자 연결에 사용\n> function, method에 속해서 다른 객체를 호출한다.  \n> function, method에 this 값을 전해준다.  \n함수는 한번 쓰고 다른 객체에서 상속 받아 사용한다.(method를 다시 만들 필요 없이)\n``` js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price < 0) {\n    throw RangeError('Cannot create product ' +\n                      this.name + ' with a negative price');\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'food';\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'toy';\n}\n\nvar cheese = new Food('feta', 5);\nvar fun = new Toy('robot', 40);\n```\n\n\n# call()을 익명함수와 함께 쓰기 \n```js\nvar animals = [\n  { species: 'Lion', name: 'King' },\n  { species: 'Whale', name: 'Fail' }\n];\n\nfor (var i = 0; i < animals.length; i++) {\n  (function(i) {\n    this.print = function() {\n      console.log('#' + i + ' ' + this.species\n                  + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n//## 결과 \n//#0 Lion: Kinf\n//#1 Whale: Fail\n```\n\n# call()호출시 this에 특정 값을 넣어 동작하기\n> \n\n```js\nfunction greet() {\n  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n  console.log(reply);\n}\n\nvar obj = {\n  animal: 'cats', sleepDuration: '12 and 16 hours'\n};\n\ngreet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n# call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n> call로 호출될 function 안에 this의 bound는 global object이다  \n> 하지만 use stric을 사용 하용하면 undefined가 나온다. \n```js\nvar sData = 'Wisen';\n            \nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call();  // sData value is Wisen \n\n``` \n\n```js            \n'use strict';\n\nvar sData = 'Wisen';\n\nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call(); // Cannot read the property of 'sData' of undefined            \n```\n\n# call, apply함수의 비교(this에 특정 값 넣어 동작)\n```js\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.call(obj,\"Korea\",\"Seoul\"));\t\n//welcome to Korea in Seoul Jaeyoon\n\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.apply(obj,[\"Korea\",\"Seoul\"]));\t\t\n//welcome to Korea in Seoul Jaeyoon\n```\n\n\n\n\n\n\n# bind()\n> 함수와 객체를 서로 묶는 것이다.  \n> bind()함수는 새 함수를 반환한다.(call, apply는 바로 동작`)\n```js\nfunction f(y) { return this.x + y }    //바인드되어야 하는 함수\nvar o = {x:1};      //바인드될 객체\nvar g = f.bind(o);  //g(x)를 호출하면 o.f(x)가 호출된다.\ng(2)                //=>3\n```\n\n# bind()함수 구현 해보기 \n```js\nFunction.prototype.bind = function(obj){\n  //this와 인자 값을 변수에 저장함으로써 다음의 중첩 함수에서 사용할 수 있다.\n  var me = this, boundArgs = arguments;\n\n  //bind() 메서드의 반환 값은 함수다.\n  return function(){\n  //인자 목록을 작성하는데, 첫 번재 이후의 인자부터\n  //나머지 모든 인자를 이 함수에 전달 한다.\n  var args = [], i;\n  for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);\n  for(i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  \n  //인자들을 포함하여 obj의 메서드로 me를 호출한다.\n  return me.apply(obj, args);\n}\n```\n\n# creating a bound function\n\n```js\nthis.x = 9;    // this refers to global \"window\" object here in the browser\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nmodule.getX(); // return: 81 - The ufnction gets invoked at the module scope\nretrieveX();   // returns 9 - The function gets invoked at the global scope\n\n// Create a new function with 'this' bound to module\n// New programmers might confuse the global var x with module's property x\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n# Partially applied functions\n\n```js\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\nvar result1 = addArguments(1, 2); // 3\n\n// Create a function with a preset leading argument\nvar leadingThirtysevenList = list.bind(null, 37);\nvar list2 = leadingThirtysevenList(); // [37]\nvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n// Create a function with a preset first argument.\nvar addThirtySeven = addArguments.bind(null, 37); \nvar result2 = addThirtySeven(5); // 37 + 5 = 42 \nvar result3 = addThirtySeven(5, 10);// 37 + 5 = 42 , second argument is ignored\n\n```\n\n\n\n# with setTimeout()\n\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  // #POINT\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with '+ this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  \n// after 1 second, triggers the 'declare' method\n```\n","excerpt":"call() 정의 주어진 this 값, 전달된 인수 와 함께 함수를 호출 call()을 생성자 연결에 사용 function, method에 속해서 다른 객체를 호출한다. function, method에 this…","fields":{"slug":"/call(), apply(), bind()/"},"frontmatter":{"date":"Feb 02, 2020","title":"call(), apply(), bind()","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로\n\n```js\n\t1 콜백함수란?\n\t2 제어권\n\t\t2-1 호출시점\n\t\t2-2 인자\n\t\t2-3 this\n\t3 콜백 함수는 함수다\n\t4 콜백 함수 내부의 this에 다른 값 바인딩하기\n\t5 콜백 지옥과 비동기 제어\n```\n\n\n\n# 1 콜백함수란?\n> 다른 코드의 인자로 넘겨주는 함수(제어권도 함께 위임)\n> 콜백함수를 넘겨 받는 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행\n\n\n# 2 제어권\n> 호출시점, 인자, this 예제를 통해서 알아 보자\n## 2-1 호출시점\n> setInterval에 callback function은 '호출주체, 제어권'은 setInterval이다.\n```js\nvar count = 0;\nvar cbFunc = function() {\n    conosl.log(count);\n    if(++count > 3) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n```\n## 2-2 인자\n> 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.\n\n* callback function의 인자 값은 filter에 의해서 정해졌다.\n    ```js\n    var newArr = [1,2,3,4,5].filter(function(idx, val){\n        console.log({'this sceop': this, idx, val});\n        return val > 2;\n    }, {a:1, b:2});     // {a:1, b:2}코드에 대한 설명은 아래 2-3 this설명에서 알 수 있다.\n\n    console.log(newArr);    //[4,5]\n\n    /*\n        this sceop: {a: 1, b: 2}\n        idx: 1\n        val: 0\n        \n        this sceop: {a: 1, b: 2}\n        idx: 2\n        val: 1\n        \n        this sceop: {a: 1, b: 2}\n        idx: 3\n        val: 2\n        \n        this sceop: {a: 1, b: 2}\n        idx: 4\n        val: 3\n        \n        this sceop: {a: 1, b: 2}\n        idx: 5\n        val: 4\n    */\n    ```\n\n## 2-3 this\n\n* Array.prototype.map - 구현    \n    ```js\n    Array.prototype.filter = function(callback, thisArg){\n        var mappedArr = [];\n        for(var i=0; i < this.length; i++){\n            var mappedValue = callback.call(thisArg || window, this[i], i , this);  //POINT\n        }\n    }\n    ```\n    * 주석 POINT 설명\n        * thisArg || window  \n            : callback function에서 this의 scope을 명시적으로 바인딩\n            : 이 코드에 의해 filter의 두번째 param으로 callback의 this를 정해줄 수 있다.\n            : 2-2인자 챕터 코드 참고하기\n        * this  \n            : filter를 호출 한 array(이 내용은 prototype과 관련해서 더 설명할 수 있겠다.)  \n        * this[i]  \n            : 이 코드에 의해서 callback function의 첫번째 param array의 i번째 요소\n        * i  \n            : 이 코드에 의해서 callback function의 두번째 param array의 i번째\n    \n# 3 콜백 함수는 함수다\n* 메서드를 콜백함수로 전달한 경우\n    ```js\n    var obj = {\n        vals: [1,2,3],\n        logValues: function(v, i){\n            console.log(this, v, i);\n        }\n    }\n    \n    obj.logValues(10,20); //{vals: Array(3), logValues: f} 10 20\n\n    [10,20,30].forEach(obj.logValues);\n    /*\n        Window{...} 10 0\n        Window{...} 20 1\n        Window{...} 30 2    \n    */\n    ```\n    * forEach의 callback function은 코드에 의해서 호출된 logValues에서 this는 Window를 가르키고 있다.\n        - callback function으로 obj 객체에 의해서 this가 결정되지 않고 별도로 this를 명시하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 가르친다.\n        \n# 4 콜백 함수 내부의 this에 다른 값 바인딩하기\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (1/3)\n    ```js\n    var obj1 = {\n        name: 'obj1',\n        func: function() {\n            var me = this;             //POINT\n            return function(){\n                console.log(me.name);\n            };\n        }\n    };\n    var callback = obj1.func();\n    setTimeout(callback, 1000);\n    ```\n    * var me = this;는 closure scope에 등록\n    * setTimeout에 의해서 callback function이 호출 될때 me.name은 excute context에서 me.name 변수를 찾는다.\n    ![callback & scope & clousre](callback&scope&closure.png)\n\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (2/3)\n    * 예제1에서 만들었던 함수 재활용하는 방법 - cb2 확인해보자\n    ```js\n        var obj1 = {\n            name: 'obj1',\n            func: function() {\n                var me = this;              //POINT: closure\n                return function(){\n                    console.log(me.name);\n                };\n            }\n        };\n\n        var obj2 = {\n            name: 'obj2',\n            func: obj1.func\n        };\n\n        var cb1 = obj1.func().bind('cb1');\n        setTimeout(cb1, 1000);\n\n        var cb2 = obj2.func().bind('cb2');\n        setTimeout(cb2, 1500);\n\n        var obj3 = { name: 'obj3' }\n        var cb3 = obj1.func.call(obj3);        //POINT: obj1.func = function(){ var me this; return function(p1){ console.log() }} \n        setTimeout(cb3, 2000);\n\n        /*\n            # 결과\n                * cb1: undefined \"obj1\" \"callback1\"\n                * cb2: undefined \"obj2\" \"callback2\"\n                * cb3: obj3 obj1 callback3\n        */\n    ```\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (3/3)\n    * bind로 this를 명시한 function을 사용\n        ```js\n        var obj1 = {\n                name: 'obj1',\n                func: function() {\n                    console.log(this.name)\n                }\n        };\n        \n        setTimeout(obj1.func.bind(obj1), 1000);\n\n        var obj2 = {name:'obj2'};\n        setTimeout(obj1.func.bind(obj2), 1500);\n\n        /*\n            # 결과\n                * obj1\n                * obj2\n        */\n        ```\n\n\n\n# 5 콜백 지옥과 비동기 제어\n> 콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상\n> 주로 이벤트 처리, 서버통신과 같은 비동기적인 작업을 수행하기 위해서 이런 형태가 등장\n\n* 동기적인 코드\n    - 현재 실행중인 코드가 완료된 후에야 다음 코드를 실행하는 방식\n* 비동기적인 코드\n    - 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다.\n    - CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드 \n* 비동기적인 코드가 필요한 경우   \n    : 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아졌다.\n    - 실행대기(setTimeout)  \n        : 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류\n    - 실행대기(addEventListener)  \n        : 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기\n    - 보류(XMLhttpRequest)  \n        : 웹브라우저 자체가 아닌 별도의 대상에 무어가를 요청하고 그에 대한 응답이 왔을때 비로소 어떤 함수를 실행하도록 대기\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로…","fields":{"slug":"/callback/"},"frontmatter":{"date":"Feb 02, 2020","title":"callback function","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n상황에 따라서 달라지는 this를 정리해보려고 한다. \n```js\n    0 javascripot에서 this\n    1 상황에 따라 달라지는 this\n        1-1 전역 공간에서의 this\n        1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n            함수 vs 메서드\n            메서드 내부에서의 this\n        1-3 함수로서 호출할 때 그 함수 내부에서의 this\n            함수 내부에서의 this\n            메서드의 내부함수에서의 this\n            메서드의 내부 함수에서의 this를 우회하는 방법\n            this를 바인딩하지 않는 함수\n        1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n        1-5 생성자 함수 내부에서의 this\n    2 명시적으로 this를 바인딩하는 방법\n        2-1 call 메서드\n        2-2 apply 메서드\n        2-3 call/apply 메서드의 활용\n            유사배열객체에 배열 메서드를 적용\n            생성자 내부에서 다른 생성자 호출\n            여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n        2-4 bind 메서드\n            name 프로퍼티\n            상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n        2-5 arrow function의 예외사항\n        2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n```\n\n# javascripot에서 this\n* 다른 객제지향 언어와 this의 차이점 \n    * 다른 대부분의 객체지향 언어의 this: 클래스로 생성한 인스턴스 객체\n        * 클래스에서만 사용할 수 있기 때문에 헷갈리지 않거나 많지 않음\n    * 자바스크립트 this: **어디에서나 쓸 수 있음**\n        * 상황에 따라 this가 바라보는 대상이 달라짐\n        * ***문제를 해결하려면 원인을 알아야 하는데, 정확한 작동방식을 이해하지 못하면 원인을 해결하기 어려움***\n\n* this 확인으로 '함수, 객체(메서드)'의 구분할 수 있는 거의 유일한 방법\n\n# 1 상황에 따라 달라지는 this\n> this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정(실행컨텍스트 설명할때 설명됨)  \n> 아래 상황별로 this가 5가지 다른 값을 보여주는 내용을 설명\n\n## 1-1 전역 공간에서의 this\n> 전역 공간에서 this는 전역객체를 가리킨다. \n\n* 전역 변수와 전역객체\n    ```js\n    var a = 1;\n    console.log(a);         //1\n    console.log(window.a);  //1\n    console.log(this.a);    //1\n    ```\n* 위 결과 값이 같은이유는? \n    * 전역변수 선언시 javascrip engine이 전역객체의 프로퍼티로 할당\n    * javascript 모든 변수는 특정 객체의 프로퍼티로 등록되고 동작\n        * 특정객체: 실행컨텍스트의 LexicalEnvironment\n        * 전역컨텍스트의 경우 LexicalEnvironment는 전역객체를 그대로 참조(실행컨텍스트 도식화 그림 참고\n* 전역 변수를 접근하는 과정은? -> scope chain\n    * a에 접근하고자 하면 스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 '전역 스코프'의 LexcialEnvironment(전역객체)에서 해당 프로퍼티를 a를 발견해서 그 값을 반환하기 때문\n\n\n---\n* 전역변수와 전역객체의 차이점\n    * 전역객체의 프로퍼티로 할당한 경우에서는 삭제 o\n    * 전역변수로 선언한 경우에는 삭제 x\n\n        ```js\n        var b = 2;\n        delete b;   //false\n        console.log(b, window.b, this.b) //2 2 2\n\n        window.c = 3;\n        delete window.c;    //true\n        console.log(c, window.c this.c); // Uncaught ReferenceError: c is not defined\n        \n        ```\n\n\n## 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n### 함수 vs 메서드\n* 함수 호출시 this: 전역객체 (아래 예제코드 POINT 주석 참고)\n* 메서드로 호출시 this: 호출한 메서드\n    ```js\n    // 함수로서 호출\n    var obj = {\n        bar: function() {\n            var x = (function(){\n                        return this\n                    })();\n            return x;\n        }\n    };\n\n    obj.bar() === window //true     //POINT\n\n\n\n    // 메서드로서 호출\n    var obj = {\n        bar: function() {\n            var x = (() => this)(); // 주의: use arrow funciton\n            return x;\n        }\n    };\n\n    obj.bar() === obj\t//true\n\n    ```\n\n## 1-3 함수로서 호출할 때 그 함수 내부에서의 this\n### 함수 내부에서의 this\n* this에는 호출한 주체 정보가 담기는데 어떤 함수를 함수로서 호출시 this 지정 안됨\n* 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.\n* **실행 컨텍스트가 지정되지 않은 경우 this는 전역 객체를 바라본다 -> 따라서 함수에서 this는 전역객체를 가리킨다.** \n\n### 메서드의 내부함수에서의 this\n* 실행순서1,2,3의 return value\n    - 실행순서1: {outer: f, outer2: f} === obj1\n    - 실행순서2: window{...}\n    - 실행순서3: {obj2Property: \"obj2Property\", innerMethod: ƒ}\n\n* POINT\n    - innerFunc에 console.log는 B, C에 의해서 호출이 되는데  \n    - B처럼 innerFunc이 함수로 호출될때는 this는 전역 변수를 가르킨다.\n    - C처럼 innerfunc이 메서도로 호출될때는 this는 호출한 대상을 가르킨다.\n        ```js\n        var obj1 = {\n            outer: function() {\n                console.log(this);  //실행순서 1 by A\n                var innerFunc = function(){\n                    console.log(this);  //실행순서 2 by B, 3 by C\n                }\n                innerFunc(); // B\n\n                var obj2 = {\n                    innerMethod: innerFunc,\n                    obj2Property: 'obj2Property' \n                };\n                obj2.innerMethod(); // C\n            },\n\n            outer2: function(){\n\n            }\n        };\n\n        obj1.outer(); // A\n        ```\n\n### 메서드의 내부 함수에서의 this를 우회하는 방법\n### this를 바인딩하지 않는 함수\n> 아래 예제 주석 참고\n* log 결과값\n    * [1]: {outer: f}\n    * [2]: window {...}\n    * [3]: {outer: f}\n    * [4]: window {...}\n    * [5]: {outer: f}\n\n    ```js\n    var obj1 = {\n        outer: function() {\n            console.log(this);  // [1]\n            var innerFunc = function(){\n                console.log(this); // [2]\n            }\n            innerFunc(); \n\n            var me = this;\n            var innerFunc2 = function(){\n                console.log(me);    // [3] POINT 메서드의 내부 함수에서의 this를 우회하는 방법\n                console.log(this);  // [4]\n            }\n            innerFunc2(); \n\n            var innerFunc3 = () => {\n                console.log(this);  // [5] POINT: this를 바인딩하지 않는 함수\n            }\n            innerFunc3();\n\n        }\n    };\n\n    obj1.outer(); \n    ```\n\n\n\n## 1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n> callback function의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정  \n> **특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.**  \n> 콜백 함수에 bind를 사용하여 [2-4 bind](https://happyjy.github.io/this/#상위-컨텍스트의-this를-내부함수나-콜백함수에-전달하기)\n\n\n    ```js\n    setTimeout(function(){\n        console.log(this);      //window 객체 \n    }, 3000);\n\n    [1,2,3].forEach(function(v){\n        console.log(this, v);   //window 객체 \n    })\n\n    //event Callback function 참고\n    document.body.innerHTML += `<button id=\"a\"> 클릭 </button>`\n    document.body.querySelector('#a').addEventListener('click', function(e){\n        console.log(this, e);\n    })\n\n    ```\n    * \"button click event Callback function this\"과 \"id='a' dom\" 객체 비교 => **같다.**\n\n    ![](eventCallbackfunction.png)\n\n\n\n* addEventListner function 내부 구현 추측 \n    - addEventListner function this가 'document.body.querySelector('#a')' 이기 때문에  \n    이 값을 callback function을 call메서드를 이용해 명시적으로 this바인딩 할 수 있겠다.\n\n        ```js\n            addEventListener: function(a, callbackFunc){\n                ...\n                callbackFunc.call(this, event);\n                ...\n            }\n        ```\n\n## 1-5 생성자 함수 내부에서의 this\n> 생성자 함수에서 this는 생성될 인스턴스를 참조\n\n```js\nvar Dog = function(name, age) {\n    this.bark = 'RRRR';\n    this.name = name;\n    this.age = age;\n};\n\nvar hs = new Dog('행성', 2);\nvar girl = new Dog('소녀', 3);\nvar universe = new Dog('우주', 1);\n\nconsole.log(hs, girl, universe);\n/*\n    hs: Dog {bark: \"RRRR\", name: \"행성\", age: 2}\n    girl: Dog {bark: \"RRRR\", name: \"소녀\", age: 3}\n    universe: Dog {bark: \"RRRR\", name: \"우주\", age: 1}\n*/\n\nconsole.log({bark: hs.bark, name: hs.name, age:hs.age})\n/*    \n    {bark: \"RRRR\", name: \"행성\", age: 2}\n*/\n\n```\n\n* 위 두 console.log를 확인했을때 Dog에의해서 생성된 instance가 this가 된것을확인 할 수 있다.\n\n# 2 명시적으로 this를 바인딩하는 방법\n> 2 이 목차는 call(), apply(), bind()에 대해서 자세하게 다루도록 위해서 다른 포스트에서 설명하도록한다.\n[call(), apply(), bind()](https://happyjy.github.io/call(),%20apply(),%20bind())\n\n\n## 2-1 call 메서드\n## 2-2 apply 메서드\n## 2-3 call/apply 메서드의 활용\n### 유사배열객체에 배열 메서드를 적용\n### 생성자 내부에서 다른 생성자 호출\n### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n## 2-4 bind 메서드\n### name 프로퍼티\n### 상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\n```js\nvar obj ={\n    outer: function(){\n        console.log(this);               //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);           //{outer: ƒ, outer2: ƒ}\n        }\n        innerFunc.call(this);       //POINT\n    },\n\n    outer2: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          //{outer: ƒ, outer2: ƒ}\n        }.bind(this);               //POINT\n        innerFunc();\n    },\n\n    outer3: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          // window{...}\n        }                            //POINT\n        innerFunc();\n    }\n}\n\nobj.outer();\nobj.outer2();\nobj.outer3();\n\n```\n\n## 2-5 arrow function의 예외사항\n* [this를 바인딩하지 않는 함수 목차 참고](https://happyjy.github.io/this/#this를-바인딩하지-않는-함수)\n\n\n\n## 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n``` js\n    var report = {\n        sum: 0,\n        count: 0,\n        add: function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.forEach(function(arg, idx){\n                debugger;   //idx가 0일때 this -> {sum: 0, count: 0, add: ƒ, average: ƒ}    :report 객체\n                this.sum += arg;\n                ++this.count;\n            }, this);       //POINT\n        },\n        average: function(){\n            return this.sum / this.count;\n        }\n    }\n\n    report.add( 10, 20, 30 );\n    console.log({sum: report.sum, count: report.count, average: report.average()});\n    //{sum: 60, count: 3, average: 20}\n```\n* 만약 위 코드에서 POINT 부분 forEach function에 두번째 parameter \"thisArg\"가 없었다면\nthis.sum += entry;에서 this는 window객체를 가르키기 때문에 console.log 결과는 아래와 같다.\n>{sum: 0, count: 0, average: NaN}\n\n* 콜백함수와 함께 thisArg를 인자로 받는 메서드  \n```js\n    Array.prototype.forEach(callback[, thisArg]);\n    Array.prototype.map(callback[, thisArg]);\n    Array.prototype.filter(callback[, thisArg]);\n    Array.prototype.some(callback[, thisArg]);\n    Array.prototype.every(callback[, thisArg]);\n    Array.prototype.find(callback[, thisArg]);\n    Array.prototype.findIndex(callback[, thisArg]);\n    Array.prototype.flatMap(callback[, thisArg]);\n    Array.prototype.from(callback[, thisArg]);\n    Set.prototype.forEach(callback[, thisArg]);\n    Map.prototype.forEach(callback[, thisArg]);\n```\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"상황에 따라서 달라지는 this를 정리해보려고 한다.  javascripot에서 this 다른 객제지향 언어와 this의 차이점  다른 대부분의 객체지향 언어의 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Feb 01, 2020","title":"this","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["javascript"]}}},{"node":{"rawMarkdownBody":"\n개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다.\n\n\n```js\n\t1 실행 컨텍스트란? \n\t2 VariableEnvironment\n\t3 LexicalEnvironment\n\t\t3-1 environmentRecord와 hoisting\n            호이스팅 규칙  \n            함수 선언문과 함수 표현식\n      \n\t\t3-2 scope, scope chain, outerEnvironmentReference\n            스코프 체인\n            전역변수와 지역변수\n\n\t4 this\n```\n\n\n# 1 실행 컨텍스트란? \n> * 실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> * 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념  \n> * 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(=호이스팅), 외부환경정보를 구성, this값을 설정  하는 동작 수행    \n-> 이로인해 다른언어에서는 발견할 수 없는 특이한 현상들이 발생\n\n* 코드 실행시 실행 컨텍스트\n    - '동일한 환경'에 있느 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 \n    - 이를 콜 스택에 쌓아올렸다가\n    - 가장 위에 쌓여있는 컨텍스트와 관련 잇는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장\n\n* '동일한 환경'(하나의 실행 컨텍스트)을 구성할 수 있는 방법\n    - 전역공간, evan()함수, 함수 등이 있음\n    - eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것\n\n* javascript engine 역할\n  - 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 '필요한 환경정보들'을 수집해서 실행 컨텍스트 객체에 저장\n  - 이 객체는 javascript engine이 활용할 목적으로 생성(개발자가 코드를 통해 확인할 수 x)  \n  - 담기는 정보 세가지  \n    : 목차 2, 3, 4에서 각각 더 자세하게 설명하도록 한다. \n  ```txt\n    VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. \n                            : 선언 시점의 LexicalEnvironment의 스냅샷 \n                            : 변경 사항은 반영되지 않음\n    LexicalEnvironment  : 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영\n    ThisBinding         : this 식별자가 바라봐야 할 객체\n  ```\n\n* 활성화된 실행 컨텍스트의 수집정보\n\n``` \n  * inner \n      Variableenvironment : environmentRecord(snapshot)/ outerEnvironmentReferenece(snapshot)\n      LexicalEnvironment  : environmentRecord/ outerenvironmentReferenece\n      ThisBindding\n  * outer\n  * 전역 컨텍스트\n```\n  \n# 2 VariableEnvironment\n* LexicalEnvironment와 같지만 최초 실행 시의 스탭 샷을 유지한다는점이 다름\n* 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음,  \n  이를 그대로 복사해서 Lexical environment를 만들어  LexicalEnvironment를 주로 활용하게 된다.\n* Variableenvironment, LexicalEnvironment의 내부는 **environmentRecord와 outerEnvironmentReference**로 구성\n  - 초기화 과정 중에는 사실상 완전히 동일, 이후 코드 진행에 따라 서로 달라짐\n  - 자세한 내용은 LexicalEnvironment를 통해 설명\n\n# 3 LexicalEnvironment\n* 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것 \n\n## 3-1 environmentRecord와 hoisting\n* js engine은 컨텍스트 내부 전체를 처음부터 쭉 훑어나가며 순서대로 수집 = \"호이스팅 개념\"  \n(= 식별자들을 최상단으로 끌어올려놓은 다음 실제코드를 실행-실제로 끌어 올리는 것이 아님, 편의상 끌어올린것으로 간주-)\n  - 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태\n  - 코드가 실행되기 전임에도 불구하고 js engine은 이미 해당 환경에 속한 코드의 변수명들으 모두 알고 있게 된다.\n                                                                \n### 호이스팅 규칙\n* environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다\n* 예시\n  * 함수 선언문으로 선언한 함수는 hoisting 대상\n  * 함수 표현식은 hosisting 대상 x\n\n  ```js\n  function a(){\n      console.log(b);   //ƒ b() {}\n      var b; \n      console.log(b);   //ƒ b() {}\n      function b() {};  //함수 선언문\n      console.log(b);   //ƒ b() {}\n\n      console.log(c);   //undefined\n      var c = function() {}\n  }\n  ```\n\n\n\n### 함수 선언문과 함수 표현식\n* 함수를 정의하는 세가지 방식\n  * 함수 선언문: 반드시 함수명이 정의 돼 있어야 함/ hoisiting이 됨\n  * 함수 표현식: 함수명이 없어도 됨           / hoisiting이 안 됨\n  * 기명 함수 표현식: 함수명을 정의한 함수 표현식\n\n```js\nfunction a() {} //함수 선언문\na();\n\n//상대적으로 긴 코드 속에서 함수 표현식이 안전한다.\nvar b = function() {} //(익명) 함수 표현식\nb();\n\nvar c = function d() {} // 기명 함수 표현식. 변수명: c, 함수명 d\nc(); // 실행\nd(); // error\n\n```\n\n## 3-2 scope, scope chain, outerEnvironmentReference\n* scope: 식별자에 대한 유표범위\n  * ES5까지의 자바스크립트는 특이하게도 전역 공간을 제외하면 오직 함수에 의해서만 스코프가 생성\n* scope chain: 이런 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것\n* outerEnvironmentReference: 스코프체인을 가능하게 하는 것이 바로 Lexicalenvironment의 두번째 수집자료인 outerEnvironmentReferenece\n\n### scope chain\n* outerEnvironmentReferenece는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조\n  - 아래 예시1 scopechain 도식화 참고\n* 과거 시점인 '선언될 당시'는 행위가 실제로 일어 날 수 있는 시점이란?  \n  - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐\n  - 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문\n\n* scope chain 예1\n  1. A함수 내부에 B함수 선언, B함수 내에 C함수 선언\n  2. 함수 C의 outerEnvironmentReferenece는 함수 B의 LexicalEnvironment를 참조 \n  3. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReferenece는 ***다시 함수 B가 선언되던 때*** A함수의 LexicalEnvironment를 참조 \n  4. 이처럼 outerEnvironmentReferenece는 연결리스트 형태를 띤다.\n  5. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것'  \n\n* 위 예시로본 특징 \n  - 예시 3번에서 본것 처럼 각 outerEnvironmentReferenece는 오직 자신이 선언된 시점의 LexicalEnvironment만 침조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능\n  - 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능** \n\n* scope chain 예1 코드\n```js\n/*01*/ var a = 1;\n/*02*/ var outer = function () {\n/*03*/   var inner = function () {\n/*04*/     console.log(a);\n/*05*/     var a = 3;\n/*06*/  };\n/*07*/   inner();\n/*08*/   console.log(a);\n/*09*/ };\n/*10*/ ouer();\n/*11*/ console.log(a);\n```\n* scope chaing 예1 코드 도식화\n    * 그림을 보면서 라인별로 어떤 동작을 하는지 생각해보자\n    ```\n      LE: Lexical Envinronment\n      e: environmentRecord\n      o: outerEnvironmentReference\n    ```\n    ![](context.jpeg)\n\n\n* **전역 컨텍스트 활성화**\n  * 0: LexicalEnvironment, VariableEnvironment, thisBinding\n\n* 전역 컨텍스트 생성/ outer 함수 호출\n  * 1,2: a에 1, outer에 함수 할당\n  * 10: outer 함수호출, 전역 컨텍스트 비활성화\n  * 2: outer실행 컨텍스트 활성화\n\n* outer 컨텍스트 생성/ inner 함수 호출\n  * 3: inner에 함수 할당\n  * 7: inner 함수 호출, outer 실행 컨텍스트 비활성화\n  * 3: inner 실행 컨텍스트 활성화 \n\n* inner 함수 수행\n  * 4: inner의 LE에서 a 탐색 -> undefined 출력\n  * 5: a에 3할당\n\n* inner 컨텍스트 종료 \n  * 6: inner 함수 종료, inner 실행 컨텍스트 제거\n  * 7: outer 실행 컨텍스트 재활성화\n  * 8: outer의 LE에서 a탐색 -> GLOBAL의 LE에서 a 탐색 -> 1출력\n\n* outer 컨텍스트 종료 \n  * 9: outer함수 종료, outer 실행 컨텍스트 제거 \n  * 10: 전역 컨텍스트 재활성화 \n  * 11: GLOBAL의 LE에서 a탐색 -> 1출력\n\n\n* outer컨텍스트 \n\n```js\n\"전역 컨텍스트\": {\n    environmentRecord: 'a, outer function',\n    outerEnvironmentReferenece: null,\n    this: window\n}\n\n\"outer컨텍스트\": {\n    environmentRecord: ['inner function'], \n    outerEnvironmentReferenece: 'GLOBAL LexicalEnvironment',\n    this: window\n}\n\n\"inner컨텍스트\": {\n    environmentRecord: ['a'], \n    outerEnvironmentReferenece: 'outer 컨텍스트',\n    this: window\n}\n```\n\n### 전역변수와 지역변수\n* 전역변수: 전역 공간에서 선언\n* 지역변수: 함수 내부에서 선언\n\n# 4 this\n* 실행컨텍스트의 thisBinding에 this로 지정된 객체가 저장\n* 실행컨텍스 활성 당시 this가 지정되지 않은경우 \"전역객체\" 저장\n* 함수 호출하는 방법에 따라 this가 달라진다.(this에 대해서만 내용을 다룰 예정)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n* 제로초 블로그\n","excerpt":"개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다. 1 실행 컨텍스트란? 실행컨텍스트(execution context…","fields":{"slug":"/Excute-context/"},"frontmatter":{"date":"Jan 24, 2020","title":"실행 컨텍스트","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6"]}}},{"node":{"rawMarkdownBody":"\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말할 수 있는 아니었다.\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있어 연예인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴져 멋있었고 떠먹기만 하면 되는 상황에서 감사한 마음이 들었다. 그래서 한편으론 실제로 적용하는 생각 연습과 다른 사람에게 효과적으로 전달 할 수 있는 고민을 하고 싶었다. (그래서 블로그에 자바스크립트 내용을 정리하는 연습을 해보려고 한다. -현재(2020.01 시작) 진행 중-) 그리고 책을 보면서 업무를 하며 익혔던 자바스크립트 내용을 상기하는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\njavascript를 더 깊게 알고 싶은 분에게 추천해주고 싶은 책이다.\n\n\n","excerpt":"이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트후기/"},"frontmatter":{"date":"Jan 20, 2020","title":"코어자바스크립트 후기","tags":["javascript","독서후기"]}}},{"node":{"rawMarkdownBody":"\n우연한 계기로 이 책을 읽고 신영준, 고영성 작가를 알게 돼서 `꾸준하게` 공부해서 `실력`을 높여야 한다는 것을 깨닫고 2018년 여름 패스트 캠퍼스를 다니기 시작한 여름부터 지금 작성하는 2020년 2월까지 약 1년 8개월 동안 Javascript 개념 정리, 토이프로젝트로 Instagram clone coding, 알고리즘 공부, 코드 스피츠 자바스크립트로 배우는 객체지향, 그리고 이를 이용하는 다양한 디자인 패턴 등 꾸준하게 업그레이드 할 수 있는 계기가 될 수 있었다.\n\n개발 공부를 `교양`으로 생각하고 취미 활동이라고 여기고 있다. 이전에 공부해야 하는데 라고 생각만 했을 때는 공부는 하지 않고 해야 한다고 스트레스만 받고 취미인 운동하러 가기 바빴다. 하지만 지금은 업무 수행하면서 궁금한 것을 기록했다 이후에 찾아서 정리하고, 토이프로젝트도 해보고, 커뮤니티도 참가해보고, 어떻게 하면 좀 더 능동적이고 성장하는 개발자가 되기 위해서 고민하고 있다.\n\n이렇게 터닝포인트가 된 책이기에 아래와 같이 정리하는 계기가 됐다.\n\n\n   \n# 1 믿음 : 공부는 믿는대로 된다.\n## a 자신을 믿지 않을때 잃어버린 믿음 세가지\n* 기대(Expectation)\n* 마인드셋(mindset)\n    1. 자신을 바라보는 사고방식    \n    2. 과제를 수행할 수 있다는 자기 능력에 관한 믿음\n\n## b 믿음, 기대를 되찾는 방법\n* 성공경험\n    - 기대수준을 낮춰 작은 성공에 도전\n* 강점주목\n    - 성적F에 집착 하지 않고 A의 강점을 마음에 품을 때 미래를 낙관적으로 바라 볼 수 있다.\n    - 기대는 강점을 먹고자란다.\n* 의미와 가치부여\n    - 니체는 살아야 할 이유를 아는 사람은 거의 어떠한 상태에서도 겨딜 수 있다.\n* 성장형 사고방식\n    - 실패를 해석하는 관점\n    - 성장형 사고방식을 하는 방법 6가지 항목\n        * 자기관점\n            - 지능과 성격은 변한다고 믿는다.\n        * 도전\n            - 자신을 성장시키는 초석\n            - 도전으로 많은 정보를 얻는다.\n        * 실패\n            - 더 많은 것을 배우고 성장한다.\n        * 노력\n            - 성장은 무조건 따라 오는 것\n        * 비판\n            - 비판으로 성장하고 개선된다고 믿는다.\n        * 다른사람의성공\n            - 다른 사람의 성공을 보며 배울 점을 찾으려고 노력\n\n## c 성장형 사고방식을 형성하는 방법 \n* 뇌의 가소성을 믿는다(뇌는 성장한다는 믿음을 갖는것)\n* 실패에 대한 개념을 바꾸는 것(실패 = 성장을 위한 발판)\n\n## d 자기효능감 \u000b: 어떤 것을 달성할 때 필요한 행동을 조직화하고 시행하는 개인의 능력에 관한 믿음\n* 자기효능감 높이는 방법\n    - 권위 있는 사람이 자신의 잠재력을 믿어 줄 때 자신도 그 잠재력을 믿는다는 것(\"김영훈 상무님\")\n    - 자기 잠재력을 인정해 줄 사람이 없다며 슬퍼하지 말자.\u000b결국, 믿는 주체는 다른 사람이아니라 자기 자신이다.\u000b이책으로 당신의 잠재력이 어마어마하다는 것을 과학적인 근거를 갖고 계속 말 해 줄 것이다.\n    - Eg\u000b고등학교 중퇴한 토드/ 아버지가 공부를 더 하라고/ 부모님은 토드를 믿었다./ 학교생활은 지옥, but 토드가 버틸 수 있었던 것은 부모님의 사랑과 믿음 때문/ 신뢰에 힘 얻어 무엇이든 더 잘할 수 있다는 믿음도 생김/ 더 높은 학위까지 성취\n\n## e 왜공부해야하는가 ?  - 신영준 박사 통찰\n* 소통\n    - 핵심: 서로의 존재를 인정해 주는 것\n    - 존재 = 뇌 = 사고(생각) = 정체성\n    - 존재를 인정해주는 것 = 정체성을 인정해주는 것 \n    - 생각을 온전하게 표현하고 이해하여 제대로 된 소통을 하는 데 가장 밑 받침이 되는 행동이 바로 공부\n* 생존\n    - 멱법칙\n\n* 즐거움\n* 나눔\n\n## f 고영성 작가 심화\n* 공부를 열심히 하면 -> 머리가 좋아진다. 죽을때까지\n* 내 뇌를 믿으며 제대로 된 방법으로 노력해야한다.\n        \n          \n     \n# 2. 메타인지 : 나를 모르면 공부도 없다.\n\n## a 자신이 무엇을 알고 무엇을 모르는지를 알기 때문에 자신의 장점을 극대화하고 자신의 단점을 최소화할 학습 전략(공부법)을 창조할 수 있다.\n\n## b 0.1% 아이들은 하루에 3시간은 개인 공부 시간을 갖는다.\n\n## c 메타인지 종류\n* 메타기억 : <기억> 장에서 다룸\n* 메타이해 : 자신이 언어를 잘 이해하는지를 아는 능력\u000b: 내용을 이해했지만 답변을 못하면 메타이해가 떨어진다고 볼 수 있다.\n    - 메타이해에 관한 질문들 7\n        * 내용을 제대로 이해하지 못했거나 주의를 기울여 읽지 않았음을 알았을 때 그부분을 다시 세심하게 읽는가? \n        * 짧은 단락을 읽고 자신의 말로 요약해 보는가 ? \n        * 책을 읽을 때 요약 정리된 부분이나 연습문제를 꼭 푸는가 ? \n        * 책에 나온 아이디어를 서로 연계시켜 보려고 노력하는가 ? \n        * 자신이 모르는 용어가 나왔을 때 사전이나 검색을 통해 용어를 완전히 이해하려고 노력하는가 ? \n        * 시험 공부를 할 때 자신이 어렵다고 여기는 부분에 더 많은 시간을 할애하는가 ? \n        * 읽은 자료들의 필요성에 대해 평가하고 적절히 분류해서 정리하는가? \n\n## d <메타인지를 높일 수 있는 방법 3>\n* 학습 전략을 배움\n* 자신의 실제 실력을 객관적으로 파악하는 피드백을 경험\n    - 연습문제, 내용요약, 가르쳐보기 -> 무엇을 할고 모르는지 제대로 확인 가능\n* 인간의 인지과정을 알면 메타인지 상승\n    - 나의 인지 과정에 대한 인지 능력(= 우리가 세상을 어떻게 인지하는지를 안다면 메타인지는 향상된다.)\n\n## e <Thinking, Fast and Slow>\n* Thinking Fast \n    - 오래 생각하지 않는 행위\n    - 자동적, 즉각적 노력과 수고가 거의. 들지 x\n* Thinking Slow\n    - 집중 요구(=수고, 노력이 든다)\n* Eg\n    - 시험 범위의 내용을 두세 번 반복해서 읽고 그 내용을 다 이해한 것 처럼 느끼는 시스템1(= fast thinking)의 한계를 알고 시스템2(=fast thinking)연습문제, 가르침을 통해 한꼐를 극복\n\n## f <인지의 한계 9>\n* 메타인지 능력을 향상하기 위해 알아야할 9가지\n* 기억력 착각\n        \n* 소박한 실재론\n    - 자신이 세상을 제대로 보고 있다고 순진하게 믿는것\n* 사후해석 편향\n        \n* 계획 오류\n    - 실향력에 대한 과대평가\n* 정서 예측 오류\n    - 자신의 미래 감정을 잘 못 예측하는 것\n* 평균 이상 효과\n    - 자신의 공부에 대한 노력이나 일을 평균 이상한다고 여긴다.\n* 확증 편향\n    - 자신이 처음 생각했던 주자엥 지지하는 근거만을 찾는 경향\n* 가용성 편향\n    - 내 기여도를 과장하는 것\n    - 가용성 평향에 파묻히면 좋은 팀워크는 지속할 수 없다.\n* 권위자 평향\n    - 권위자의 말이라면 제 생각도 기꺼이 바꾸는 것\n\n## g 신영준 작가의 통찰\n* 연습문제와 씨름 하면서 내 학습 수준을 확인하고 부족하면 다시 더 공부해서 그 내용을 온전하게 소화해 내는 것이 올바를 학습방법\n* 지식의 저주\n    - 상대방이 무엇을 알 고 있으며 어떤 상태이고 어떤 사람인지에 과한 것\n    - 메타 인지가 나에 관한 지식과 관련됐다면 지식의 저주는 타인에 관한 지식과 관련이 있다.\n    - 책: 누구나 처음엔 걷지도 못했다. (지식의 저주 관한 이야기)\u000b\n\n# 3. 기억 : 기억력은 타고나는 것이 아니다.\n\n## a 기억이란 무엇인가 ? \n* 기억이란 ? \n    - 중용한 것은 기술이고, 기억이 작동하는 법을 이해하는 것\n* 공부를 잘하기 위해서 우리가 알아야 할 첫 시작\n    - 집중력!(주의)\n* 주의&전두엽\n    - 전두엽 : 뇌에서 의사결정을 담당하는 CEO역할\n    - 20대 중 후반까지 성장\n    - 전두엽 발달이 미비-> 제대로 된 주의력을 발휘할 수가 없다.\n\n## b 주의에 대한 이해와 멀티태스크의 허구\n* 주의력을 키우는 가장 좋은 방법\n    - 공부를 많이한다.\n    - 공부를 계속하다 보니 주의력, 집중력이 좋아 졌다.\n* 멀티태스크\n    - 한번에 여러가지일 -> 거짓말\n    - 음악 : 가사가 있는 음악(X), 연주곡 (ok)\n\n## c 단기기억은 기억 저장소 인가 ? \n* 정신속에 상호 관련된 정보들을 동시에 유지하면서 '작업(working)' 하고 그것을 적절히 사용하도록 한다\n* 단기기억 = 작업기억\n\n## d 4가지 작업대\n> 음운회로(phonological loop)\u000b  \n> 시공간 메모장(visual-spatial sketchpad)\u000b  \n> 일화완충기(episodic buffer)\u000b  \n> 중앙집행기(central executive)\n\n* 음운회로\n    - 단어를 읽을 때 속으로 이 단어를 소리 내었음을 알 수 있는 것(=하위발성-subvocalization)\n    - 짦은 시간 동안 제한된 수 안에서 활성화\n* 시공간 메모장\n    - 시각과, 공간정보를 처리\n* 일화완충기\n    - 이전 경험들을 해석하고 새로운 문제를 해결하며 미래 활동을 계횓하도록 능동적으로 조작하는곳\n    - 임시 저장 체계, but 여기서 생성된 개념이나 복잡한 심상은 장기기억속에 저장\n* 중앙집행기\n    - 공부 방법 선택, 수학문제를 어떻게 공략할 것인지\n* 법칙\n    - 숫자 암기 => 음운회로\n    - 공간 추리관제 => 시공간 메모장\n    - 독서는 음운회로와 연관\n    - 중앙집행기 언어능력, 읽기이해, 추론능력, 노트 필기 기술 등 공부 전반에 걸쳐 밀접한 관계\n    - 주의력결핍 과잉 행동장애(ADHD)중앙집행기 과제를 잘 수행하지 못한다.\n    - 시공간메모장을 음운회로로 치환하지 않도록 노력한다.\n    - 위대한 과학자, 예술가들은 심상을 통해 대상을 이해하는 겨우가 매우 많았다.\n    - 오히려 말로 설명 하기 힘든것들이 많다.\n\n## e 장기기억이란 무엇인가?\n* 작성대기\n\n## f 강의듣기와 반복 읽기의 허상\n* 1퍼센트의 학생들은 개인 공부 시간을 확보(최소 3시간)\n* 뇌는 해야 할 일을 안하고 있기 때문\n* 강의는 열심히 공부한 것이 아니다.\n* 반복읽기 & 암기\n    - 좋지 않음 \n    - 왜할까 ? \n    - 가장 쉽고 간편\n    - 복습할때 연습문제, 요약/구술 귀찮으니까.\n    - 소화했다는 착각\n\n## g 기억전략 1-5\n* 기억전략1 : 시험 효과\n    - 연습문제 -> 장기기억 상승, 메타인지 상승\n    - 인출이 중요하다!(장기기억으로 가는 최선의 길)\n* 기억전략2 : 인출효과\n    - 시험, 암송, 요약, 토록, 발표, 관련된 글을 쓰는 것\n    - 잊지 말자. 어렵게 공부하면 잊기 어렵다.\n    - 아는 내용이라 할지라도 인출 경험이 없는 질문이 나오면 유창하게 대답을 하지 못한다.\n    - 김영훈이사님이 daily 계획 엑셀을 만들면서 연습하지않았나 생각\n* 기억전략3 : 분산 연습 효과\n    - 연속으로 연습 -> 단기기억이 주로 일을 하게 되면서 내용을 완전히 숙지 한듯 보이지만 실제로 장기기억으로 많이 가지 않게 된다.\n    - 간격을 두고 학습하게 되면 두번째 학습할 때 약간의 어려움을 겪게 된다.\n    - 뇌를 더 적극적으로 활용하면 장기기억으로 갈 활률이 올라간다.\n    - 전문가들은 보통 하루 정도의 간격을 두고 공부할 때 매우 효과적\n* 기억전략4 : 교차효과\n    - 교차로 수학 문제를 풀면 쉽다는 느낌이 덜 들게된다. \n    - 뇌가 더 공새하게 되면서 뇌의 신경섬유 연결이 더 활성화된다.\n* 기억전략 5 : 그외 5가지\n    - 자기 참조효과\n    - 정보를 자신과 관련시킬 때 우리는 더 많은 정보를 기억 할 수 있다.\n    - 맥락 효과\n    - 공부할 때의 맥락과 유사할 때 기억을 잘해낼 수 있다.\n    - 시험을 보는 비슷한 시간, 비슷한 장소에서 비슷한 시험 유형으로 공부한다면 실제 시험에 큰 도움이 된다.\n    - 심상 활용\n    - 이미지 활용\n    - 1-닭 치킨이 담배를 피우는 이미지\n    - 조직화\n    - 분류화(범주화)\n    - 첫 낱자 조홥 기법\n\n## h 신박사의 통찰\n* 임생을 바꾸는 암기의 힘\n    - 예 영어단어 암기\n    - X개 단어암기(기간 측정) -> 시험 -> x개 익숙\n          X개 익숙 -> x+a개 단어암기 -> 시험 ………..\n    - 암기는 운동으로 따지면 기초체력\u000b그 어떤 운동도 기교를 따지기 전에 기초체력이 충분히 쌓여야 한다.\n* 고작가의 심화\n* 플로우(flow): 일에 푹 빠져 있는 상태\n* 무아지경 : 자아에 대한 의식이 사라진다.\n    - 건설적이 일이라면 자존감은 더욱 상승(몰입 이후에 더큰 자아존중감을 느끼게된다.)\n* 몰입-> 행복감 -> 쾌감\n      \n      \n      \n# 4. 목표 : 성공적인 목표 설정은 따로 있다.\n\n## a 목표는 왜 중요한가?\n* 현재 우리가 무엇을 해야 하는지 알려준다.\n* 강력한 동기부여\n    - 성취했을 때 없던 힘도 생기고 노력한다.\n* 준거점이 있을때 현재의 모습을 제대로 볼 수 있다.\n\n## b 성장 목표와 증명목표\n* 성장목표\n    - 노력으로 성장한다는 믿음\n    - 실수,실패 -> 무언가를 배우는 경향\n    - 스스로 질문, 요약등 효과적인 공부 전략을 적극적으로 활용\n* 증명목표\n* 결론\n    - 성장목표의 비중을 높이는 것이 학업성취도뿐만 아니라 행복한 인생에도 무조건 유리\n    - 증명목표 사고를 가진 사람은 겨로가 중심의 사고를 할 수 밖에 없다.\n\n## c 증명 목표의 부작용 1. 편법\n* 원하는 결과를 얻을 수 있지만, 성장은 하지 못한다.\n\n## d 증명 목표의 부작용 2. 회피\n* 어린 신동 > 타고난 능력으로 칭찬 > 고정형 사고 방식을 갖고 증명 목표에 메달릴 가능성 높다.\n* 독창성은 실패를 먹고 자란다.\n* 과감한 시도로 인간은 잠시 자신의 위치를 잃을 수 있다. 그러나과감한 시도가 없으면 인간은 자기 자신을 잃는다. - 쇠란 키르케고르\n* 공부의 궁극적인 이유 \"성장\"\n\n## e BHAG목표: 크고 위험하고 대담한 목표\n* Big Hairy Audacious Goal, 장기목표\n* 사람의 감정을 움직이게 한다.\n* 어떻게 장기 목표에 접근할가 ? \n    - 왜 일하는지 스스로에게 계속 묻자\n    - 당신이 가장 존경하는 사람을 떠올려 보자\n    - 그사람이 어떻게 살아 왔는지 삶을 벤치마킹해보자\n    - 인생의 마지막 때를 생각해 보자.\n    - 어떤한 인생을 살았을까? 무슨 일을 하고 살았을까?\n\n## f BHAG목표의 단점\n* 두가지 환상, 포기\n* 환상 : 상상 속에서만 존재하는 목표를 이용해 환상에 빠진다.\n* 포기 : 도전적이고 멀게 느껴질 때\n* 결론 : 그래서 SMART 목표가 필요\n\n## g SMART 목표\n\n## h 시간관리\n* 통찰 : 목표 달성의 재구성\n* 심화 : 산티아고가 내게 준 선물\n    \n# 5. 동기 : 내게 자유를 달라\n## a 동기를 상실한 사람들\n* 심리적 기능\n    - 행동에 활력\n    - 행동에 방향성\n    - 행동의 지속성\n* 동기부여가 제대로 된 학생들 특징\n    - 학교에 대한 긍정적 태도\n    - 어려운 과제를 포기하지 않음\n    - 정보를 깊은 수준으로 처리하고 학급에서의 학습경험이 뛰어남\n\n## b 내재적 동기와 외재적 동기\n* 내재적 동기가 더 중요\n* 자율성\n    - 미래를 기대, 성장형 사고방식, 자신의 잠재력 믿음, 목적의식을 확고히 하는 것 만큼이나 아주 강력한 내재적 동기를 불러 일으키는 것\n        \n\n## c 자율성과 내재적 동기\n\n## d 자율성과 공부\n* 선택권\u000b80문제중 어떤 과목을 풀지 몇 문제를 풀고 싶은지\n* 권한\u000b결정한 문제의 수만큼만 풀어도 되며 교식을 자유롭게 돌아다닐 수 있는 권한\n* 결과\u000b선택권, 권한을 가진 아이들은 문제를 풀 때 끝까지 집중력을 잃지 않았으며, 무엇보다 문제를 쉽게 느끼고 문제 풀이 자체를 즐거워했다.\n\n## e 동기부여의 임계점 그리고 확산\n* 영어 학원 다녀도 성적이 오르지 않을 때 \n    - 일주일에 500개 외우면\n    - 자녀에게 장학금 지급(=학원비)\n* 동기 = 심장\n    - 심장이 멈출때 외부에서 강력한 전기 충격\n\n## f 자율성\n*  스스로 의사결정 가능\n* 주도성을 갖게 하고 책임감을 느끼게 \n* 스스로 통제할 수 있다는 마음을 갖게 한다.\n* 주도성, 책임감, 통제감은 그 어떤 것보다 내적 동기를 불러일으키기 때문에 더 높은 업무 성과를 내는 것\n      \n# 6. 노력 : 노력은 결코 배신하지 않는다\n## a '1만 시간의 법칙'은 틀렸다?\n\n## b 노력은 절대적이다\n* 성장에 있어서 핵심은 홀로 공부하는 것\n* 최상위 학생들\n    - 하루에 개인적으로 3시간 이상 확보(== 스스로 부딪치는 시간)\n    - 수면을 부족하게 하지 않음(수면부족 = 효율 down)\n* 일이 괴로울때 극복유무\n    - 각 분야에 전문가로 성장할 수 있느냐 없느냐를 가늠\n\n## c 재능 결정론의 허구\n* 임계점 돌파\n    - 초반에는 힘든, 어느 정도 수준만 올라서면 그 일에 능숙해지고 더 잘하게 된다는 사실\n    - 도전하는 사람의 나이, 상황, 환경에 따라서 아마추어때 뒤쳐지지만 전문가가 되어서는 압도적인 성과를 내는 경우도 있다.\n\n## d 자제력의 힘\n* 의지력, 인내력, 버티는 힘, 그릿(절대 포기하지 않는 태도), 성실성, 근면성 등 노력을 이끌어 내는데 자제력이 큰 역할을 한다는 것이 증명되었다.\n* 노력을 지속할 힘\n    - 믿음, 목표, 동기부여\n    - + '자제력' : 장기 보상을 위해 단기 충동을 억제 능력\n\n## e 1만 시간은 법칙을 틀렸다.\n* 제대로 된 방법으로 노력해야한다. (= 의식적인 연습)\n\n## f 재능을 키우는 '의식적인 연습'\n* 훌륭한 방법 = 노력의 효율을 몇배나 올려주기 때문\n* 의식적인 연습의 7가지 특징\n    - 일정 수준 이상 체계적으로 정립된 방법론으로 연습해야한다.\n    - 자신의 능력보다 조금 더 어려운 작업을 지속해서 해야한다.\n    - 구체적이고 명확한 목표로 연습한다.\n    - 신중하고 계획적이다.\u000b(= 개인공부시간을 무조건 많이 늘려야 한다.)\n    - 기초를 충실하게 마스터해야한다.\n        (= 고급으로 가기 위해서는 초급, 중급은 필수)\n    - 심성 모형을 만들어 내는 한편 거기에 의존\n    - 피드백과 피드백에 따라 행동을 변경  \n        \n\n## g 심성 모형을 키우는 3F 효과\n* 심성모형이란?\n      - 메타인지 향상과 장기기억 확장을 통해 양과 질을 향상하는 것\u000b\n      - 자기 자신이나 다른 사람 또는 특정 환경 속에서 상호작용하는 사물에 관해 어떤 모형을 갖는 것\n      - 현재 상태 뿐 아니라 미래 예측까지도 잘할 수 있게 된다.\n      - 바둑고수  \u000b\n        * 수천 판 이상 바둑을 두면서 셀 수 없이 많은 패턴을 외우고 각 수가 가진 의미에 대해서 엄청난 고민을 했던 사람들\n        * 단기기억의 한계를 극복\n        * 바둑판에 놓인 말들의 패턴을 한눈에 파악하는 능력을 지님\n* <u>**마태 효과(Matthew Effect)**</u>\n    - </u>**많이 아는자가 더 많이 아는 상황**</u>\n    - </u>**공부는 하면 할수록 효율이 붙는다는 사실**</u>\n* **의식적인 연습**\n    - 피드백을 통해 현재 내가 무엇을 알고 무엇을 모르는지를 알고\n    - 명확한 계획과 실행이 가능 효과적인 전략도 다시 세울 수 있다.\n* **심성모형을 훌륭하게 키우기 위한 3F**\n    - Focus\n        - 마음가짐, 집중할 수 있는 환경\n    - Feed Back\n        - 연습문제 풀기, 수시로 시험보기, 토론하기, 발표하기를 통해\n        - 자신이 실제로 얼마나 알고 있는지를 확인하는 셀프 피드백\n        - 효과 : 메타인지, 장기기억\n    - Fit\n        - 피드백 \u000b-> 자신의 모습확인\u000b-> 그 조건에 맞게 전략을 수정, 계획을 수정, 행동 수정\n        \n\n## h 노력은 배반하지 않는다!\n* 제대로 된 노력은 결코 당신을 배반하지 않는다.\n      그리고 전문가, 프로의 반열에는 오를 수 있다.\n* 신박사의 통찰(=Y수석의 비밀)\n* 노력 = 제대로 + 꾸준히 = 질문하면서 열심히\n* 전공 서적 한 분기에 1권씩 -> 1년이면 8권\n      \n    \n# 7. 감정 : 감정은 공부의 안내자다\n\n## a 5세 아이의 한글 교육은 득일까?\n* 어린아이 한글교육 주의 점 두가지\n    - 7세 전까지 부모가 많이 읽어주자\n    - 7세 전까지는 문자를 외우는 것이 크게 중요하지 않음\n    - 5세 아이는 듣는데 천재, 읽는데 바보\n        * 듣기 : 효율성 높게, 다양한 어휘와 복잡한 문장을 듣는다.\n        * 읽기 : 효율성 낮게, 알고 있는 어휘와 매우 단순한 문장을 힘겹게 읽는다.\n    - 감정은 학습과 밀접한 관계\n    - 한글 공부는 부모가 교육\n    - 부모는 전문교육자가 아님\n    - 아이가 못할 때 감정적 대응\n    - 아이는 감정이 상한다.\n\n## b 감정과 학습\n* 효율적인 기억력 방법 : 기억 할 때 감정의 자극을 받을수록\n\n## c 부정적 감정 VS 긍정적 감정\n* 긍정적 감정일 때 효율적으로 공부 할 수 있다.\n* 예) 삼곡초 수학시험, 골프 퍼팅\n\n## d 시험 불안 해소하기\n* 불안 잠재우기 방법\n    - 정서명명 : \n    - 불안에 대해 상세히 설명, 글을 쓰는 것(잊으려고 노력하는 것이 아니라)\n    - 지금 느끼는 불안에 대해 이성적으로 설명, 글 -> 자신도 모르게 불안이 잠잠 해짐을 느낀다고 한다.\n* 평소 긍정적 에너지 유지 하는 방법 \n    - 부정적 감정이 들 때마다 그것을 긍정적인 단어로 재정의\n    - 매일 감사 일기\n    - 친한 친구들과 서로에 대한 장점을 이야기 하는 시간\n          \n\n## e 시험과 유전자\n* 콤트 유전자 전사형, 걱정쟁이형, 중간형\n* 도파민 대표적인 동기 부여 호르몬\n* 전사형 > 걱정재이형 : 시험에서 좋은 성적\n* 사소한 것들을 걱정하기에는 인생이 너무 짧다 -19세기 소설가 찰스 킹슬리-\n\n## f 신박사의 통찰(관심이 생겼다면 일단 반은 성공이다!)\n* 어떤 일을 하든 간에 감정에 크게 좌우\u000b-> 어떻게 즐겁게 업무 혹은 공부를 할 것인가에 대한 고민도 꼭 하자\u000b너무 무작정 열심히 하려고만 하지 말고 \n\n## g 고 작가의 심화\n* 행복 : 집단주의 vs 개인주의 -> 개인주의 win\n    - 개인의 가치와 감정을 최대한 존중하고 수용하는 문화가 생복을 만든다\n    - 집단주의는 심리적 자유감이 부족하다.(= 내 마음대로 살다간 비판받기 일쑤)\n    - 행복의 조건중 하나 : 사람(가장큰 사망 요인 = 외로움)\n* 행복 관련 책\n    - 행복의 기원-서은국 교수\n    - 행복의 조건-조지 베일런트\n    - 당신이 지갑을 열기 전에 알아야 할 것들-엘리자베스던과 마이클 노튼\n\n## h 동기부여의 임계점 그리고 확산 \n\n# 8. 사회성 : 함께할 때 똑똑해진다.\n\n## a 진정한 사회적 동물\n* \"아리스토텔레스\" <정치학>\n    - 사회적이 아닌 개체는 하찮은 존재이거나 인간보다 높은 수준의 존재이다. 사회는 본질적으로 개체보다 우위에 있는 어떤 것이다. 공동 생활을 영위할 수 없거나, 혹은 공동생활의 필요성을 느끼지 않을 만큼 자급자족이 가능한, 그래서 사회의 일원이 되지 않는 존재가 있다면, 그것은 짐승이거나 신이다.\n\n## b 외로우면 멍청해진다\n* 외로움은 한 사람의 지적 과제 수행 능력을 떨어뜨린다. 자재력을 끌어내리고, 니능 지수도 낮춘다. \u000b이에 따라 청소년과 대학생들의 내신과 시험 성적 또한 끌어내린다. 뿐만아니라 직장인의 업무 능력도 저하시킨다.\n\n## c 외로우면 건강을 잃는다\n* 외로움을 느끼는 것만으로도 지적 능력이 저하되고 신체 기능마저 나빠진다.\u000b즉 공부에 크나큰 적\n\n## d 우정이 똑똑하고 건강한 사람을 만든다\n* 우정의조건\n    - 익숙함\n    - 물리적 근접성\n    - 유사성\n    - 서로의 비밀\n* 결론\n    - 같은 목적을 가진 사람들과 함께 고웁하며, 서로의 고충을 나누고 격려하고, 더 나아가 서로를 가르치는 행위까지 한다면 외로움도 없애고 기억력도 상승시키는 1석2조의효과를 누릴 수 있다.\n    - 그리고 만약 그 모임이 지속하며 모두에게 소속감까지 준다면 공부 효율은 상상할 수 없을 만큼 올라갈 수 있다.\n\n## e 한줄 요약\n    - 진정한 우정과, 소속감을 느낀다면 똑똑해진다.\n\n## f 대인관계가 성공을 결정짓는다.\n* 대인관계의 중요성을 미리 알고 공부하고 실천하며 살아간다면 일에서뿌만아니라 삶에서 긍정적인 일들을 기대할 수 있기 때문이다.\n* 대인관계에서 가장 중요한 덕목 하나를 뽑으라고하면 '공감능력'이다.\n\n## g 공감능력의 힘과 소설 읽기\u000b: 대인 관계의 기본\n* 공감능력 발달 두가지 방법\n    - 많은 사람과 만남 \n        * 다양한 상황과 여건에서 사람들과 부딛히다 보면 자연스럽게 상대방의 몸짓과 표정을 읽게 되고 상대방의 마음을 헤아리게 된다.\n    - 문학 소성 읽기\u000b\n        * 주인공, 그 인물을 둘러싼 다양한 군상들에 대해 심리를 해석하게 됨으로 타인의 마음을 읽을 수 있는 연습을 할 수 있다.\n\n## h 대인관계를 높이는 7가지 기술\u000b: 대인관계 높이는 기본 -공감능력-\n* 일관성\n    - 관계중 좋은 순위 \u000b긍정적 관계 > 부정적 관계 > 양면적 관계\n    - 양면적 관계가 최악\n        * 이유1 : 상대방이 어떻게 나올지 모르기때문에 불안정감을 느낀다. (사람은 적응을 잘하기때문에 부정적 관계도 적응을 잘할 수 있다.)\n        * 이유2 : 스트레스 지수, 우울증, 삶에 대한 불만이 상대적으로 더 크다는 것\n        * 이유3 : 친한사람은 어떻게 반응할지 안다는 것이다. 그래서 편한다.\u000b\n* 존중\n    - 직장 동료를 존중할때 직장생활이 행복하다고 느낀다.\n    - 존중 받으려면 존중해야한다.\n* 경청\n    - 타인의 말을 진실하게 경청하는 능력이 결합된 인물일수록 동료들에게 신망을 얻는다.\n    - 적극적 듣기 자세 방법\n        * 말하는 사람쪽으로 약간 기울인다/ 눈을 마주친다/ 고개를 끄덕인다.\n* 조언\n    - 성공적으로 임원이 된 사람들은 상사에게 조어을 자주 구한다.\n    - 조언을 구하는 자는 뭘 모르는게 아니다 뭘 좀 아는자다.\n* 겸손\n    - 지위가 낮은 사람일수록 다른 사람의 관점을 잘 읽는다는 연구 결과가 있다.(UC버클리대학의 대처 케트너 교수팀)\n    - 교만 : 타인의 마음을 읽는 능력을 상실\n    - 겸손 : 마음을 헤아리는 능력을 상승\n* 칭찬\n    - 다른 사람에게 인정받는 것 만큼 행복한 것은 없다.\n    - 칭찬이 진심이 아니라는 것을 알면서도 칭찬하는 이를 좋아하는 사람이 있다.(그렇다고 남발하지 말자/ 상황, 사람을 보며 눈치것 하자)\n* 실수\n    - 실수효과\n        * 전문가일때 실수를 할때 더 호감을 살 수 있다.\n        * 대인관계에 이어서 실력이 주는 영향력이 대단하다\n* 마지막 한줄\u000b: 공감능력, 실력이 뒷받침 되는 상태에서 나머지 대인관꺠 기술들을 제대로 연마하게 되면 당신은 당신은 '사,기,캐,릭'이 되고도 남는다.\n      \n* 통찰:가장 어려운 인간관계 하지만 가장 중요한 인간관계\n* '인간관계론'/ 아마존 서점에서 아직도 판매 최상위권/ \n* 예전 경험이지만 이유 사회과학 실험으로 부터 나온 결론과 일치하기때문\n* 심화:대인관계의 신인류:이기적 이타주의자\n* 애덤 그랜트는 사람을 3가지 유형으로 분류\n    - Taker : 자신이 준것보다 더 많이 받기를 바라는 사람\n    - Matcher : 상부상조 원리를 내세워 자기 이익을 보호\n    - Giver : 더 많이 주기를 좋아한다.\n*  애덤 그랜트가 나눈 3가지 유형으로 본 성공할 확률이 높은 사람\n    - GIVER \n    - 이유 \n        * 현대 사회는 조직을 이룬다/조직은 믿을 수 있는 투자자,파트너 필요\n        * 누군가에게 도움을 주면 피드백 속도가 점점 빨라진다.\n* 이기적 이타주의자 \n    - 이기심, 이타심은 매우 독립적이기 때문에 우리는 이 둘을 모두 가질 수 있다.\n    - 성공한 기버들은 강한 동기부여 요소인 이타심과 이기심을 자신 안에 적절히 융합 시켜 일을 추진한다.\n    - 자신의 베푸는 행동이 어떠한 사회적 영향력을 발휘하는지에 대해 잘 안다.\n    - 자신의 희생이 큰 영향력을 발휘한다는 것을 확인하는 것은 최고의 보상이 되기 때문이다.\n        \n    \n  \n# 9. 몸 : 몸은 공부의 길을 안다\n## a 나사는 왜 실패했을까?\n* 아래 문제를 알고도 모든팀이 빡빡한 일정때문에(우주 궤도에 맞춰 미룰 수 없었다.) 뒤로 미뤄두고 해결하지 못하고 프로젝트는 진행 되었다.\n    - 문제\n        * 궤도 진입에는 적적한 속도가 적대적(이 속도는 매우 복잡하고 정밀한 계산)\n        * 궤도에 적절한 속도로 진입하기 위해서는 역추진 엔진 가동 필요\n        * 역주친 엔진이 너무 강력하게 돌앗다.\n        * 역추진엔진 : 영국식측정법/ 중앙처리장치 : 미터법\n\n## b 휴식은 문제 해결의 열쇠\n* 복잡한 문제를 해결, 고민스러운 의사결정을 할때, 아이디어의 샘이 메말랐을때 무의식이 힘을 발휘하도록 우리는 휴식과 여유로운 시간을 가질 필요가 있다.\n\n## c 최고의 공부 전략, 운동\n* 뇌유래신경영양인자(BDNF)\n    - 뇌 시냅스 근처에 잇는 저장소에 모여있다가 혈액이 펌프질할 때 분비되는 단백질로서 새로운 신경세포를 생성하고 기존 신경세포를 보호하며 시냅스의 연결을 촉진(=뇌의 가소성에 핵심적인 역할을 한다.)\n    - 학습과 기억의 가장 중요한 토대를 마련해준다.\n* 세로토닌, 도파민, 노르에피네프린 생성 증가\n    - 이 신경 화학물질들은 집중력, 뇌의 각성 상태, 기분전화을 통한 학습 긍적적 태도 증가, 인내심과 자제력등을 높힌다.\n* 학습에 최적화된 운동\n    - 유산소(뇌 건강에 가장 큰 호전을 가져다 줌 by 쥐 실험)\n* 운동의 최적시기 \n    - 공부하기 전 \n    - 이유 \n        * 운동 중 인지능력의 최상위 역할을 하는 전전두엽에 혈류량이 많지가 않아 집중도 있는 공부가 잘 안됨 / but 운동 후 즉시 전전두엽에 혈류량이 많아져 학습을 위한 최상의 상태에 돌입\n* 운동 횟수\n    - 일주일 4~5회, 30분씩     \n\n## d 수면도 최고의 공부전략\n* 잠을 자는 동안 뇌는 새로운 기억을 기존기억과 통합, 통합된 기억을 다시 분석\n* 성인 권장 수면시간 : 7-9\n\n## e 낮잠, 커피 그리고 설탕\n* 낮잠 추천 시간 : 일어잔후 7~8시간 후/ 30분 이내\n* 커피 추천 양 : 하루 머그잔 기준 두잔 이하\n* 커피 & 피곤함 \n    - 피곤함을 느끼는 이유\u000b\n        * 뇌를 쓰면 아데노신 물질 생김/ 뇌의 수용기(receptor)에 붙는다.\u000b(수용기에 쌓이면 우리 몸은 피곤함을 느낌)\u000b\n        * 커피를 마시면 카페인도 수용기에 붙는다.(즉 아데노신이 수용기에 붙을 수 없다.)\n* 낮참 & 피곤함\n    - 잠을 잘 때 아데노신이 사라지기 때문에 개운해지는 것\n* 명상\n    - 주의력, 집중력, 스트레스 수준을 낮춰줌\n* 기억력/ 문제 해결 능력을 높이는 방법\n    - 다중감각학습\n    - 시각, 청각, 촉각등 두개 이상의 감각을 사용\u000b\n\n## f 통찰 : 공부의 뿌리 : 건강(신박사 통찰)\n* 운동으로 숙면\n* 몸이 가벼워 20~30분 정도 영어공부\n* \"건강한 신체에 건강한 정신이 깃든다.\"\u000b=\"건강한 신체가 공부도 업무도 더 잘하게 해준다\"\u000b\n    \n# 10. 환경 : 공부 효율은 환경 따라 달라진다\n## a 신 박사 + 비닐가방 = 영어회화\n* 영어회화시 불필요한 말을 줄이기 위해서 강력한 화경을 조성\n      \n\n## b 알람을활용하라!\n* 습관은 도도히 그리고 거대하게 흐른 물 같아서 우리의 의지로는 대부분 그 물줄기를 바꾸지 못한다.\n* 습관을 깨기 위한 방법 : 환경설정\n\n## c 눈에띄게 만들기\n* 눈에 띄는 장치로 공부/ 업무 효율을 높일 수 있을 지 고민해보자\n\n## d 데드라인 만들기\n* 성공-> 보상/ 실패-> 벌금\n\n## e 고작가 + 지하철 = 영어 독해\n* 공간을 활용 환경설정\n\n## f 공간이 무의식에 끼치는 영향\n\n## g 몰입을 방해하는 스마트폰\n* 섬엽(insula): 공상, 집중 상태의 전환 기능\n* 자주 사용할수록 피곤함이 증가\n* 스마트폰사용 섬엽 자주 사용 -> 피로도 증가\n* 쉴때 스마트폰을 쓰지 말자\n* 인지자원은 한정 스마트폰을 사용함으로 인지자원을 사용하면 다른곳에 사용할 수 없다.\n\n## h 공부 효율이 떨어지는 뇌\n* 스마트폰/인터넷 사용으로 '전전두엽'사용\n* 전전두엽\u000b\n    - 문제 해결이나 의사결정을 담당하는 부위\u000b\n    - 독서를 할 때는 거의 활성화되지 않는 부위\n* 왜 인터넷으로 글을 읽는데 전전두엽을 사용할까?\u000b\n    - 인지 자원을 콘텐츠에 집중시키지 못하고 다른데에 사용하게 하는 다양한 방해물들이 있기때문\n* 쓸데없는 의사결정, 괄계없는 문제해결, 주의력 분산의 세가지가 집중력이 저하\n* 결론\u000b\n    - 읽기는 공부에서 가장 기본이 되는 능력\u000b\n    - 스마트폰/인터넷으로 읽기 능력을 저하 시키지 말자\n* 마지막 한마디\u000b\n    - 우리가 집을 만들지만, 그 집이 다시 우리를 만든다\u000b\n    - 환경은 우리가 만들지만, 그 환경이 우리를 만든다는 것이다.\u000b\n    - 환경 설정만 잘해도 당신의 공부 효율은 몇 배나 향상 될 수 있다.\n\n## i 통찰 : 결심보다 강력한 것은환경(신박사)\n* 집중을 잘하려면 의지보다 환경설정이 필요\n* 스스로 인생을 발전시키고 싶다면 마음 보다 환경을 바꿔야한다.\n* 올바른 환경 설정이 반이다\n\n## j 심화 : 구글의 스마트한 환경 설정\n    \n\n# 11. 창의성 : 창의성은 지능이 아니라 태도다\n## a 창의성에 대한 오해\n* 스티브잡스 say\u000b   \n    - 창의성은 당지 사물을 잇는 것이다. 창의적인 사람들에게 그토록 괸장한 일을 어떻게 할 수 있었는지 물어보면 약간 죄책감을 느낀다.\u000b(즉 창의성의 첫번째 속정은 '연결' 이다)\n\n## b 연결이 곧 창의성이다.\n* 스티브잡스 say 2\u000b\n    -  뭔가를 한 것이 아니라 그저 본것이기 때문이다. 일단 눈에 띈 후 에는 당연한 것처럼 생각된다. 과거의 경험을 연결하여 새로운 것을 합성하기 때문이다. 그것이 가능한 이유는 경험이 많거나 다른 사람들 보다 자신의 경험에 대해 더 많이 생각했기 때문이다.\n    - 즉 다양한 경험이 있을수록 그 사람은 창의적인 아이디어를 낼 가능성이 커진다. 왜냐하면 연결한 것들이 많으니까.\n\n## c 다양한 경험\n* 노벨상 받은 과학자는 예술을 즐겼다.\n* 여행은 찾선 경험을 축적해주고 그 겨험들은 창의성을 발휘 할 수 있는 귀중한 재료가 된다.\n* 낯선 경험 방법 네가지\n    - 전문 분야와 다른 분야의 취미를 가져보라\u000b: eg)전문분야 : 인문/과학, 취미 : 스포츠 \n    - 해외여행\n        * 이질적인 문화를 몸소 체험하는 것\u000b: 문화를 알려면 보는 것보다 대화를 함께하는것이 좋다고 생각한다.\n    - 다양한 분야의 사람\n    - 다양한 책\n        * 적응 비용으로 다양한 경험 가능\n        * 논리와 지성이 진하게 녹아 있음\n\n## d 도전도많이, 실패도 많이\n\n## e 통찰 : 다시 그리고 또 다시!\u000b\n    * 작성대기\n\n## f 심화 : 창의성과 리스크관리\u000b\n    * 작성대기\n\n    \n# 12. 독서 : 독서는 모든 공부의 기초다.\n\n## a 질문이 사라진 학교\n\n## b 질문 못하는 기자\n* 질문이 없다 -> 의문이 없다 -> '비판적 사고'의 결여\n* 당연한 현상에 '정말 그럴까?' 라는 의문을 던질 수 있을 때 성장과 발전이 있을 수 있다.\n* 미국에서 논문을 쓰는 과정 6가지\n    - 연구주제 찾기\n    - 정해진 연구 주제 답을 도출하기 위해 얻너 방법으로 어떻게 진행할지 연구방법론 및 절차를 설계\n    - 연구와 관련이 있을 만한 각종 자료 및 선행 문헌들을 읽고 분석\n    - 연구 설계에 따른 절차(실험, 개발, 조사, 인터뷰)들을 직접 수행\n    - 연구 결과를 분석\n    - 분석의 결과가 무엇을 의미하는 것인지 해석하고 결론을 도출\n* 한국인은 연구주제찾기, 분석 결과가 무엇을 의미하는 것인지 해석하고 결론도출을 잘 못한다.(나머지는 잘한다)\n* 질문 찾는 방법 -> 독서\u000b\n\n## c 지적인 호기심과 만나다\n* '지식'과 '자식의 부재'가 적절히 균형을 이루었을 때 호기심은 기지개를 켜기 시작한다.\n* 지식이 있을 때 비로소 '지식의 공백'을 느끼게 된다.\n* 독서로 습득한 다양한 지식은 아이러니하게도 지식의 공백을 만들어 우리를 지적 호기심의 세계로 이끈다.\n* 한 그룹은 칸마다 여러 종류의 동물 그림 \u000b: 한칸을 클릭하면 큰 동물의 극히 일부분만\u000b= 검색을 통해 단편적인 정보를 얻거나 대부분 짧은 인터넷 글을 보는 행위\u000b: 책 한 권을 읽는 것은 큰 그림을 보는 것과 같고 더나아가 더 큰 그림이 있음을 알려주기도한다.\n* 세상사를 다 파악했다고 생각하는 속 편한 확신을 떠받치는 것은 자신의 무지를 무시할 수 있는 무한한 능력이다.\n* 무지를 무시할 수 있는 무한한 능력의 소유자\n    - 독서 x(무식해서 확신에 차있다.)\n    - 자신의 전문 분야만 하는 사람(편협함으로 확신에 차있다.)\n* 독서는 ?\n    - 자식을 준다.\n    - 자식의 부재가 있음을 알게 한다.\n    - 자적인 호기심을 갖도록 한다.\n    - 지적인 호기심을 느끼는 당신은 당연히 '잘문'을 던질 수 밖에 없을 것이다.\n\n## d 비판적 사고 그리고 책이라는 것\n* 비판적 사고란 ? \n    - 의문만 품는 것이 아니라 \n    - 증거에 근거해서 결론을 내리는 개인의 능려고가 경향을 포함한다.\n\n## e 처참한 성인 문해력\n* 1~5 등급(높을 수록 문해력이 높다)\n    - 4~5등급으로 문해력 가진 사람은 1등급 문해력을 가진 사람보다 임금은 2.9배, 봉사활동 찬여도 2.5배, 자기신뢰 2.3배, 취업률 2.2배 건강은 2.1배가 높은 것으로 나왔다.\u000b(OECD 평균으로 분석한 것이지만 문해력과 사회경재적 지위 및 성취가 얼마나 높은 상관과계를 맺는지 나타낸다.\n* 우리나라는 평균 2등급\u000b우리 나라 사람은 토론을 잘 못한다.(토론을 원활하게 하기 위해서는 3등급 이상은 되어야하기 때문에)\n* 2등급\u000b\n    - 둘 이상의 정보를 통합할 수 있고, 비교 대조하거나 간단한 추리나 추론을 할 수 있다. 정보에 접근하고 필요한 정보를 식별하기 위해 다양한 디지털 텍스트를 검토할 수 있다.\n* 3등급\n    - 여러 페이지에 걸친 비교적 난해하고 긴 문장을 이해할 수 있다. 텍스트의 구조를 이해하고 여기에 구사한 수사법을 간파하고 해석할 수 있으며 여러곳에서 정보를 얻고 해석하여 적절한 추론을 할 수 있다.\n* 4등급\n    - 복잡하거나 긴 텍스트에서 여러 단계에 걸쳐 체계적으로 정보를 조합, 해석, 축적할 수 있다. 텍스트의 배경에 깔린 주장을 해석 하거나 평가할 수 있으며, 이를 적용하여 복잡한 추론이나 설득을 할 수 있다.\n* 5등급\n    - 다양한 분야을 아우르는 어려운 텍스트에서 정보를 찾고 축적할 수 있다. 또한, 텍스트에서 핵심 아이디어를 추려내고 분류하고 재구성할 수 있으며 증거와 논증에 기반을 두어 평가할 수 있다. 이들은 논리적이고 개념적인 모형을 수립할 수 있으며, 텍스트에서 핵심 정보를 추출하고 객관적으로 그 신뢰도와 타당성을 평가할 수 있다.\n\n## f 다독이 첫 시작이다\n* 초보자\u000b\n    - 편하게 하루 1시간 2~3달 꾸준히  \n    : 그 이후 스스로 정독하고 재독하는 자신을 마주 할 수 있음\n* 다독의 종류\u000b\n    - 계독: 한 분야의 계보에 따라 \u000b\n    - 남독: 다양한 책을   \n        * 지은이 추천 \n            - 계독(관심, 전공 분야에 책을 최소 50~200권 정도 읽어야 준전문가 수준의 식견을 얻는다.)\u000b-> 일하는데 직접적인 도움 & 전문가들을 비평할 정도의 실력을 갖춘 자신을 보며 삶에 큰 자신감\n\n## g 그 외 독서법: 만독, 관독, 재독, 낭독\n* 만독\u000b\n    - 느리게 읽기(=책 한권을 해부)\u000b\n    - 챕터별로 요약(+ 자기 생각을 덧붙이거나 연관된 다른 자료를 함께 적기)\u000b\n    - 블로그, SNS로 자신의 글을 공개해 보자\u000b-> 공기된 글쓰기를 하면 집중도가 배가 될 뿐만 아니라 퇴고도 더 잘하게 되고 무엇보다 대중에게 피드백을 받을 수 있으므로 성장에 있어서 최고의 전략\u000b\n    - 이런 과정 -> 완성된 멋진 글을 쓰는 자기 자신을 만나게 된다.\n* 관독\u000b\n    - 하나의 관점을 갖고 책을 읽는 것\u000b\n    - 예) 공부법 책을 쓰려는 관점으로 다른 책을 바라 봤을때 예전에 큰 의미 없이 넘겼던 내용과 이론들이 공부법과 연계되기 시작한다\u000b\n    - 콘텐츠 제작, 아이디어 발굴에 도움이 된다.\u000b\n    - 특정 관점을 가지고 세상을 바라보면 때로는 많은 것을 놓칠 수 있겠지만, 자신에게 진짜 중요한 것을 얻게 된다.\n* 재독\u000b\n    - 다시 읽기(망각의 강을 건넌 다음에)\u000b\n    - 과거의 자신을 보게 할 뿐만 아니라 변해 버린 현재의 자신을 인지시켜 준다.\u000b\n    - 고작가 say -> 재독 '자아의 시간여행'\n* 낭독\u000b\n    - 소리 내어 읽는 독서법\u000b\n    - 유시만 작가 say \u000b-> 묵독보다 낭독이 말이 되는 글인지 안되는 글인지(좋은 글의 기준)바로 알 수 있다.즉, 퇴고에 매우 유용하다.\u000b\n    - 글의 마지막 투수\n\n## h 독서 습관을 만드는 7가지 방법\n* 스마트폰과 멀어지기\u000b\n    - 비행기 모드로 해 놓고 책보기\u000b\n    - 스마트폰과 멀어질수록 독서는 가까워진다.\n    - 지하철 - 스마트폰을 넣어두고 무조건 책을 읽는다는 마음가짐\n* 인지부조화 이용하기\u000b\n    - 독서를 하기 싫을 때 조차도 그냥 읽어본다.\u000b\n    - 메커니즘 \u000b- 싫은데 계속했을 때 뇌 -> 자기정당화(독서를 하고 있어! 나는 독서를 좋아해!!!)\n* 책을 한꺼번에 많이 사기\u000b\n    - 5-10권을 사고 눈에 띄는 곳으로 => '내가 앞으로 읽을 책들이 저기 많구나...'\n* 독서 모임 \u000b\n    - 책으로 만난 사람들과의 모임은 삶의 질을 향상해 준다.\n* 3~4권 동시에 읽기\u000b\n    - 읽기 싫을 때 -> 그냥 덮고 다른 책을 읽는다.(마음의 반전)\u000b-> 다시 볼때 이미 몇십 페이지 읽음\u000b-> 고지가 좀 더 낮아 보여 저항이 줄어듬\u000bthen, 1~2권은 정말 읽고 싶은 책을 사 놓을 수록 좋다.\n* 다독가를 주변에 두기\u000b\n    - 가슴속에 큰 동기부여\u000b\u000b\n* 통찰 \n    - 독서, 인생 성장자양분(신박사의 통찰)\n* 회사에서 가장 좋은 학습 방법\u000b\n    - 배운 것을 활용해서 내 지식의 깊이를 더하는 것\u000b(똑같은 지식을 간접 적으로 배운 경우 vs 경험을 통해서 배운 경우\u000b=> 겉으로 보기에 아는 것은 비슷 but, 깊이, 검세함 그리고 그 지식에 대한 확신 정도는 비교조차 되지 않는다.)\n* 회사에서 좋은 학습 방법에 적용하기 어려운 이유& 해결책\n    - 적용이 어려운 이유\n        * 축적한 지식의 양이 너무 적거나, 그 깊이가 업무에 적용될 만큼 성숙하지 않을 때\u000b\n        * 지식은 충분히 잇으나 업무가 바뀌어 버리는 경우\n    - 해결책\u000b\n        * 꾸준히 공부 -> 부족한 지식 채움\u000b\n        * 업무가 바뀔때 -> 학습을 통해 새로운 환경에 적응\n* 공부의 핵심\u000b\n    - 독해력 & 요약 능력\u000b\n    - 독해력이 떨어지면 업무파악 어렵\u000b\n    - 오약 능력이 떨어지면 보고하고 소통하는 것이 어렵\n* 독해력 키우는 방법\u000b\n    - 책의 난이도를 서서히 높여간다.\n* 요약 능력 키우는 방법\u000b\n    - 토론, 독서 노트로 요약 능력을 향상\u000b\n    - 건설적으로 해 줄 이야기가 많아진다.\n    \n# 13. 영어 : 이번 기회에 제대로 배우자.\n\n# 14. 일 : 실전처럼 공부하면 실전에서 통한다.\n\n## a 머리가 아니라'몸'으로 공부하기\n\n## b 실질학습의 효과\n\n## c 반복연습과 실전학습의 놀라운 조화\n* 반복연습은 상당한 의지력이 있어야 함은 틀림 없지만 한 사람을 빛나는 천재처럼 보이게 할 정도로 대단하다\n* '반복연습', '실질학습'의 놀라운 조화 실력을 키우는 좋은 방법\u000b\n    - 예) 발표 : 최대한 실전과 비슷하게 반복연습\n\n## d 프로세스를 활용한 의사결정\n\n## e 시뮬레이션의 놀라운 능력\n* 시뮬레이션은 실제로 행동하는 것만큼의 효과는 거둘 수 없다.\u000bbut, 그 다음으로 가장 훌륭한 방법이다.\n* 시뮬레이션으로 익숙한 상황이므로 일을 잘 처리하는 것\n* 시뮬레이션: '미래계획기억'을 형성하는 거의 유일한 방법\n\n## f 디테일을 잊지말자\n* 깨진 유리창은 처음에는 매우 사소\u000bbut, 그 디테일을 놓치게 되면 차 전체가 망가지게 된다.\n* 실수의 미용이 적을 때는 충분히 복구할 수 있으며 실수가 오히려 다음 성공에 큰 밑천\u000bbut, 절대 놓치지 말아야 할 디테일이 있다.(중요한 바이어, 신제품을 출시, 사활이 걸린 행사-두 번째 기회가 없는 일에서 실수란 용납되지 않는다.-)\n* 디테일 != 사소한 것, 디테일 == 막중한 것\n\n## g 통찰1 : 공부의 화룡점정 : 말하기와 발표\n\n## h 심화 : 짐단 의사 결정은 왜 실패하는가?\n\n## i 통찰 2: 회사생활은 왜 이렇게 힘들까?\n*  직급의 역할\u000b\n    - 사원 실무를 잘해야 한다.\u000b\n    - 대리 사원처럼 실무를, 과장 처럼 관리를 잘해야 한다.\u000b\n    - 과장 조직 관리가 되어야 한다.\u000b- 우리 나라에서는 과장의 리더십 가뭄이다.\u000b\n    - 부장 영어로 director = 문제 발생시 방향을 제시할 수 있어야 한다.\u000b\n    - 관리만 잘하는 것은 연차 높은 과장일 뿐\u000b\n    - 진짜로 일이 어떻게 돌아가는지 현장의 온도를 정확하게 파악해야 하기에 사원하고 가장가까운 직급\u000b\n    - 누구보다 더 부지런해져야 한다.(현장감도 잃지 않고 누구보다 더 열심히 해서 끊임없이 새로운 아이템을 발굴해야한다.)\u000b\n    - 임원 \n        * 결정하는 사람(= 막중한 책임이 따른다)\n* 회사가 마음에 안든다.(eg 부조리, 돌아이 상사)\u000b: 공부를 열심히해서 이직을 하면 된다.\n* 이직이 어려운 이유\u000b\n    - 새로운 환경에 다시 적응해야 하기 때문\u000b\n    - 정말 이직을 하고 싶다면 현실적인 답 \n    - '버티면서' 공부해야한다 현실을 무시 할 방법은 없다.\n        * 결국은 공부가 생각보다 많은 것을 해결해 주지만 안타깝게도 많은 사람이 공부하지 앟는다.\u000b\n        * 잊지 말자. 공부가 답이다.\u000b(회사 생활을 시작해도 꾸준히 능동적으로 공부할 마음만 있다면 생각보다 직장 생활은 힘들지 않다)\n","excerpt":"우연한 계기로 이 책을 읽고 신영준, 고영성 작가를 알게 돼서  공부해서 을 높여야 한다는 것을 깨닫고 2018년 여름 패스트 캠퍼스를 다니기 시작한 여름부터 지금 작성하는 2020년 2월까지 약 1년 8개월 동안 Javascript…","fields":{"slug":"/완벽한 공부법/"},"frontmatter":{"date":"Nov 04, 2018","title":"완벽한 공부법","tags":["독서후기"]}}}]}},"pageContext":{}}}