{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n\nsetTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래 3개를 직접 그리며 개념을 정리했다.\n\n\n# 이벤트 루프 설명 시 주요 용어\n    - 호출스택\n    - 백그라운드\n    - 테스크큐\n    - 이벤트 루프\n\n# 이벤트 루프 설명 예시\n```js\n\nconsole.log('Hi');\n\nsetTimeout(function(){\n    console.log('CB');\n}, 3000)\n\nconsole.log('bye');\n\n```\n* 위 코드 결과는 Hi, bye, CB 순서로 로그가 남게 된다. 아래 설명을 참고\n* 만약 setTimeout이 0초로 설정하게 된다면 로그는 어떻게 출력이 될지 아래 설명을 보면서 생각해보자 \n\n## 이벤트 루프 예시 도식화/ 설명\n![](eventLoop1.jpg)\n* 상태 \n    - console.log('Hi')가 수행되어 콘솔에 찍히고 `호출스택`에서 빠진 상태\n* 설명\n    1. setTimeout이 수행되어 setTimeout callback function이 `백그라운드`로 이동된 상태\n    2. setTimeout callback function이 `백그라운드`로 이동\n    3. 3초후에 setTimeout callbakc function이 수행 되도록 설정 되어 있기 때문에 3초 이후 `태스크 큐`로 이동\n\n![](eventLoop2.jpg)\n\n* 설명\n    4. `호출 스택`실행이 끝나면 \n    5. `이벤트루프`는 태스크 큐의 callback function을 `호출 스택`으로 올린다.\n\n![](eventLoop3.jpg)\n* 설명  \n    6. run(setTimeout callback function)이 `호출 스택`에서 실행 되고 비워지게 된다.  \n    7. `이벤트루프`는 `태스크 큐`에 callback function이 들어올 때까지 대기\n\n\n# 추가 설명\n* setTimeout 0초는 4ms 지연 시간을 갖고 있어 hi, bye, CB 순서대로 로그가 남게 된다.\n* 백그라운드에서 3초를 설정했음에도 3초 후에 실행되지 않는경우 \n    - 호출 스택에서 많은 일을 하게 되면 이벤트루프가 태스크 큐에 쌓이 콜백함수들을 호출스택으로 끌어 올리지 못하기 때문\n* 백그라운드 사용하는 작업\n    - setTimeout, setInterval\n    - ajax 요청\n    - event Listener  \n        : 참고  http://latentflip.com/loupe/\n    - File Reader\n    - Javascript 기본제공 메소드 중 콜백 함수를 사용하는 메소드는 백그라운드를 사용하는 경우가 많다.\n\n# 참고 \n* 1. 제로초\n* 2. JSConf\n    - https://www.youtube.com/watch?v=8aGhZQkoFbQ&feature=emb_title","excerpt":"setTimeout을 통해서 비동기 처리를 하는데 호출 스택이 어떻게 되는지 궁금하다 이벤트 루프를 알게 됐고 \n맨아래 참고 두번째 유브를 통해서 개념을 알고 첫번째 제로초 사이트에 알기 쉽게 도식화 된 내용을 참고하여 아래…","fields":{"slug":"/eventLoop/"},"frontmatter":{"date":"Feb 16, 2020","title":"eventLoop","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n\n예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source를 사용하려면 당연히 사용 할수 없습니다.  \n(**스크립트 읽기가 지금 당장 시작되더라도 실행은 함수가 종료되고 난 후에야 실행되므로 스크립트는 ‘비동기적으로’ 실행되었다고 할 수 있습니다.**)\n\n이렇게 비동기 적으로 실행되고 있는 문제를 해결하기위해서 callback기반 비동기 프로그램 방법으로 해결 할 수 있습니다.  \n(**무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공** -> script load를 보장 하는 loadScript function capter)\n\n하지만 callback기반 비동기 프로그램은 callback hell이라는 단점이 있고 이런 문제를 해결 할 수 있는 방법이 'promise, Async, awiat'fksms 개념이 있습니다. -> callback hell capter\n\n\n\n# callback function \n## script load를 보장 할 수 없는 loadScript function\n* document객체에 생성한 script객체를 추가해주면 추가한 script 주소를 통해서 원하는 파일을 받을 수 있다.\n* `loadScript` 구현\n    ```js\n    function loadScript(src) {\n        // creates a <script> tag and append it to the page\n        // this causes the script with given src to start loading and run when complete\n        var script = document.createElement('script');\n        script.src = src;\n        document.head.append(script);\n    }\n    ```\n\n    ```js\n    loadScript('/my/script.js'); // the script has \"function newFunction() {…}\n    newFunction(); // no such function!\n    ````\n* sciprt.js에 newFunction() 이 있다고 하자 loadScript를 통해서 받은 script.js파일에 선언한 newFunction()을 호출 하면 호출하지 못 한다.\n* 이유는 브라우저가 script.js 파일을 받기 전에 newFunction을 호출 했기 때문이다.\n* 그래서 **파일을 받고 function을 호출 시키는 보장해주는 코드를 추가 해야한다.**\n\n## script load를 보장 하는 loadScript function\n* 위 load를 보장하지 못하는 코드와 달라진점은 `callback` function 을 parameter로 전달해주고 loadScript는 전달 받은 param을 script onload property에 추가해줬다.\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(script);   // 기능 개선한 부분\n\n        document.head.append(script);\n    }\n    ```\n\n### script laod를 보장하는 예제\n* load를 보장하는 기능이 개선 된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n        script.onload = () => callback(script);       //POINT\n        document.head.append(script);\n    }\n\n    loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n        console.log(`Cool, the script ${script.src} is loaded`);\n        console.log( _ ); // function declared in the loaded script\n    });\n    ```\n* 결과 \n    - loadScript callback function을 확인해보면 콘솔 로그가 두개 있는데. script.src에 추가한 loadScript 첫번째 param loadash cdn 주소를 포함한 문자열과 load한 lodash lib의 _ 객체를 확인 할 수 있다.\n    - **callback function은 받고 싶은 파일을 로드한뒤 사용할 수 있는 공간이다.**(loadScript callback callback function으로 넘어 갔기 때문)\n\n* 정리 \n    - **이런 방식을 `콜백 기반(callback-based)` 비동기 프로그래밍이라고 합니다. 무언가를 비동기적으로 처리하는 함수는 함수 내 동작이 모두 처리된 후 실행되어야 하는 함수가 들어갈 콜백을 인수로 반드시 제공해야 합니다.**\n\n# callback in callback \n* 위 예제 처럼 callback으로 하나의 파일만 로드할 뿐만 아니라 여러개도 load하고 싶을 것이다. \n* 아래 예제와 같이 구현 할 수 있을 것이다.\n    ```js\n    loadScript('/my/script.js', function(script) {\n\n        loadScript('/my/script2.js', function(script) {\n\n            loadScript('/my/script3.js', function(script) {\n            // ...continue after all scripts are loaded\n            });\n\n        })\n\n    });\n    ```\n\n# Handling errors \n* error 처리를 할 수 있는 기능이 개선된 `loadScript`\n    ```js\n    function loadScript(src, callback) {\n        var script = document.createElement('script');\n        script.src = src;\n\n        script.onload = () => callback(null, script);\n        script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n        document.head.append(script);\n    }\n    ```\n* 에러 처리 기능이 개선된 laodScript 를 사용하는 방법\n    - callback function에 2개의 param을 설정한다.\n        - 첫번째 parameter: error 객체\n        - 두번째 parameter: loadScript로 받고 싶은 script src string 객체\n    ```js\n    loadScript('/my/script.js', function(error, script) {\n                if (error) {\n                    // handle error\n                } else {\n                    // script loaded successfully\n                }\n    });\n    ```\n\n# callback hell\n* callback을 사용해서 비동기 처리가 유용해보인다. 하지만 callback in callback capter에서 확인해볼 떄 callback 안에 callback을 사용함으로 아래 코드와 같이 가독성이 떨어지는 결과를 가지고 옵니다.\n\n* callback hell 예제\n    ```js\n    loadScript('1.js', function(error, script) {        // 첫번째 callback\n\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', function(error, script) {    // 두번째 callback\n                if (error) {\n                    handleError(error);\n                } else {\n                    // ...\n                    loadScript('3.js', function(error, script) {    // 세번째 callback\n                        if (error) {\n                            handleError(error);\n                        } else {\n                            // ...continue after all scripts are loaded (*)\n                        }\n                    });\n\n                }\n            })\n        }\n    });\n    ```\n\n* 이를 해결하기 위해서 아래와 같이 **중첩하는 callback function**으로 callback hell을 만들지 않고 function을 top-level로 나눠 조금더 가독성이 쉽게 구현 할 수 있습니다. \n    ```js\n    loadScript('1.js', step1);\n\n    function step1(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('2.js', step2);\n        }\n    }\n\n    function step2(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...\n            loadScript('3.js', step3);\n        }\n    }\n\n    function step3(error, script) {\n        if (error) {\n            handleError(error);\n        } else {\n            // ...continue after all scripts are loaded (*)\n        }\n    };\n    ```\n* 하지만 step1, 2, 3과 같은 function은 연쇄 작용하는 코드 밖에서 사용할 수 없는 단점이 있습니다. 그래서 이런 점과 callback hell을 피할 수 있는 \"promise, Asynch/await\" 개념을 정리해보겠습니다.\n\n\n# 참고 \n- javascript.info  \nhttps://javascript.info/callbacks#callback-in-callback","excerpt":"예를 들어 화면 페이지에서 scriptLoad하는 과정이 있는데 페이지에서 load하기 전에 load한 파일에 있는 source…","fields":{"slug":"/callback,Promise,async&await_1/"},"frontmatter":{"date":"Feb 16, 2020","title":"callback","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\n* javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다.\n\n```\n목차 \n# excutor: promise\n# 소비자: then, catch, finally\n# 예시: loadScript\n```\n\n# excutor: promise\n\n* \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // executor (제작 코드, \"가수\")\n    });\n    ```\n    - excutor는 아래 콜백 중 하나를 반드시 호출해야 합니다. \n        - resolve(value): 성공적으로 끝난 경우 결과를 value param으로 전달하며 resolve 호출\n        - reject(error): 에러 발생시 에러 객체를 error param으로 전달하며 reject 호출\n\n* new Promise(executor)의 callback 'resolve(value)', 'reject(error)'의 state, result 상태 \n* new Promise 생성자가 반환하는 promise 객체는 다음과 같은 내부 프로퍼티를 갖습니다.\n    - state: 처음엔 \"pending\"(보류)이었다 resolve가 호출되면 \"fulfilled\", reject가 호출되면 \"rejected\"로 변합니다.\n    - result: 처음엔 undefined이었다, resolve(value)가 호출되면 value로, reject(error)가 호출되면 error로 변합니다.\n\n\n* 성공일때 예제(resolve) \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 프라미스가 만들어질 때 executor 함수는 자동으로 실행됩니다.\n\n        // 1초 뒤에 일이 성공적으로 끝났다는 신호와 함께, result가 'done'이 됩니다.\n        setTimeout(() => resolve(\"done\"), 1000);\n    });\n    ```\n\n* 실패일때 예제(reject)\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        // 1초 뒤에 에러와 함께 실행이 종료되었다는 신호를 보냅니다.\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    ```\n\n* resolve/reject 함수 호출 규칙\n    - excutor에 의해서 끝난일은 resolve, reject중 첫번째로 오는 것만 수행됩니다.\n    - 나머지는 무시\n    \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      resolve(\"done\");\n\n      reject(new Error(\"…\")); // 무시됨\n      setTimeout(() => resolve(\"…\")); // 무시됨\n    });\n    ```\n\n\n# 소비자: then, catch, finally\n> 프라미스 객체는 executor(‘제작 코드’ 혹은 ‘가수’)와 결과나 에러를 받을 소비 함수(‘팬’)를 이어주는 역할을 합니다. 소비함수는 .then, .catch, .finally 메서드를 사용해 등록(구독)됩니다.\n\n\n## then\n> excutor가 성공, 실패 한경우를 모두 handling 할 수 있다. \n> then parameter에 두개를 전달해줄 수 있는데 첫번째는 param에 성공 handling function, 두번째는 param에 실패 hanlding function을 전달할 수 있다.\n\n* excutor가 성공적으로 수행한 경우\n    - POINT 주석 참고\n    ```js\n    var promise = new Promise(function(resolve, reject) {\n      setTimeout(() => resolve(\"done!\"), 1000);\n    });\n\n    // POINT: resolve 함수는 .then의 첫 번째 함수(인수)를 실행합니다.\n    promise.then(\n        result => alert(result), // 1초 후 \"done!\"을 출력      \n        error => alert(error) // 실행되지 않음\n    );\n    ```\n    - 아래 와 같이 성공했을때는 작성 가능하다 \n        - then function에 parameter 한개만 전달해주면 된다.\n        ```js\n        var promise = new Promise(resolve => {\n            setTimeout(() => resolve(\"done!\"), 1000);\n        });\n\n        promise.then(alert); // 1초 뒤 \"done!\" 출력\n        ```\n\n* excutor가 에러로 필해한 경우\n    - POINT 주석 참고 \n    ```js\n    var promise = new Promise(function(resolve, reject) {\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    // POINT: reject 함수는 .then의 두 번째 함수를 실행합니다.\n    promise.then(\n        result => alert(result), // 실행되지 않음\n        error => alert(error) // 1초 후 \"Error: 에러 발생!\"를 출력\n    );\n    ```\n\n\n## catch\n> excutor 수행 결과 중 error만 다루고 싶을 때 사용\n\n* 예시\n    - POINT 주석 참고\n    - .catch(f)는 문법이 간결하다는 점만 빼고 .then(null,f)과 완벽하게 동일\n    \n    ```js\n    var promise = new Promise((resolve, reject) => {\n        setTimeout(() => reject(new Error(\"에러 발생!\")), 1000);\n    });\n\n    // POINT\n    // .catch(f)는 promise.then(null, f)과 동일하게 작동합니다\n    promise.catch(alert); // 1초 뒤 \"Error: 에러 발생!\" 출력\n    ```\n\n## finally\n> try... catch에 finally가 있는 것 처럼 promise에도 finally가 있다.\n\n\n* finally 예1  \n    : finally 이후 then을 통해 resolve 결과를 then으로 전달\n    ```js\n    new Promise((resolve, reject) => {\n        setTimeout(() => resolve(\"result\"), 2000)\n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .then(result => alert(result)); // <-- .then에서 result를 다룸\n    ```\n\n* finally 예2  \n    : finally 이후 cath를 통해 \n    ```js\n    new Promise((resolve, reject) => {\n        throw new Error(\"에러 발생!\");\n        // setTimeout(()=>{ reject(new Error('error'))}, 1000); // excutor 처리 시점만 조금 다르고 같은 결과 \n    })\n        // 성공, 실패 여부와 상관없이, 프라미스가 처리되면 실행됨\n        .finally(() => alert(\"Promise ready\"))\n        .catch(err => alert(err)); // <-- .catch에서 에러 객체를 다룸\n    ```\n\n# 예시: loadScript\n* callback에서 loadScript 설명에서 callback hell을 해결 할 수 있는 방법이 promise라고 했는데 그 방법을 소개하겠다.\n\n* promise로 구현한 loadScript\n    ```js\n    function loadScript(src) {\n        return new Promise(function(resolve, reject) {\n            var script = document.createElement('script');\n            script.src = src;\n\n            script.onload = () => resolve(script);\n            script.onerror = () => reject(new Error(`${src}를 불러오는 도중에 에러가 발생함`));\n\n            document.head.append(script);\n        });\n    }\n    ```\n\n* 사용 방법\n    ```js\n    var promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\n    promise.then(\n        script => alert(`${script.src}을 불러왔습니다!`),\n        error => alert(`Error: ${error.message}`)\n    );\n\n    promise.then(script => alert('또다른 핸들러...'));\n    ```    \n    - 설명\n        - loadScript(script)로 스크립트를 읽고, 결과에 따라 그다음(.then)에 무엇을 할지에 대한 코드를 작성하면 되죠.\n    - 비교 \n        - 콜백으로 구현시에 loadScript(script, callback)를 호출할 때, 함께 호출할 callback 함수가 준비되어 있어야 합니다.  \n          loadScript를 호출하기 이전에 호출 결과로 무엇을 할지 미리 알고 있어야 했다.\n    \n\n# 참고 \n- javascript.info  \nhttps://javascript.info/promise-basics\n","excerpt":"javascript info 팬이 가수의 앨범을 사기위해서 아무런 정보 없이 대기 하기 보다는 가수가 앨범을 다만들면 팬들에게 그 소식을 알려 팬이 가수의 앨범을 살수 있다 라는 설명으로 promise로 설명 하고 있습니다. excutor…","fields":{"slug":"/callback,Promise,async&await_2/"},"frontmatter":{"date":"Feb 16, 2020","title":"promise","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n\npromise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다.\n\n# promise chaing 방법 두가지 \n## promise chaining 첫번째 방법(1/2)\n\n* promise객체의 하나에 then을 여러개 연속으로 연결해서 사용하는 방법으로 사슬고리처럼 연결되어 있어 다음 then에 value를 넘겨 줄 수 있습니다.\n    ```js\n        new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000); // (*)\n        }).then(function(result) { // (**)\n            alert(result); // 1\n            return result * 2;\n        }).then(function(result) { // (***)\n            alert(result); // 2\n            return result * 2;\n        }).then(function(result) {\n            alert(result); // 4\n            return result * 2;\n        });\n    ```\n\n\n## promise chaining 두번째 방법(1/2)\n* then을 선언할때마다 promise를 사용해서 선언하게 되면 모든 선언한 then에 pomise의 결과가 전달이 됩니다.\n    ```js\n        var promise = new Promise(function(resolve, reject) {\n            setTimeout(() => resolve(1), 1000);\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n\n        promise.then(function(result) {\n            alert(result); // 1\n            return result * 2;\n        });\n    ```\n\n# 프로미스 반환하기 \n* 아래 예제 설명 \n    - 예시에서 첫 번째 .then은 1을 출력하고 new Promise(…)를 반환((*))합니다.  \n    - 1초 후 이 프라미스가 이행되고 그 결과(resolve의 인수인 result * 2)는 두 번째 .then으로 전달됩니다. \n    - 두 번째 핸들러((**))는 2를 출력하고 동일한 과정을 반복합니다.\n* **프라미스를 반환하는 것도 비동기 작업 체인을 만들 수 있다.**\n\n    ```js\n    new Promise(function(resolve, reject) {\n        setTimeout(() => resolve(1), 1000);\n    }).then(function(result) {\n        alert(result); // 1\n        return new Promise((resolve, reject) => { // (*)\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) { // (**)\n        alert(result); // 2\n        return new Promise((resolve, reject) => {\n            setTimeout(() => resolve(result * 2), 1000);\n        });\n    }).then(function(result) {\n        alert(result); // 4\n    });\n    ```\n\n# 예제: loadScript callback function 해결하기 \n\n    ```js\n    loadScript(\"/article/promise-chaining/one.js\")\n        .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n        .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n        .then(script => {\n            // 스크립트를 정상적으로 불러왔기 때문에, 스크립트 내의 함수를 호출할 수 있습니다.\n            one();      //...one.js에 있는 function \n            two();      //...two.js에 있는 function \n            three();    //...three.js에 있는 function\n        });\n    ```\n\n# fetch와 함께 체이닝 함께 응용하기 \n\n* 프론트 단에선, 네트워크 요청 시 프라미스를 자주 사용합니다. \n* 예시에선 메서드 fetch를 사용해 원격 서버에서 사용자 정보를 가져오겠습니다. \n* fetch는 promise객체를 반환 하기 때문에 fetch로 원하는 정보를 가지고 오고 promise에서 설명한 것 처럼 then을 통해서 후처리를 할 수 있습니다.\n\n    ```js\n    fetch('/article/promise-chaining/user.json')\n        // 원격 서버가 응답하면 .then 아래 코드가 실행됩니다.\n        .then(function(response) {\n            // response.text()는 응답 텍스트 전체가 다운로드되면\n            // 응답 텍스트를 새로운 이행 프라미스를 만들고, 이를 반환합니다.\n            return response.text();\n        })\n        .then(function(text) {\n            // 원격에서 받아온 파일의 내용\n            alert(text); // {\"name\": \"iliakan\", isAdmin: true}\n        });\n    ````\n\n# 참고 \n- javascript.info  \nhttps://javascript.info/promise-chaining","excerpt":"promise객체에 then을 연속적으로 사용할 수 있는 promise chaining에 대해서 설명하겠습니다. promise chaing 방법 두가지 promise chaining 첫번째 방법(1/2) promise객체의 하나에 then…","fields":{"slug":"/callback,Promise,async&await_3/"},"frontmatter":{"date":"Feb 16, 2020","title":"Promise chaning","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# 개발자로 어떻게 살 것인가? \n > 2020년 2월 4년 3개월차 개발자의 고민 작성 \n\n* 개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년 8개월이 지났다. 늦게 시작한 만큼 효율적으로 **목적을 정해두고 목표를 세워 시간을 만회하고 싶어** 작성하기 시작했다.\n\n\n\n# 목적 \n> fw/lib 익혀 비즈니스 개발에만 그치지 않고 CTO 성향을 가진 개발자  \n> 인문학도 공부하며 커뮤니케이션에 원활한 사람  \n> 사회/정치에도 관심을 두면서 개발자로서 그사이에 내가 해야 할 일을 고민하기  \n\n* FW/LIB 익혀 비즈니스 개발에 그치지 않고 원리를 알고 개발하며 나아가 **'설계, 성능, 보안, 설계에 관심을 두고, product level로 만들 수 있는 능력, 문제가 있을때 어디가 통찰력 있게 해결할 수 있는 능력, 지식 습득을 교양을 쌓는다고 여기며 꾸준하게** 할 수 있는 개발자가 되고 싶다. \n\n* 위 능력을 갖추면서 \"이슈\"가 생겼을 때 **먼저 나서서** 처리 할 수 있는 능력을 갖추고 싶다.\n\n\n# 목표 \n> 지속적으로 작성 계획\n\n## javascript개념을 정리하게된 계기\n* 그동안 공부해온 것을 정리하고 그다음으로 넘어가고 싶었다. \n    한 언어를 깊게 공부하고 싶었다. \n    - 이유는   \n    : 다른 언어를 배우더라도 내가 아는 개념과 뭐가 다르고 같은지 비교/생각해가며 공부하면 더 재밌고 수월할 것 같다고 생각했기 때문이다.  \n    : react, node를 사용해 toy project를 진행하며 Javascript를 느낄 수 있을 정도로 알고 싶었다.  \n    : 이슈 해결을 수월하고 더 재미있는 개발, 더 좋은 퍼포먼스를 낼 수 있을 거라고 느꼈다.\n    : Javascript를 정리해야 그다음 단계(설계, lib, fw)로 넘어갈 수 있는 자격이 주어지는 거라고 스스로 생각해서 꼭 해야겠다고 생각했다.\n\n## 그래서 그다음단계는? \n* 코드스피츠에서 front-end 관련해서 design pattern과 view Pattern을 정리/ project 완료하기  \n* react, node로 toy project 한 것 정리/ 확장\n    - 사용한 기술 정리를 통해서 공식 라이브러리 확인하기\n    - 스스로 개발지식을 습득하고 적용하는 연습\n* 알고리즘 문제를 풀면서 생각하는 연습을 지속해서 연습\n\n","excerpt":"개발자로 어떻게 살 것인가? 2020년 2월 4년 3개월차 개발자의 고민 작성  개발자 경력은 4년 3개월 차 개발자이지만 2017년 여름 본격적으로 개발 공부를 교양 쌓는다고 여기며 시작한 지 갓 1년…","fields":{"slug":"/개발자로 어떻게 살 것 인가/"},"frontmatter":{"date":"Feb 12, 2020","title":"개발자로 어떻게 살 것 인가?","tags":["생각정리"]}}},{"node":{"rawMarkdownBody":"\n자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.\n\n\n```js\n\t1 클래스와 인스턴스의 개념 이해\n\t2 자바스크립트의 클래스\n\t3 클래스 상속\n\t\t3-1 기본 구현\n\t\t3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n\t\t3-3 constructor 복구 하기 \n\t\t3-4 상위 클래스에 접근 수단 제공\n\t4 ES6의 클래스 및 클래스 상속\n\n```\n# 1 클래스와 인스턴스의 개념 이해\n* 클래스\n    - **공통 속성, 기능 정의한 추상적 개념**\n    - 클래스를 바탕으로 인스턴스를 만들 때 비로소 어떤 객체가 클래스의 속성을 지닌다.\n    - 어떤 인스턴스가 다양한 클래스에 속할 수는 있지만 이 클래스들은 모두 인스턴스 입장에서는 '직계존속'\n    - 다중상속을 지원하는 언어이든 그렇지 않은 언어이든 결국 인스턴스를 생성할 때 호출할 수 있는 클래스는 오직 하나뿐일 수 밖에 없기 때문\n\n* 인스턴스\n    - 클래스에 속한 객체 \n\n* static member(static method, static properties)\n    - 클래스 자체에서만 동작\n* prorotype method\n    - 인스턴스에서 활용 가능\n\n# 2 자바스크립트의 클래스\n\n* 생성자 함수 Array를 new연선자와 함께 호출하면 인스턴스 생성 하는 과정을 통한 설명\n    - Array를 일종의 클래스라고 하면, **Array의 prototype 객체 내부 요소들이 인스턴스에 '상속'**된다고 볼 수 있다. \n        - **엄밀하게 상속이 아닌 프로토타입 체이닝에 의한 참조지만 결과적으로 동일하게 동작**\n    - ***한편 Array 내부 프로퍼티들 중 prorotype 프로퍼티를 제외한 나머지 인스턴스에 상속되지 않는다.***  \n    (=== static member: static method, static properties)\n\n    - 인스턴스에 상속되는지(인스턴스가 참조하는지) 여부에 따라 **\"static member\"(상속불가능)**와 **\"instance member\"(상속가능)**로 나뉜다.\n        - 이 분류는 다른 언어의 클래스 구성요소에 대한 정의를 차용한것으로 클래스 입장에서 사용대상에 따라 구분한것 \n        - 하지만 **자바스크립트는 다른 언어와 달리 인스턴스에서도 직접 메서드를 정의할 수 있다.**\n        - 그래서 '인스턴스 메서드'라는 명칭은 프로토타입에 정의한 메서드를 지칭하는 것인지 인스턴스에 정의한 메서드를 지칭하는것인지 혼란이 올 수 있다.  \n        따라서 **프로토타입에 정의한 메서드를 프로토타입 메서드라고 부른다.**\n\n\n    - 도식화 - Array constructor function\n    ![](class&instance.jpg)\n\n    - 도식화 - prorotype, \\_\\_proto__, instance\n    ![](class&instance2.jpg)\n\n*  실제 예제\n```js\n    function Person(name, age){\n        this._name = name;\n        this._age = age;\n    }\n\n    Person.getInformations = function(inst){    //Static emthod\n        return{\n            name: inst._name,\n            age: inst._age\n        };\n    }\n    Person.prototype.getName = function(){      //(prototype) method\n        return this._name;\n    }\n    Person.prototype.getAge = function(){       //(prototype) method\n        return this._age;\n    }\n\n\n    var yoon = new Person(\"happyjy\", 30);\n    console.log(yoon.getName());    //happyjy\n    console.log(yoon.getAge());     //30\n\n    console.log(yoon.getInformations(yoon));    \n    //에러! yoon.getInformations is not a function\n    //생성자 함수 property(getInformations)에는 인스턴스가 직접 접근하지 못한다.\n    //생성자 함수 property는 인스턴스로 상속할 수 있는 프로퍼티로 만들지 않는다.\n    console.log(Person.getInformations(yoon)); //{name: \"happyjy\", age: \"30\"}\n    //생성자 함수 property는 생성자 함수로만 접근이 가능하다.\n```\n\n\n# 3 클래스 상속\n## 3-1 기본 구현\n* 구현 point\n    1. 프로토타입 설정\n    2. contsructor 복구\n\n    ```js\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.name = name || '홍길동(setting by Employee function)';\n        this.age = age || 0;\n        this.position = position || '미정';\n    };\n\n    //1.prorotype 설정\n    Employee.prototype = new Person();      // 이 코드에 의해서 new Employee에 의해서 생성된 인스턴스.__proto__에 Person 인스턴가 세팅된다.\n    //2. constructor 복구\n    Employee.prototype.constructor = Employee;  // prototype에서 다뤘던 내용\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    };\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n- mac의 결과 값\n    - ***문제: mac.\\_\\_proto__에 추상적이어야할 클래스 prorotype 담겨 있는 것***\n    - 만약 delete mac.name이후 mac.getName을 하면 undefined가 return 되어야 하는데 prototype chain에 의해서 홍길동(mac.__proto__ property)이 반환된다.\n    - 그래서 아래 예제 \"prototype\"로 상속 구현하기에 extendClass에 의해서 문제를 해결할 수 있다. \n        - 문제 해결 방법 요약: 상속할때 parent, child class 사이에서 extend해주는 개념이 필요하다  \n        : 아래 3-2, 3-3, 3-4 capter에서 다루도록 하겠다.\n\n    ![](Employee상속.png)\n\n\n\n## 3-2 클래스가 구체적인 데이터를 지나지 않게 하는 방법\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **1,2번** 참고 \n\n## 3-3 constructor 복구 하기 \n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **3번** 참고 \n\n## 3-4 상위 클래스에 접근 수단 제공\n* 아래 도식화(extend Class 구현 개념)에서 빨간색 동그라미 **4번** 참고 \n\n* extend Class 구현 개념\n    - 아래 구현 예제 주석 1,2,3,4번 코드 참고\n![](extendClass.jpg)\n\n* extendClass구현으로 prototype상속 구현\n\n    ```js\n    //* es5에서 많이 사용해서 아래와 같이 클래스 상속을 구현 \n    //* 클로저를 생성해서 'Bridge'를 단한번만 사용할 수 있게 함 \n    var extendClass = (function(){\n        function Bridge(){}\n        return function(Parent, Child){\n            Bridge.prototype = Parent.prorotype;  //1번\n            Child.prototype = new Bridge();       //2번\n            Child.prototype.constructor = Child;  //3번\n            Child.prototype.superClass = Parent;  //4번\n        }\n    })();\n\n    function Person(name, age){\n        this.name = name || '홍길동';\n        this.age = age || 0;\n    }\n    Person.prototype.getName = function(){\n        return this.name;\n    }\n    Person.prototype.getAge = function(){\n        return this.age;\n    }\n\n    function Employee(name, age, position){\n        this.superClass(name, age); //4번: 하위 클래스에서 이런 호출로 상위 클래스가 설정한 프로퍼티 세팅 가능\n        this.position = position || '미정'\n    }\n\n    \n    extendClass(Person, Employee);\n    Employee.prototype.getPosition = function(){\n        return this.position;\n    }\n\n    var mac = new Employee('mac', 30, 'CTO');\n    ```\n* 결과 \n![](extendClass적용.png)\n\n* 짚고 넘어가자! - this.superClass에 대해서 \n    - this.superClass는 Parent object이기 때문에 Person constructor function에서 name, age설정\n    - Person constructor function에서 this.name, this.age에 설정 시 this scope은 \"Employee instance object\"라서 위 결과 처럼 name, age가 Employee instance property에 설정 된다.\n\n\n# 4 ES6의 클래스 및 클래스 상속\n* class로 상속 구현하기\n```js\n    class Person {\n        constructor (name, age) {\n            this.name = name || '아무개';\n            this.age = age || '0';\n        }\n\n        getName(){\n            return this.name;\n        }\n\n        getAge(){\n            return this.age;\n        }\n    }\n\n    class Employee extends Person {\n        constructor (name, age, position){\n            super(name, age);\n            this.position = position || '미정';\n        }\n        getPosition(){\n            return this.position;\n        }\n\n    }\n```\n\n\n# 참고 \n* 코어 자바스크립트","excerpt":"자바스크립트는 프로토타입 기반 언어라 '상속' 개념이 존재 하지 았는데\n다른 언어의 class와 비슷하게 동작하게 하는 'class'문법이 ES6에 추가 됐다.…","fields":{"slug":"/class/"},"frontmatter":{"date":"Feb 11, 2020","title":"class","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\njavascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자. \n\n\n```js\n\t1 프로토타입의 개념 이해 \n\t\t1-1 constructor, prototype, instance\n\t\t1-2 constructor 프로퍼티\n\t2 프로토타입 체인\n\t\t2-1 메서드 오버라이드\n\t\t2-2 프로토타입 체인\n\t\t2-3 객체 전용 메서드의 예외사항\n\t\t2-4 다중 프로토타입 체인\n```\n\n# 1 프로토타입의 개념 이해 \n# 1-1 Constructor, prototype, instance\n\n* Constructor\n    - A function that initializes an object\n    - similar to normal javaconstuctor\n* prototype\n    - Constructor의 property\n    - instance의 property \\_\\_proto__과 메모리 공유  \n    : constructor.prototype === instance.\\_\\_proto__\n* instance\n    - Constructor를 new키워드로 호출로 생성한 객체\n\n* prototype 도식\n    ![](프로토타입도식.jpg)\n    * 왼쪽 꼭짓점: Constructor(생성자 함수)\n    * 오른쪽 꼭짓점: Constructor.prorotype 프로퍼티\n    * new를 통해 instance 생성\n    * instance.\\_\\_proto__\n\n* 어떤 생성자 함수(Constructor)를 new 연산자와 함께 호출하면\n    * Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스(instance)가 생성됩니다.\n    * 이때 instance에는 \\_\\_proto__라는 프포퍼티가 자동으로 부여\n    * 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조\n\n* prototype 개념의 핵심: prototype 프로퍼티, \\_\\_proto__라는 프로퍼티\n    * **prototype은 객체**\n    * **이를 참조하는 \\_\\_proto__도 객체**\n    * prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장\n    * 그러면 인스턴스에서도 숨겨진 프로퍼티인 \\_\\_proto__를 통해서 이 메서들을 접근할 수 있게 된다.\n\n    ```js\n    var Person = function(name) {\n        this._name = name;\n    }\n\n    Person.prototype.getName = function(){\n        debugger;\n        return this._name;\n    }\n\n    //---\n    typeof Person                   // function\n    typeof new Person('boa');       // object\n    new Person('boa');              // Person {_name: 'boa'}\n    new Person('boa').__proto__     // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    Person.prototype                // {getName: f, constructor: f} -> constructor는 위 Person function 입니다.\n    //---\n    \n    var boa = new Person('boa');\n    boa.__proto__.getName();    //undefined\n    boa.getName();              //boa\n    /*\n        boa.__proto__에 _name 프로퍼티가 없어 식별자(this._name)를 찾을 수 없다.\n        * boa.__proto__.getName();, boa.getName(); \n            - getName이 호출 돼 scope에 있는 this가 서로 다르다. 그래서 결과 값이 다르다.\n            - boa.__proto__ this -> {getName: f, constructor: f}\n            - boa this ->  Person {_name: 'boa'} \n\n    */\n\n    Person.prototype === boa.__proto__;\n    /*\n        Constructor function의 prototype으로 생성한 instnace 'boa'의 property '__proto__'객체는 Consytructor function의 객체는 메모리를 공유하고 있다.\n\n        이런 특징으로 \n        instance.__proto__ property를 변경하면 Constructor.prototype도 변경이 된다.\n        즉 instance.__proto__, Constructor.prototype 객체는 메모리를 공유하고 있따. \n    */\n\n    var boa = new Person('boa');\n    boa.__proto__._name = 'boa.__proto__';\n    boa.__proto__.getName() =               //Boa__proto__\n    /*\n        * boa.__proto__.getName() 에 의해서 호출된 getName의 this는 boa.__proto__\n        * \n    */\n\n    //---\n    \n    var iu = new Person('iu');\n    iu.getName(); // iu\n    \n    /*\n        iu.__proto__.getName \n        = iu(.__proto__).getName\n        = iu.getName\n    */\n\n\n    //---\n\n    var Constructor = function(name) {\n        this.name = name;\n        console.log(this);\n    }\n\n    Constructor.prototype.method = function(){};\n    Constructor.prototype.prototype1 = 'constructor Prototype property';\n\n    var instance = new Constructor('INSTANCE');\n    console.dir(Constructor);\n    console.dir(instance);\n    /*\n        Constructor.prototype === instance.__proto__\n    */\n\n\n    //--\n    var arr = [1,2];\n    console.dir(arr);\n    console.dir(Array);     //Array: 내장 생성자 함수\n\n    arr.forEach(function(){});  //\n    Array.isArray(arr);         //true\n    arr.isArray()               //TypeError: arr.isArray is not a function\n\n\n    ```\n\n# 1-2 constructor 프로퍼티\n\n```js\n    var arr = [1,2];\n    Array.prototype.constructor === Array;\n    arr.__proto__.constructor === Array;\n    arr.constructor === Array;\n\n    var arr2 = new arr.constructor(3,4);\n    console.log(arr2) //[3,4]\n```\n\n\n```js\nvar Person = function(name){\n    this.name = name;\n}\n\nvar p1 = new Person('인간1');                           //Person {name:\"인간1\"} true\nvar p1Proto = Object.getPrototypeOf(p1);\n\nvar p2 = new Person.prototype.constructor('인간2');     //Person {name:\"인간2\"} true\nvar p3 = new p1Proto.constructor('인간3');              //Person {name:\"인간3\"} true\nvar p4 = new p1.__proto__.constructor('인간4');         //Person {name:\"인간4\"} true\nvar p5 = new p1.constructor('인간5');                   //Person {name:\"인간5\"} true\n\n[p1, p2, p3, p4, p5].forEach(function(p){\n    console.log(p, p instanceof Person);\n})\n\n[constructor]\n[instance].__proto__.constructor\n[instance].constructor\nObject.getPrototypeOf([instance]).constructor\n[Contsructor].prototype.constructor\n\n[Constructor]\n[instance].__proto__\n[instance]\nObject.getPrototypeOf([instance])\n\n```\n\n# 2 프로토타입 체인\n\n# 2-1 메서드 오버라이드\n\n* 예제 \n    - 아래 메서드 오버라이드 전, 후 캡쳐 참고\n        ```js\n        var Person = function(name){\n            this.name = name;\n        }\n        Person.prototype.getName = function(){\n            return this.name;\n        }\n\n        var boa = new Person('보아');\n        boa.getName = function(){\n            return '이 사람은 ' + this.name;\n        };\n\n        console.log(boa);               // Person {name: \"보아\", getName: ƒ}\n        console.log(boa.getName());     // 이 사람은 보아\n\n        console.log(boa.__proto__.getNam());    // undefined\n        Person.prototype.name = '권보아';\n        console.log(boa.__proto__);             // {name: \"권보아\", getName: ƒ, constructor: ƒ}\n        console.log(boa.__proto__.getName());   // 이사람은 권보아\n        console.log(boa.__proto__.getName.call(boa));   // this를 명시적으로 선언\n        /*\n            메서드가 오버라이드된 경우에는 자신으로부터 가장 가까운 메서드에만 접근\n            그다음으로 가까운 __proto__의 메서드도 우회적인 방법을 통해서 접근 가능\n        */ \n        ```\n* 결과\n    - override 하기 전\n    ![](method_override.png)\n    \n                             \n    - override 후\n    \n    ![](method_override1.png)\n\n# 2-2 프로토타입 체인\n* Object의 내부 구조\n\n![](prototypeOfObject.png)\n\n* Array의 내부 구조\n![](prototypeOfArray.png)\n\n\n* Array 내부 도식화\n![](Array내부도식화.jpg)\n    - [1,2]는 Array.prototype, Object.prototype내부의 메서드를 자신의 것처럼 실행 할 수 있다. \n    - .\\_\\_proto__는 생략 가능하다\n    - 예시\n\n        ```js\n        var arr = [1,2];\n        arr(.__proto__).push(3);                            //3\n        arr(.__proto__)(.__proto__).hasOwnProperty(2);      //true\n        ```\n\n* 메서드 오버라이드와 프로토타입 체이닝\n\n```js\nvar arr = [1,2,3];\nArray.prototype.toString.call(arr);     //1,2,3\nObject.prototype.toString.call(arr);    //[object Array]\narr.toString();                         //1,2,3\n\narr.toString = function(){      //결과 아래 캡쳐 참고 \n    return this.join('_');\n};\narr.toString();                         //1_2_3\n```\n\n* arr 객체에 toString function 추가시 arr객체 내부\n\n    ![](Array객체에toString추가.png)\n\n\n# 2-3 객체 전용 메서드의 예외사항\n\n* Object.prototyp에 추가한 메서드의 접근\n    ```js\n    Object.prototype.getEntries = function(){\n        var res = [];\n        for (var prop in this){\n            if(this.hasOwnProperty(prop)){\n                res.push([prop, this[prop]]);\n            }\n        }\n        return res;\n    }\n\n    var data = [\n        ['object', {a: 1, b: 2, c:3}],\n        ['number', 345],\n        ['string', 'abc'], \n        ['boolean', false],\n        ['func', function(){}],\n        ['array', [1,2,3,4]]\n    ];\n\n    data.forEach(function(d){\n        console.log(d[1].getEntries());\n    })\n\n    ```\n    - 어떤 데이터 타입이건 거의 무조건 프로토타입 체이닝을 통해 getEntries 메서드에 접근 \n\n\n* 스태틱 메서드(객체한정메서드)\n    - 객체만을 대상으로 동작하는 객체 전용메서드들은 부득이 Object.prototype이 아닌 Object에 스태틱 메서드(static method)로 부여할 수 밖에 없다.\n    - 생성자 함수인 Object, 인스턴스 객체 리터럴 사이에는 this를 통한 연결이 불가능\n    - 전용 메서드 처럼 '메서드명 앞의 대상이 곧 this'가 되는 방식대신  \n    this의 사용을 포기하고 대상 **인스턴스를 인자로 직접 주입해야 하는 방식**으로 구현  \n    : 예시 Object.freeze({prop: 42})\n    - Object.prototype.consructor 하위 메서드 & Object.protptype 하위 메서드\n     ![](객체전용메서드&스태틱메서드.jpg)\n\n# 2-4 다중 프로토타입 체인\n* 새롭게 만드는 생성자 함수에 \\_\\_proto__를 연결해서 체인 관계를 만들수 있다.\n\n* Grade 생성자 함수와 인스턴스\n    ```js\n    var Grade = function(){\n        //arguments: 유사배열\n        var args = Array.prototype.slice.call(arguments);\n        for(var i=0; i<args.length; i++){\n            this[i] = args[i];\n        }\n        this.length = args.length;\n    }\n    var g = new Grade(100, 80);\n\n    Grade.prototype = [];   //POINT\n\n    var g1 = new Grade(10, 20);\n    g1.push(1);\n    console.log(g1);    //Grade(3) [10, 20, 1]\n    g1.shift()\n    console.log(g1);    //Grade(3) [20, 1]\n\n    ```\n    - 도식화 \n    ![](Grade생성자함수에배열proto.jpg)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"javascript언어는 prototype을 기반으로 oop를 구현하고 있다. \n(클래스 기반의 oop를 구현한 언어도 있다.)\nprototype 기반의 언어가 어떻게 oop를 구현 하고 있는지 알아보도록 하자.  1 프로토타입의 개념 이해 1-…","fields":{"slug":"/prototype/"},"frontmatter":{"date":"Feb 08, 2020","title":"prototype","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다. \n\n\n```js\n\t1 클로저의 의미 및 원리 이해\n\t2 클로저와 메모리 관리\n\t3 클로저 활용사례\n\t\t3-1 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때 \n\t\t3-2 접근 권한 제어(정보 은닉)\n\t\t3-3 부분 적용함수\n\t\t3-4 커링함수\n```\n\n\n# 1 클로저의 의미 및 원리 이해\n\n\n* 클로저란?  \n  : 함수형 프로그래밍 언어에서 등장하는 특징\n    > 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 **실행 컨텍스트가 종료된 이후에도 변수a가 사라지지 안는 현상**\n    > 내부함수를 외부로 전달하는 방법: 함수를 return하는 경우, callback으로 전달\n    - mdn 설명\n    > A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).  \n    > In other words, a closure gives you access to an outer function’s scope from an inner function. \n    > In JavaScript, closures are created every time a function is created, at function creation time.\n    \n\n* 외무 함수의 변수를 참조하는 내부 함수(1)\n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    outer();\n    ```\n    * inner함수 내부에서는 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못하므로 outerEnvironmentReference에 지정된 상위 컨텍스트인 outer의 LexicalEnvironment에 접근해서 다시 a를 찾는다. \n    * outer함수의 실행 컨텍스트가 종료되면 LexicalEnvironmentReference에 저장된 식별자들(c, inner)에 대한 참조를 지운다. \n        - 각 주소에 저장돼 있던 값들은 자신을 참조하는 변수가 하나도 없게 되므로 가비지 **컬렉터의 수집 대상**이된다.\n    * inner function안에서 closure 영역에 있는 변수는 'c' 하나 뿐이다. c1처럼 변수 선언만 하고 할당하지 않으면 메모리에 올라오지 않는다. \n\n* 외무 함수의 변수를 참조하는 내부 함수(2): outer 함수의 실행컨텍스트가 종료된 후 inner 함수를 호출하면?  \n    ```js\n    var outer = function() {\n        var c = 1;\n        var c1\n        var inner = function() {\n            console.log(++c);\n        }\n        inner();\n    };\n    var excuteInnerFunc = outer();\n    consl.log(excuteInnerFunc); // 2\n    consl.log(excuteInnerFunc); // 3\n    ```\n    * inner함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없습니다.\n    * outerEnvironmentReferenece에는 inner함수가 선언된 위치의 LexicalEnvironment가 참조복사\n    * inner함수는 outer함수 내부에서 선언됐으므로, outer함수의 Lexicalenvironment가 담김\n        - 위 단계로 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 그 값인 2를 반환\n        - inner함수의 실행 컨텍스트가 종료\n    * excuteInnerFunc를 두번째 호출하게 되면 위 단계를 걸쳐  2->3으로 증가한다.\n\n    * ***주의할점***\n        > inner함수의 실행시점에는 outer함수는 이미 실생 종료된 상태인데 outer함수의 Lexicalenvironment에 어떻게 접근할 수 있는걸까? \n        - 가비지 컬렉터의 동작 방식때문\n        - 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함시키지 않습니다.\n        - 언젠가 inner함수의 실행컨텍스트가 활성화 되면 outerEnvironmentReferenece가 outer함수의 Lexicalenvironment를 필요로 할 것이므로 수집 대상에서 제외\n            - 그래서 inner함수 c 변수에 접근 가능\n\n* return 없이도 클로저가 발생하는 다양한 경우\n    ```js\n    (function(){\n        var a = 0 ;\n        var intervalId = null;\n        var inner = function() {\n            if (++a>9) {\n                clearInterval(intervalId);\n            }\n            console.log(a);\n        };\n        intervalId = setInterval(inner, 1000);\n    })()\n\n    // clouser&eventListener\n    (function(){\n        var count = 0;\n        var button = document.createElement('button');\n        button.innerText = 'click';\n        button.addEventListener('click', function(){\n            console.log(++count, 'times clicked');\n        });\n        document.body.appendChild(button);\n    })()\n    ```\n    ![clouser&eventListener](clouser&eventListener.png)\n\n# 2 클로저와 메모리 관리\n* 객체지향, 함수형 모두를 아우르는 중요한 개념\n* 클로저는 메모리 소모가가 있지만 이런 특성을 정확히 이해하고 잘 활용하도록 노력해야한다.     \n\n* closure를 GC가 수거하게 하는 방법\n    - 3장 예시에 POINT 주석 3개 참고   \n    ```js\n        //1번째 예시\n        var outer = function() {\n            var c = 1;\n            var c1\n            var inner = function() {\n                console.log(++c);\n            }\n            inner();\n        };\n        outer();\n        outer = null;   // POINT: outer실별자의 inner 함수 참조를 끊음\n        \n\n        //2번째 예시\n        (function(){\n            var a = 0 ;\n            var intervalId = null;\n            var inner = function() {\n                if (++a>9) {\n                    clearInterval(intervalId);\n                    inner = null;             // POINT: inner식별자의 함수 참조를 끊음  \n                }\n                console.log(a);\n            };\n            intervalId = setInterval(inner, 1000);\n        })();    \n\n        \n        //3번째 예시\n        // clouser&eventListener\n        (function(){\n            var count = 0;\n            var button = document.createElement('button');\n            button.innerText = 'click';\n\n            var clickHandler = function(){\n                //console.log(++count, 'times clicked');\n                if( ++count > 9 ){\n                    clickHandler = null;  //POINT: clickHandler 식별자 함수 참조를 끊음\n                }\n            };\n\n            button.addEventListener('click', clickHandler);\n            document.body.appendChild(button);\n        })()\n    ```\n\n# 3 클로저 활용사례\n\n## 3-1 Event Listener(콜백 함수 내부에서 외부 데이터를 사용하고자 할 때)\n\n* event Listener callback function\n    ``` js\n        var colorList = ['red', 'blue', 'white'];\n        var $ul = document.createElement('ul');\n\n        colorList.forEach(function(color){                  //(A)\n            var $li = document.createElement('li');\n            $li.innerText = color;\n            $li.addEventListener('click', function(){       //(B)\n                alert('your choice: ', color);\n            });\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n    ```\n    * (B)는 color라는 **클로저**가 있다. \n    * (A)는 colorList만큼의 **'실행 컨텍스트가 활성화 됨'**\n    * (B) outerEnvironmentReferenece가 (A)의 LexicalEnvironment참조  \n       -> **(B)함수가 참조할 예정인 변수 color에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능**\n\n\n* event Listener callback function에 bind 사용\n```js\n    var $ul = document.createElement('ul');\n    var colorList = ['red', 'blue', 'white'];\n    var consoleColor = function(color){\n        if(this === window){\n            //POINT3, POINT2\n            console.log('### this is window -> ' + this + \"/// callback function param: \" + color);\n            console.log(this);      //<li>blue</li>\n            console.log(color);     //MouseEvent\n            console.log('--------------------')\n        } else {\n            //POINT1\n            console.log('### this is HTMLElement -> this Value:' + this + \"/// callback function param: \" + color);\n            console.log(this);      //window\n            console.log(color);     //blue\n            console.log('====================')\n        }   \n    }            \n    \n    colorList.forEach(function(fruit){\n        var $li = document.createElement('li');\n        $li.innerText = fruit;\n        $li.addEventListener('click', consoleColor);                        //POINT 1: eventListener의 this, 첫번째 파라미터는 각각 '클릭한 dom', 'MouseEvent' 객체들이다.\n        $li.addEventListener('click', consoleColor.bind(this, fruit));      //POINT 2: forEach의 callback function에서 this는 windown!/ fruit는 clousre! \n        $ul.appendChild($li);\n    });\n    document.body.appendChild($ul);\n    \n    consoleColor(colorList[2]);                                             //POINT 3\n```\n    ![](callbackEg_EventListener.png)\n    \n    * POINT1,2,3의 consoleColor function의 console 확인 필요 \n    * POINT1,2의 this, 첫번째 param을 다시 상기 시켜보자.\n    * POINT2의 제약사항  \n        **- 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라지는 점은 감안해야한다.**\n\n        \n* event Listener에 고차 함수 사용\n    - 함수형 프로그램밍에서 자주 쓰이는 방식\n\n    ```js\n        var $ul = document.createElement('ul');\n        var colorList = ['red', 'blue', 'white'];\n        var consoleColor = function(color){\n            return function(){\n                console.log(color)\n            }\n        }            \n        \n        colorList.forEach(function(fruit){\n            var $li = document.createElement('li');\n            $li.innerText = fruit;\n            $li.addEventListener('click', consoleColor(fruit));\n            $ul.appendChild($li);\n        });\n        document.body.appendChild($ul);\n        \n    ```\n\n## 3-2 접근 권한 제어(정보 은닉)\n\n```js\n    var outer = function(){\n        var a = 1;                  //closure\n        var inner = function(){\n            return ++a;\n        }\n        return inner;\n    }\n    var outer2 = outer();\n\n    console.log(outer2());\n    console.log(outer2());\n```\n\n* outer함수는 외부(전역 스코프)로부터 철저하게 격리\n* 외부에서는 외부 공간에 노출돼 있는 outer라는 변수를 통해 outer함수를 실행할 수 있지만  \n, outer함수 내부에는 어떠한 개입도 할 수 없다.\n* **외부에서는 오직 outer함수가 return한 정보에만 접근할 수 있다.** (== return 값이 외부에 정보를 제공하는 유일한 수단)\n\n## 3-3 부분 적용함수\n\n```js\nvar add = function(){\n    var result = 0;\n    for(var i = 0; i < arguments.length; i++){\n        result += arguments[i];\n    }\n    return result;\n};\nvar addPartial = add.bind(null, 1,2,3,4,5);\nconsole.log(addPartical());             //15\nconsole.log(addPartial(6,7,8,9,10));    //55\nconsole.log(addPartical(10));           //25\n\n```\n## 3-4 커링함수\n* 여러 인자를 받은 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성\n\n* curring function eg\n    ```js\n\n    var curryFuncTest = function (func){\n        debugger;\n        return function(a){\n            debugger;\n            return function(b){ // getMaxWith10, getMinWith10 funciton\n                debugger;\n                return func(a,b);\n            };\n        };\n    };\n\n\n    var getMaxWith10 = curryFuncTest(Math.max)(10);\n    console.log(getMaxWith10(8));\n    console.log(getMaxWith10(25));\n\n    var getMinWith10 = curryFuncTest(Math.min)(10);;\n    console.log(getMinWith10(8));\n    console.log(getMinWith10(25));\n\n    ```\n![curryfunciton](curryfunction.png)\n\n* curring function with arrow function\n\n    ```js\n        var curryFuncTestWithArrowFunc = func => a => b => func(a,b);\n        var getMaxWith10WithArrowFunc = curryFuncTestWithArrowFunc(Math.max)(10);\n        console.log(getMaxWith10WithArrowFunc(8));\n        console.log(getMaxWith10WithArrowFunc(25));\n    ```\n\n* curring function 실제 사용 예\n\n    ```js\n    var getInfomation = function(baseUrl){                      // 서버에 요청할 주소의 기본 URL\n        return function (path) {                                // path값\n            return function (id) {                              // id    \n                return fetch(baseUrl + path + '/' + id);        // 실제 서버에 정보 요청\n            };\n        };\n    };\n\n    var getInformation = baseUrl => path => id => fetch(baseUrl + path + '/' + id);\n    var imageUrl = 'http://imgAddr.com/';\n\n    // 이미지 타입별 요청 함수 준비\n    var getImage = getInformation(imageUrl);    //http://imgAddr.com/\n    var getEmoticon = getImage('emoicon');      //http://imgAddr.com/emoticon\n    var getIcon = getImage('icon');             //http://imgAddr.com/icon\n\n    //실제 요청\n    var emoticon1 = getEmoticon(100);       //http://imgAddr.com/emoticon/100\n    var emoticon2 = getEmoticon(200);       //http://imgAddr.com/emoticon/200\n    var icon1 = getIcon(10);                //http://imgAddr.com/icon/10\n    var icon2 = getIcon(20);                //http://imgAddr.com/icon/20\n\n    ```\n\n    * 이런 이유로 최근 여러 프레임워크, 라이브러리 등에서 커링을 상당히 광범위하게 사용하고 있다.\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"업무를 하다가보면 closure 영역을 나도모르게 많이 사용하고 있다는 걸 정리하면서 생각이 들었다. (위젯 define option, setTimeout, IIFE 에서도...)\n그런 closure에 대해서 정리를 해보겠다.…","fields":{"slug":"/closure/"},"frontmatter":{"date":"Feb 05, 2020","title":"closure","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n```\n# 목차\n    * call() 정의\n    * call()을 생성자 연결에 사용\n    * call()을 익명함수와 함께 쓰기 \n    * call()호출시 this에 특정 값을 넣어 동작하기\n    * call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n    * call, apply함수의 비교(this에 특정 값 넣어 동작)\n    * bind()\n    * bind()함수 구현 해보기\n    * creating a bound function\n    * Partially applied functions\n    * with setTimeout()\n```\n\n# call() 정의\n> 주어진 this 값, 전달된 인수 와 함께 함수를 호출\n\n```js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = 'food';\n}\n\nconsole.log(new Food('cheese', 5).name);\n// expected output: \"cheese\"\n```\n\n# call()을 생성자 연결에 사용\n> function, method에 속해서 다른 객체를 호출한다.  \n> function, method에 this 값을 전해준다.  \n함수는 한번 쓰고 다른 객체에서 상속 받아 사용한다.(method를 다시 만들 필요 없이)\n``` js\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price < 0) {\n    throw RangeError('Cannot create product ' +\n                      this.name + ' with a negative price');\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'food';\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);  //Product function을 재사용\n  this.category = 'toy';\n}\n\nvar cheese = new Food('feta', 5);\nvar fun = new Toy('robot', 40);\n```\n\n\n# call()을 익명함수와 함께 쓰기 \n```js\nvar animals = [\n  { species: 'Lion', name: 'King' },\n  { species: 'Whale', name: 'Fail' }\n];\n\nfor (var i = 0; i < animals.length; i++) {\n  (function(i) {\n    this.print = function() {\n      console.log('#' + i + ' ' + this.species\n                  + ': ' + this.name);\n    }\n    this.print();\n  }).call(animals[i], i);\n}\n//## 결과 \n//#0 Lion: Kinf\n//#1 Whale: Fail\n```\n\n# call()호출시 this에 특정 값을 넣어 동작하기\n> \n\n```js\nfunction greet() {\n  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n  console.log(reply);\n}\n\nvar obj = {\n  animal: 'cats', sleepDuration: '12 and 16 hours'\n};\n\ngreet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n# call() 호출시 첫번째 인자값 넣지 않고 동작하기 \n> call로 호출될 function 안에 this의 bound는 global object이다  \n> 하지만 use stric을 사용 하용하면 undefined가 나온다. \n```js\nvar sData = 'Wisen';\n            \nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call();  // sData value is Wisen \n\n``` \n\n```js            \n'use strict';\n\nvar sData = 'Wisen';\n\nfunction display() {\n  console.log('sData value is %s ', this.sData);\n}\n\ndisplay.call(); // Cannot read the property of 'sData' of undefined            \n```\n\n# call, apply함수의 비교(this에 특정 값 넣어 동작)\n```js\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.call(obj,\"Korea\",\"Seoul\"));\t\n//welcome to Korea in Seoul Jaeyoon\n\nvar obj = {name: \"Jaeyoon\"};\nvar greeting = function(a, b){\n    return \"welcome to \" + a + \" in \" + b + \" \" + this.name;\n};\nconsole.log(greeting.apply(obj,[\"Korea\",\"Seoul\"]));\t\t\n//welcome to Korea in Seoul Jaeyoon\n```\n\n\n\n\n\n\n# bind()\n> 함수와 객체를 서로 묶는 것이다.  \n> bind()함수는 새 함수를 반환한다.(call, apply는 바로 동작`)\n```js\nfunction f(y) { return this.x + y }    //바인드되어야 하는 함수\nvar o = {x:1};      //바인드될 객체\nvar g = f.bind(o);  //g(x)를 호출하면 o.f(x)가 호출된다.\ng(2)                //=>3\n```\n\n# bind()함수 구현 해보기 \n```js\nFunction.prototype.bind = function(obj){\n  //this와 인자 값을 변수에 저장함으로써 다음의 중첩 함수에서 사용할 수 있다.\n  var me = this, boundArgs = arguments;\n\n  //bind() 메서드의 반환 값은 함수다.\n  return function(){\n  //인자 목록을 작성하는데, 첫 번재 이후의 인자부터\n  //나머지 모든 인자를 이 함수에 전달 한다.\n  var args = [], i;\n  for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);\n  for(i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  \n  //인자들을 포함하여 obj의 메서드로 me를 호출한다.\n  return me.apply(obj, args);\n}\n```\n\n# creating a bound function\n\n```js\nthis.x = 9;    // this refers to global \"window\" object here in the browser\nvar module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX(); // 81\n\nvar retrieveX = module.getX;\nmodule.getX(); // return: 81 - The ufnction gets invoked at the module scope\nretrieveX();   // returns 9 - The function gets invoked at the global scope\n\n// Create a new function with 'this' bound to module\n// New programmers might confuse the global var x with module's property x\nvar boundGetX = retrieveX.bind(module);\nboundGetX(); // 81\n```\n\n\n\n# Partially applied functions\n\n```js\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\nvar result1 = addArguments(1, 2); // 3\n\n// Create a function with a preset leading argument\nvar leadingThirtysevenList = list.bind(null, 37);\nvar list2 = leadingThirtysevenList(); // [37]\nvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n// Create a function with a preset first argument.\nvar addThirtySeven = addArguments.bind(null, 37); \nvar result2 = addThirtySeven(5); // 37 + 5 = 42 \nvar result3 = addThirtySeven(5, 10);// 37 + 5 = 42 , second argument is ignored\n\n```\n\n\n\n# with setTimeout()\n\n```js\nfunction LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  // #POINT\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log('I am a beautiful flower with '+ this.petalCount + ' petals!');\n};\n\nvar flower = new LateBloomer();\nflower.bloom();  \n// after 1 second, triggers the 'declare' method\n```\n","excerpt":"call() 정의 주어진 this 값, 전달된 인수 와 함께 함수를 호출 call()을 생성자 연결에 사용 function, method에 속해서 다른 객체를 호출한다. function, method에 this…","fields":{"slug":"/call(), apply(), bind()/"},"frontmatter":{"date":"Feb 02, 2020","title":"call(), apply(), bind()","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로\n\n```js\n\t1 콜백함수란?\n\t2 제어권\n\t\t2-1 호출시점\n\t\t2-2 인자\n\t\t2-3 this\n\t3 콜백 함수는 함수다\n\t4 콜백 함수 내부의 this에 다른 값 바인딩하기\n\t5 콜백 지옥과 비동기 제어\n```\n\n\n\n# 1 콜백함수란?\n> 다른 코드의 인자로 넘겨주는 함수(제어권도 함께 위임)\n> 콜백함수를 넘겨 받는 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행\n\n\n# 2 제어권\n> 호출시점, 인자, this 예제를 통해서 알아 보자\n## 2-1 호출시점\n> setInterval에 callback function은 '호출주체, 제어권'은 setInterval이다.\n```js\nvar count = 0;\nvar cbFunc = function() {\n    conosl.log(count);\n    if(++count > 3) clearInterval(timer);\n};\nvar timer = setInterval(cbFunc, 300);\n```\n## 2-2 인자\n> 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.\n\n* callback function의 인자 값은 filter에 의해서 정해졌다.\n    ```js\n    var newArr = [1,2,3,4,5].filter(function(idx, val){\n        console.log({'this sceop': this, idx, val});\n        return val > 2;\n    }, {a:1, b:2});     // {a:1, b:2}코드에 대한 설명은 아래 2-3 this설명에서 알 수 있다.\n\n    console.log(newArr);    //[4,5]\n\n    /*\n        this sceop: {a: 1, b: 2}\n        idx: 1\n        val: 0\n        \n        this sceop: {a: 1, b: 2}\n        idx: 2\n        val: 1\n        \n        this sceop: {a: 1, b: 2}\n        idx: 3\n        val: 2\n        \n        this sceop: {a: 1, b: 2}\n        idx: 4\n        val: 3\n        \n        this sceop: {a: 1, b: 2}\n        idx: 5\n        val: 4\n    */\n    ```\n\n## 2-3 this\n\n* Array.prototype.map - 구현    \n    ```js\n    Array.prototype.filter = function(callback, thisArg){\n        var mappedArr = [];\n        for(var i=0; i < this.length; i++){\n            var mappedValue = callback.call(thisArg || window, this[i], i , this);  //POINT\n        }\n    }\n    ```\n    * 주석 POINT 설명\n        * thisArg || window  \n            : callback function에서 this의 scope을 명시적으로 바인딩\n            : 이 코드에 의해 filter의 두번째 param으로 callback의 this를 정해줄 수 있다.\n            : 2-2인자 챕터 코드 참고하기\n        * this  \n            : filter를 호출 한 array(이 내용은 prototype과 관련해서 더 설명할 수 있겠다.)  \n        * this[i]  \n            : 이 코드에 의해서 callback function의 첫번째 param array의 i번째 요소\n        * i  \n            : 이 코드에 의해서 callback function의 두번째 param array의 i번째\n    \n# 3 콜백 함수는 함수다\n* 메서드를 콜백함수로 전달한 경우\n    ```js\n    var obj = {\n        vals: [1,2,3],\n        logValues: function(v, i){\n            console.log(this, v, i);\n        }\n    }\n    \n    obj.logValues(10,20); //{vals: Array(3), logValues: f} 10 20\n\n    [10,20,30].forEach(obj.logValues);\n    /*\n        Window{...} 10 0\n        Window{...} 20 1\n        Window{...} 30 2    \n    */\n    ```\n    * forEach의 callback function은 코드에 의해서 호출된 logValues에서 this는 Window를 가르키고 있다.\n        - callback function으로 obj 객체에 의해서 this가 결정되지 않고 별도로 this를 명시하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 가르친다.\n        \n# 4 콜백 함수 내부의 this에 다른 값 바인딩하기\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (1/3)\n    ```js\n    var obj1 = {\n        name: 'obj1',\n        func: function() {\n            var me = this;             //POINT\n            return function(){\n                console.log(me.name);\n            };\n        }\n    };\n    var callback = obj1.func();\n    setTimeout(callback, 1000);\n    ```\n    * var me = this;는 closure scope에 등록\n    * setTimeout에 의해서 callback function이 호출 될때 me.name은 excute context에서 me.name 변수를 찾는다.\n    ![callback & scope & clousre](callback&scope&closure.png)\n\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (2/3)\n    * 예제1에서 만들었던 함수 재활용하는 방법 - cb2 확인해보자\n    ```js\n        var obj1 = {\n            name: 'obj1',\n            func: function() {\n                var me = this;              //POINT: closure\n                return function(){\n                    console.log(me.name);\n                };\n            }\n        };\n\n        var obj2 = {\n            name: 'obj2',\n            func: obj1.func\n        };\n\n        var cb1 = obj1.func().bind('cb1');\n        setTimeout(cb1, 1000);\n\n        var cb2 = obj2.func().bind('cb2');\n        setTimeout(cb2, 1500);\n\n        var obj3 = { name: 'obj3' }\n        var cb3 = obj1.func.call(obj3);        //POINT: obj1.func = function(){ var me this; return function(p1){ console.log() }} \n        setTimeout(cb3, 2000);\n\n        /*\n            # 결과\n                * cb1: undefined \"obj1\" \"callback1\"\n                * cb2: undefined \"obj2\" \"callback2\"\n                * cb3: obj3 obj1 callback3\n        */\n    ```\n\n* 콜백 함수 내부의 this에 따른 값을 바인딩하는 방법 (3/3)\n    * bind로 this를 명시한 function을 사용\n        ```js\n        var obj1 = {\n                name: 'obj1',\n                func: function() {\n                    console.log(this.name)\n                }\n        };\n        \n        setTimeout(obj1.func.bind(obj1), 1000);\n\n        var obj2 = {name:'obj2'};\n        setTimeout(obj1.func.bind(obj2), 1500);\n\n        /*\n            # 결과\n                * obj1\n                * obj2\n        */\n        ```\n\n\n\n# 5 콜백 지옥과 비동기 제어\n> 콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상\n> 주로 이벤트 처리, 서버통신과 같은 비동기적인 작업을 수행하기 위해서 이런 형태가 등장\n\n* 동기적인 코드\n    - 현재 실행중인 코드가 완료된 후에야 다음 코드를 실행하는 방식\n* 비동기적인 코드\n    - 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어간다.\n    - CPU의 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적인 코드 \n* 비동기적인 코드가 필요한 경우   \n    : 웹의 복잡도가 높아진 만큼 비동기적인 코드의 비중이 예전보다 훨씬 높아졌다.\n    - 실행대기(setTimeout)  \n        : 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류\n    - 실행대기(addEventListener)  \n        : 사용자의 직접적인 개입이 있을 때 비로소 어떤 함수를 실행하도록 대기\n    - 보류(XMLhttpRequest)  \n        : 웹브라우저 자체가 아닌 별도의 대상에 무어가를 요청하고 그에 대한 응답이 왔을때 비로소 어떤 함수를 실행하도록 대기\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"업무중에 setTimeout, 특정 반목문, event callback function 등 특정상황에서 콜백함수 내부에서 this를 바인딩해서 사용하는 경우가 있었는데 그 경우를 실행 컨텍스트, 제어권에 따라 달라지는 것으로…","fields":{"slug":"/callback/"},"frontmatter":{"date":"Feb 02, 2020","title":"callback function","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# 문제 \n* 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n        \n# 해결 방법 \n* 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다\n\n# STEP\n* STEP1: 배열의 숫자형을 문자형으로 변환\n* STEP2: 문자형변환후 배열 요소를 자리를 바꿔가며 숫자 크기를 비교(문자열x)\n\n# code\n```js\nvar a = [3, 30, 34, 5, 9];\nvar b = [6, 10, 2];\n\nfunction solution(numbers) {\n    var answer = numbers.map(v => v + '')\n        .sort((a, b) => (b + a)* 1 - (a + b)*1)\n        .join('');\n\n    return answer[0] === '0' ? '0' : answer\n}\n```\n\n# 결과\n![](result.png)\n","excerpt":"문제 문제 배열의 숫자들을 숫자별로 내림차순으로 정렬한다. \n     해결 방법 배열의 숫자를 문자형으로 바꾸고 자리를 바꿔가며 문자를 조합하고 숫자형으로 다시 변환한뒤 숫자 크기를 비교한다 STEP STEP…","fields":{"slug":"/배열로 만들수 있는 수중 가장 큰수/"},"frontmatter":{"date":"Feb 01, 2020","title":"배열로 조합할 수 있는 수중 가장 큰 수 구하기","tags":["algorithm"]}}},{"node":{"rawMarkdownBody":"\n상황에 따라서 달라지는 this를 정리해보려고 한다. \n```js\n    0 javascripot에서 this\n    1 상황에 따라 달라지는 this\n        1-1 전역 공간에서의 this\n        1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n            함수 vs 메서드\n            메서드 내부에서의 this\n        1-3 함수로서 호출할 때 그 함수 내부에서의 this\n            함수 내부에서의 this\n            메서드의 내부함수에서의 this\n            메서드의 내부 함수에서의 this를 우회하는 방법\n            this를 바인딩하지 않는 함수\n        1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n        1-5 생성자 함수 내부에서의 this\n    2 명시적으로 this를 바인딩하는 방법\n        2-1 call 메서드\n        2-2 apply 메서드\n        2-3 call/apply 메서드의 활용\n            유사배열객체에 배열 메서드를 적용\n            생성자 내부에서 다른 생성자 호출\n            여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n        2-4 bind 메서드\n            name 프로퍼티\n            상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n        2-5 arrow function의 예외사항\n        2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n```\n\n# javascripot에서 this\n* 다른 객제지향 언어와 this의 차이점 \n    * 다른 대부분의 객체지향 언어의 this: 클래스로 생성한 인스턴스 객체\n        * 클래스에서만 사용할 수 있기 때문에 헷갈리지 않거나 많지 않음\n    * 자바스크립트 this: **어디에서나 쓸 수 있음**\n        * 상황에 따라 this가 바라보는 대상이 달라짐\n        * ***문제를 해결하려면 원인을 알아야 하는데, 정확한 작동방식을 이해하지 못하면 원인을 해결하기 어려움***\n\n* this 확인으로 '함수, 객체(메서드)'의 구분할 수 있는 거의 유일한 방법\n\n# 1 상황에 따라 달라지는 this\n> this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정(실행컨텍스트 설명할때 설명됨)  \n> 아래 상황별로 this가 5가지 다른 값을 보여주는 내용을 설명\n\n## 1-1 전역 공간에서의 this\n> 전역 공간에서 this는 전역객체를 가리킨다. \n\n* 전역 변수와 전역객체\n    ```js\n    var a = 1;\n    console.log(a);         //1\n    console.log(window.a);  //1\n    console.log(this.a);    //1\n    ```\n* 위 결과 값이 같은이유는? \n    * 전역변수 선언시 javascrip engine이 전역객체의 프로퍼티로 할당\n    * javascript 모든 변수는 특정 객체의 프로퍼티로 등록되고 동작\n        * 특정객체: 실행컨텍스트의 LexicalEnvironment\n        * 전역컨텍스트의 경우 LexicalEnvironment는 전역객체를 그대로 참조(실행컨텍스트 도식화 그림 참고\n* 전역 변수를 접근하는 과정은? -> scope chain\n    * a에 접근하고자 하면 스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 '전역 스코프'의 LexcialEnvironment(전역객체)에서 해당 프로퍼티를 a를 발견해서 그 값을 반환하기 때문\n\n\n---\n* 전역변수와 전역객체의 차이점\n    * 전역객체의 프로퍼티로 할당한 경우에서는 삭제 o\n    * 전역변수로 선언한 경우에는 삭제 x\n\n        ```js\n        var b = 2;\n        delete b;   //false\n        console.log(b, window.b, this.b) //2 2 2\n\n        window.c = 3;\n        delete window.c;    //true\n        console.log(c, window.c this.c); // Uncaught ReferenceError: c is not defined\n        \n        ```\n\n\n## 1-2 메서드로서 호출할 때 그 메서드 내부에서의 this\n### 함수 vs 메서드\n* 함수 호출시 this: 전역객체 (아래 예제코드 POINT 주석 참고)\n* 메서드로 호출시 this: 호출한 메서드\n    ```js\n    // 함수로서 호출\n    var obj = {\n        bar: function() {\n            var x = (function(){\n                        return this\n                    })();\n            return x;\n        }\n    };\n\n    obj.bar() === window //true     //POINT\n\n\n\n    // 메서드로서 호출\n    var obj = {\n        bar: function() {\n            var x = (() => this)(); // 주의: use arrow funciton\n            return x;\n        }\n    };\n\n    obj.bar() === obj\t//true\n\n    ```\n\n## 1-3 함수로서 호출할 때 그 함수 내부에서의 this\n### 함수 내부에서의 this\n* this에는 호출한 주체 정보가 담기는데 어떤 함수를 함수로서 호출시 this 지정 안됨\n* 함수로서 호출하는 것은 호출 주체(객체지향 언어에서의 객체)를 명시하지 않않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다.\n* **실행 컨텍스트가 지정되지 않은 경우 this는 전역 객체를 바라본다 -> 따라서 함수에서 this는 전역객체를 가리킨다.** \n\n### 메서드의 내부함수에서의 this\n* 실행순서1,2,3의 return value\n    - 실행순서1: {outer: f, outer2: f} === obj1\n    - 실행순서2: window{...}\n    - 실행순서3: {obj2Property: \"obj2Property\", innerMethod: ƒ}\n\n* POINT\n    - innerFunc에 console.log는 B, C에 의해서 호출이 되는데  \n    - B처럼 innerFunc이 함수로 호출될때는 this는 전역 변수를 가르킨다.\n    - C처럼 innerfunc이 메서도로 호출될때는 this는 호출한 대상을 가르킨다.\n        ```js\n        var obj1 = {\n            outer: function() {\n                console.log(this);  //실행순서 1 by A\n                var innerFunc = function(){\n                    console.log(this);  //실행순서 2 by B, 3 by C\n                }\n                innerFunc(); // B\n\n                var obj2 = {\n                    innerMethod: innerFunc,\n                    obj2Property: 'obj2Property' \n                };\n                obj2.innerMethod(); // C\n            },\n\n            outer2: function(){\n\n            }\n        };\n\n        obj1.outer(); // A\n        ```\n\n### 메서드의 내부 함수에서의 this를 우회하는 방법\n### this를 바인딩하지 않는 함수\n> 아래 예제 주석 참고\n* log 결과값\n    * [1]: {outer: f}\n    * [2]: window {...}\n    * [3]: {outer: f}\n    * [4]: window {...}\n    * [5]: {outer: f}\n\n    ```js\n    var obj1 = {\n        outer: function() {\n            console.log(this);  // [1]\n            var innerFunc = function(){\n                console.log(this); // [2]\n            }\n            innerFunc(); \n\n            var me = this;\n            var innerFunc2 = function(){\n                console.log(me);    // [3] POINT 메서드의 내부 함수에서의 this를 우회하는 방법\n                console.log(this);  // [4]\n            }\n            innerFunc2(); \n\n            var innerFunc3 = () => {\n                console.log(this);  // [5] POINT: this를 바인딩하지 않는 함수\n            }\n            innerFunc3();\n\n        }\n    };\n\n    obj1.outer(); \n    ```\n\n\n\n## 1-4 콜백 함수 호출 시 그 함수 내부에서의 this\n> callback function의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정  \n> **특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라본다.**  \n> 콜백 함수에 bind를 사용하여 [2-4 bind](https://happyjy.github.io/this/#상위-컨텍스트의-this를-내부함수나-콜백함수에-전달하기)\n\n\n    ```js\n    setTimeout(function(){\n        console.log(this);      //window 객체 \n    }, 3000);\n\n    [1,2,3].forEach(function(v){\n        console.log(this, v);   //window 객체 \n    })\n\n    //event Callback function 참고\n    document.body.innerHTML += `<button id=\"a\"> 클릭 </button>`\n    document.body.querySelector('#a').addEventListener('click', function(e){\n        console.log(this, e);\n    })\n\n    ```\n    * \"button click event Callback function this\"과 \"id='a' dom\" 객체 비교 => **같다.**\n\n    ![](eventCallbackfunction.png)\n\n\n\n* addEventListner function 내부 구현 추측 \n    - addEventListner function this가 'document.body.querySelector('#a')' 이기 때문에  \n    이 값을 callback function을 call메서드를 이용해 명시적으로 this바인딩 할 수 있겠다.\n\n        ```js\n            addEventListener: function(a, callbackFunc){\n                ...\n                callbackFunc.call(this, event);\n                ...\n            }\n        ```\n\n## 1-5 생성자 함수 내부에서의 this\n> 생성자 함수에서 this는 생성될 인스턴스를 참조\n\n```js\nvar Dog = function(name, age) {\n    this.bark = 'RRRR';\n    this.name = name;\n    this.age = age;\n};\n\nvar hs = new Dog('행성', 2);\nvar girl = new Dog('소녀', 3);\nvar universe = new Dog('우주', 1);\n\nconsole.log(hs, girl, universe);\n/*\n    hs: Dog {bark: \"RRRR\", name: \"행성\", age: 2}\n    girl: Dog {bark: \"RRRR\", name: \"소녀\", age: 3}\n    universe: Dog {bark: \"RRRR\", name: \"우주\", age: 1}\n*/\n\nconsole.log({bark: hs.bark, name: hs.name, age:hs.age})\n/*    \n    {bark: \"RRRR\", name: \"행성\", age: 2}\n*/\n\n```\n\n* 위 두 console.log를 확인했을때 Dog에의해서 생성된 instance가 this가 된것을확인 할 수 있다.\n\n# 2 명시적으로 this를 바인딩하는 방법\n> 2 이 목차는 call(), apply(), bind()에 대해서 자세하게 다루도록 위해서 다른 포스트에서 설명하도록한다.\n[call(), apply(), bind()](https://happyjy.github.io/call(),%20apply(),%20bind())\n\n\n## 2-1 call 메서드\n## 2-2 apply 메서드\n## 2-3 call/apply 메서드의 활용\n### 유사배열객체에 배열 메서드를 적용\n### 생성자 내부에서 다른 생성자 호출\n### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 apply 활용\n## 2-4 bind 메서드\n### name 프로퍼티\n### 상위 컨텍스트의 this를 내부함수나 콜백함수에 전달하기\n\n```js\nvar obj ={\n    outer: function(){\n        console.log(this);               //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);           //{outer: ƒ, outer2: ƒ}\n        }\n        innerFunc.call(this);       //POINT\n    },\n\n    outer2: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          //{outer: ƒ, outer2: ƒ}\n        }.bind(this);               //POINT\n        innerFunc();\n    },\n\n    outer3: function(){\n        console.log(this);              //{outer: ƒ, outer2: ƒ}\n        var innerFunc = function(){\n            console.log(this);          // window{...}\n        }                            //POINT\n        innerFunc();\n    }\n}\n\nobj.outer();\nobj.outer2();\nobj.outer3();\n\n```\n\n## 2-5 arrow function의 예외사항\n* [this를 바인딩하지 않는 함수 목차 참고](https://happyjy.github.io/this/#this를-바인딩하지-않는-함수)\n\n\n\n## 2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)\n``` js\n    var report = {\n        sum: 0,\n        count: 0,\n        add: function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.forEach(function(arg, idx){\n                debugger;   //idx가 0일때 this -> {sum: 0, count: 0, add: ƒ, average: ƒ}    :report 객체\n                this.sum += arg;\n                ++this.count;\n            }, this);       //POINT\n        },\n        average: function(){\n            return this.sum / this.count;\n        }\n    }\n\n    report.add( 10, 20, 30 );\n    console.log({sum: report.sum, count: report.count, average: report.average()});\n    //{sum: 60, count: 3, average: 20}\n```\n* 만약 위 코드에서 POINT 부분 forEach function에 두번째 parameter \"thisArg\"가 없었다면\nthis.sum += entry;에서 this는 window객체를 가르키기 때문에 console.log 결과는 아래와 같다.\n>{sum: 0, count: 0, average: NaN}\n\n* 콜백함수와 함께 thisArg를 인자로 받는 메서드  \n```js\n    Array.prototype.forEach(callback[, thisArg]);\n    Array.prototype.map(callback[, thisArg]);\n    Array.prototype.filter(callback[, thisArg]);\n    Array.prototype.some(callback[, thisArg]);\n    Array.prototype.every(callback[, thisArg]);\n    Array.prototype.find(callback[, thisArg]);\n    Array.prototype.findIndex(callback[, thisArg]);\n    Array.prototype.flatMap(callback[, thisArg]);\n    Array.prototype.from(callback[, thisArg]);\n    Set.prototype.forEach(callback[, thisArg]);\n    Map.prototype.forEach(callback[, thisArg]);\n```\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드","excerpt":"상황에 따라서 달라지는 this를 정리해보려고 한다.  javascripot에서 this 다른 객제지향 언어와 this의 차이점  다른 대부분의 객체지향 언어의 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Feb 01, 2020","title":"this","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n# INTRO\n* 목표: 객체 지향을 자바스크립트로 해보자 \n* 객체지향 이론\n    - 오늘 배운 이론 남은 4개 강의에서 활용\n\n# Value Context, Identifier Context\n> value Context: 함수형 프로그래밍에서 사용  \n> identifier context: 객체지향 프로그래밍에서 사용\n\n권장 하나의 context만 사용\n특별한 사항을 제외하고 \n\n```js\nconst a = { a:3,b:5 };\nconst b = { a:3,b:5 };\nconsole.log(a === b);   //identifier context\nconsole.log(JSON.stringify(a) === JSON.stringify(b));   //value context\n```\n\n* 객체 지향의 기본: 메소드 인자, return value, 메소드가 만드는 무언가가 모든 객체만 사용한다임.\n* 객체지향에서 사용할수 있는 value context는 생성자 인자\n\n## value특징\n1. 끝없는복사본 \n    - value값은 변하지 않으면서 복사본을 계속해서 사용한다. \n2. 상태 변화에 안전?\n    - 1번 특징으로 값이 변하지 않음으로 상태에 변화에 안전하다 \n    - 3 + 1 연산에서 3이 4로 바뀌는게 아니라 4가 새로 생기는 것 \n    - 불변하는 값을 계속 만들어서 이것도 관리한는게 힘들다 => 그래서 `함수형 프로그래밍`이 탄생\n3. 연산을 기반으로 로직을 전개\u001f(수학적 프로그래밍)\n    - 수학적 프로그래밍은 '확정', '간단'한 로직은 어울린다. \n    - 구현하기 어려운 도메인을 복잡한 연산으로 구현하기 어렵다.\n        - 복잡한 것을 도메인을 수학적 프로그래밍으로 정교하게 구현해도 교체 하는 비중이 너무 커서 깨지기 쉽다 \n    - 넷플릭스에서 어울림 동영상 스트리밍 하는 것만 연산 하면 된다.\n\n## identifier 특징\n1. 하나의원본\n    - 값이 mutable\n    - 상태가 일관적이지 않음\n2. 상태 변화를 내부에서 책임짐 \n    - 내부 상태에서 책임지는 객체를 만드는게 힘들다.\n3. 메세지를 기반으로 로직을 전개\n    - 우리가 배울 테마 \n    - 구현사는데까지 만들고 다른 놈에게 위임 할 수 있다. \n\n## 정리 \n* 객체 지향에서 제일 중요한것 값을 사용하지 않는것 \n\n\n# Polymorphism\n> Polymorphism 대체가능성 + Polymorphism 내적일관성   \n> 객체 지향 프로그래밍은 Polymorphism을 지원해야 한다.\n\n## polymorphism of Prototype\n\n```js\n    const Worker = class{ \n        run(){ console.log(\"working\") }\n        print(){ this.run(); } \n    };\n    const HardWorker = class extends Worker{ \n        //overriding\n        run(){ console.log(\"hardWorking\") }\n    };\n    const worker = new HardWorker(); \n    \n    // substitution\n    console.log(worker instanceof Worker); //true -> Polymorphism의 대체가능성\n    // internal identity\n    worker.print();                        //hardWorking -> Polymorphism의 내적일관성\n```\n\n## Polymorphism의 대체가능성(substitution)\n> 확장된 클래스는 확장할 대상 클래스를 대체할 수 있다.\n* worker instanceof Worker 결과 값은 true이다. 아래 도식화 참고 \n## Polymorphism의 내적일관성(internal identity)\n> 태어났을때 원본 클래스를 유지하는 속성 \n* worker.print() 동작시 this.run()이 호출한 곳에서 가까운 Worker class의 run funtion이 호출되는게 아니라 print를 호출한 대상 worker instance에서 가까운 run 함수를 호출하도록 하자 정한 것을 '내적일관성'이라고 한다.  \n\n## Polymorphism의 장점 \n*  확장된 객체는 원본으로 대체 가능\n*  생성 시점의 타입이 내부에 일관성 있게 참조됨.\n\n## PolymorPhism of Prototype\n* javascript prototype, prototype chain을 통해서 `대체가능성`,`내적일관성`을 구현했다.\n* [프로토타입체인 참고](https://happyjy.github.io/prototype/#2-2-프로토타입-체인)\n\n\n## 대체가능성 설명 도식화 \n![](polymorphismOfPrototype1.png)\n![](polymorphismOfPrototype2.png)\n    - worker instanceof Worker 설명\n        - 첫번째 사진에서 HardWorker class instance인자 확인 아니기 때문에 두분째 사진처럼 Worker class instance인지 확인\n\n## 내적일관성 설명 도식화 \n![](polymorphismOfPrototype.png)\n    - 위코드에서 worker.print()가 'hardWorking'이 호출되는 것을 설명 할 수 있다.\n\n## 대체가능성, 내적일관성 설명 도식화 코드로 확인\n```js\n\nworker.__proto__ === HardWorker.prototype;           //true\nworker.__proto__.__proto__ === Worker.prototype;     //true\n\nworker.__proto__.constructor === HardWorker;         //true\nworker.__proto__.__proto__.constructor === Worker;   //true\n\nHardWorker === HardWorker.prototype.constructor;     //true\nWorker === Worker.prototype.constructor;             //true\n\n``` \n\n\n# Object Essentials\n* 객체의 본질이란 ? \n    > Maintenance of State(state 관리=> 데이터은닉)\n    > Encapsulation of Functionality(기능의 캡슐화)\n\n\n```js\nconst EssentialObject = class {\n    // 데이터은닉(hide state): 내부의 상태를 감춤\n    #name = ''\n    #screen = null\n\n    constructor(name) { this.#name = name }\n    camouflage(name) { this.#screen = (Math.random() * 10).toString(16).replace('.', '') }\n\n    // 캡슐화(encapsulation): 안에서 무슨 일이 일어나는지 노출하면 안됨\n    get name(){ return this.#screen || this.#name }\n}\n```\n\n## 데이터 은닉(hide State)\n> 내부 상태(데이터)를 감춰야 한다.\n* 객체지향에서 데이터 은닉은 필수(= 상태를 외부에 보여주지 않는다. = private) \n* 객체 지향은 메모리 참조로 움직여야 하는데 속성이 공개되는 순간 속성을 값으로 취득해서 쓰기때문에 value context가 프레임 전체에 관여 -> 객체지향은 무너진다. \n\n\n## 캡슐화(encapsulation)\n> 메소드를 추상화 시켜야 한다.\n* 메소드 안에서 무슨일이 일어나는지 노출하면 안된다(=밖에서는 추상화로 인식해야 한다.)\n    - 예시 ATM에서 돈뽑는 것: \b돈달라는 인터페이스만 노출, but 실제로 카드인증, 신용인증, 보안인증 트렌젝션 준비, 확인, 데이터 연산등이 있다. \n* 안좋은예\n    - setAge() 함수가 있다고 하자. 이 함수는 캡슐화가 된게 아니다. 왜냐하면 age 필드를 날로 노출했으니까. 그렇다면 본질적으로 왜 setAge하는지 알아야 한다. **더 생각해서 setAdult setChild 메소드로 만들고 그안에 나이 조건이 있고 이 나이에 따라서 컨텐츠를 구분해야 한다. 이런식으로 더 깊이 생각해야한다.** 이렇게 직접노출하지 않고 기능의 캡슐화가 가능하다 \n* 데이터 은닉: 데이터 대상/ 캡슐화: 기능 대상 \n \n\n\n## Isolation of change\n> 격리: 해당 변화가 일어났을때 그곳에만 변화가 일어나고 다른곳에 여파가 오지 않게 하는 것 \n\n* 소프트웨어는 '당연하게' 요구사항이 계속 변함으로 같이 계속 변한다.\n* 우리는 변화를 막을 수 없기 때문에 Isolation 하는 것이 목표다.\n* 객체지향에서 '변질'을 막고 다른곳으로 퍼지지 못하게 하는것이 이것 밖에 없다.(그래서 본질로 생각한다.)\n\n\n\n# 알려진 기본 설계 요령\n## SOLID 원칙 \n* SRP Single Responsibility(단일책임)\n* OCP Open Closed(개방폐쇄)\n* LSP Liskov Substitusion(업캐스팅 안전)\n* ISP Interface Segregation(인터페이스분리\n* DIP Dependency Inversion(다운캐스팅금지)\n\n### SRP Single Responsibility(단일책임)\n> 수정하는 원인이 하나가 되도록 만드는 것\n* 이를 지키지 못했을때 산탄총 수술(shotgun surgery)가 필요하다 \n* [수정필요](아래 srp를 준수하는 객체망이 문제를 해결 chapter link)\n\n### OCP Open Closed(개방폐쇄)\n* open: extends, implements를 할 수 있게 만드는 것 \n* closed\n    - 수정이 필요하면 기존 class를 만드는게 아니라 다른 extends, implemtns class를  만들어서 문제를 해결하는 것(=새로운 객체를 만들어서 해결)\n    - 문제의 공통점을 인식해서 추상화에 성공해서 그 다음에도 추상화를 이어 받아서 새로운걸 해결 할 수 있는 것이다. \n\n### LSP Liskov Substitusion(업캐스팅 안전)\n> 추상층의 정의가 너무 구체적이면 구상층 구현에서 모순이 발생\n* 아래 예제1 '추상층'에서 다리로 이동한다. 라는 정의때문에 구상층 '아메바, 독수리, 고래'에서 위배된다. 그래서 예제2를 다시 확인해보자 \n\n[예제1]\n```\n* 추상층 - 생물\n    - 숨을 쉰다. \n    - 다리로 이동한다.\n* 구상층(구현)\n    - 사람, 타조: OK\n    - **아메바, 독수리, 고래: NO**\n```\n\n* 아래 예제2를 보면 추상층을 두개로 나눴다. \n    - 생물 class, 다리이동 interface\n[예제2]\n```\n* 추상층 - 생물(숨을 쉰다), 다리이동(다리로 이동한다)\n    \n* 구상층(구현)\n    - 사람, 타조: \"생물\", \"다리이동\" -> OK\n    - 아메바, 독수리, 고래: \"생물\" -> OK\n```\n\n### ISP Interface Segregation(인터페이스분리)\n> 위 원칙 LSP가 성림하지 않았기 때문에 ISP(예제1 -> 예제2)작업이 있었다.\n\n* ISP 필요대상\n![](ISP-필요대상.png)\n\n* 위침으로 해결하는 방법\n![](ISP-위임.png)\n    - 위임(소유): 인터페이스로 분리하지 않고 처리하는 첫번째 옵션\n    - 모듈A, B, C 바라볼 객체를 만들어서 객체별로 A,B,C를 상대하도록 만들어 준다\n\n\n* 인터페이스 사용 \n![](ISP-interface.png)\n    - 객체를 만들때 처음부터 인터페이스A,B,C 세개를 가져와서 인터페이스에 맡게 메소드를 오버라이드한\u001d다. \n    - 그래서 외부에서 볼때는 객체를 보는게 아니라, 객체가 구현한 인터페이스를 보게 된다. \n\n### DIP Dependency Inversion(다운캐스팅금지)\n> 의존성 역전의 법칙이라고도함  \n> 의존성은 언제나 부모쪽으로 흘러야 한다. \n\n* 다운캐스팅을 안하면 나머니 솔리드 원칙이 다 지켜지는것이기 때문에 어려운 항목이다. \n* 고차원의 모듈은 저차원의 모듈에 의존하면 안된다. **이 두 모듈 모두 추상화된것에 의존해야 한다.**\n    - 고차원: extends를 \u001f더 많이 한 것(자식 쪽)\u001d\n* 추상화 된 것은 구체적인 것에 의존하면 안된다. **구체적인 것이 추상화된 것에 의존해야한다.**\n\n## 기타 \n### DI(Dependency Injection, 의존성주입) \n* IoC(Inversion of control, 제어역전)의 일부, 구현체 중에 하나 \n\n### DRY(Don't Repeat YourSelf)(중복방지)\n\n### Hollyworld Principle(의존성 부패방지)\n* 요구하지 말고 요청 또는 기다려 내가 요청할께 \n* 액션이 처리할 사람이 거꾸로 연락하게 하는 패턴  \n* 은닉화, 캡슐화가 지켜지지 않은 경우\n\n### Law of demeter(최소지식)\n* classA.methodA의 최대지식한계 \n    - classA의 필드 객체\n    - methodA가 생성한 객체\n    - methodA의 인자로 넘어온 객체\n* 이 법칙이 지켜지지 않으면 **열차전복(train wreck)**가 일어난다. \n\n\n# Message\n> 다른객체에게의뢰하는것=다른객체에게메세지를보내는것  \n> 객체지향은 Message를 통해서 문제를 해결한다. \n\n[수정필요]아래 SRP 링크 잡기\n## SRP(SOLID중 1개: Single Responsibility(단일책임))를 준수하는 객체망이 문제를 해결\n* 책임이 상세하게 분리 -> 각자의 격할만하고 다른놈에게 넘겨서 문제를 해결 마치 data structure에 linked-list처럼(이것이 객체지향이 문제를 해결하는 방법이다.)\n    - 이렇게 문제를 해결하지 않고 쭉 코드를 짜면 수정하는 원인이 한가지가 아니라 여러가지 이다.  \n* 설계라는것은? \n    - 어디까지 나눠야할지 말아야할지 결정하는 것이다. \n    - 변화가 많이 일어나면 더 상세하게 나눠야 한다. \n* **단일 책임 원칙을 준수하는 객체에게 책임 이상의 업무를 부여하면?**\n    1. **만능 객체가 되려한다.** \n    2. **다른 객체에게 의뢰한다.**\n* Message를 보낸다의 의미 \n    - **다른객체에게의뢰하는것=다른객체에게메세지를보내는것**\n\n\n1. `메세지`-의뢰할내용\n2. `오퍼레이션` - 메세지를 수신할 객체가 제공하는 서비스 \n    * 오퍼레이터\n        - 메세지를 수신 하는 역할을 한다. \n        - 실제로 잘동하지 않는다. \n        - 대외적으로 공개된 채널로 내부적으로 매핑(`런타임`구성)에 따라서 하나의 메소드를 실행시칸다. \n        - 위 worker.run()을 예를 들어서 생각해보자. \n            - run()이라는 `오퍼레이터`는 Wokrer, HardWorker 둘중 어느것을 수행할지는 worker.run()을 수행할때 `런타임`이 정해져 어떤 run을 수행할지 정해진다. 이를 `동적바인딩`이라고 한다. 이렇게 javascript는 `prototype`에 의해서 동적 바인딩을 지원한다. \n3. `메소드` - 오퍼레이션이 연결될 실제 처리기\n\n* 추상클래스, 인터페이스를 상속하게 하는 이유는? \n    - **오퍼레이션, 메소드를 분리해서 런타임에 원하는 애를 바뀌기 위해서**\n    - 결국 **SRP통해서 OCP(SOLID중 1개: Open Closed(개방폐쇄))를 만들어 낸다**\n\n\n# Dependency \n> 의존성은 가장 중요한 격리의 문제\n\n* 우리가 진짜 원하는 얘기\n* 격리가 되지 않는 이유?\n    - **문제가 되고 있는 객체를 의존해서**\n* 설계의 어려운 이유 \n    - SRP(위 대chapter Message-srp)설명할때는 책임을 상세하게 나누라고 했는데 여기서는 난눈 개체가 문제가 생기면 격리가 안되서 문제라고 한다. \n    - 그래서 이 둘(SRP, Dependency)을 고민해서 설계해야 한다.  \n    : 적당하게 의존성을 가지고 있어야한다.  \n* 의존성 다소의 차이\n    * 의존성이 많을때는 객체가 각자의 역할이 정해져있다. \n    * 의존성이 적을때는 한개의 객체가 많은 역할을 수행한다.\n\n## 의존성의 종류 \n> 두가지가 있다. \n> 1. 객체의 생명주기 전체에 걸친의존성 \n> 2. 각 오퍼레이션 실행 시 임시적인 의존성 - 의존(dependency)\n1. **객체의 생명주기 전체**에 걸친의존성 \n    * 상속(extends)\n        - **강력한 의존성으로 부모객체와 합체 된 개념으로 부모의 변화가 있으면 자식의 변화를 감수해야한다.** \n        - 그래서 상속이 안좋다고 하는 이유입니다. \n    * 연관(association)\n        - 필드의 그 객체 타입을 알고 있다. \n        - **예를 들어 A클래스에 B라는 멤버를 생성해서(소유), 생성한 B멤버 클래스는 클래스A인스턴스가 만들고 없어질때까지 B멤버 클래스와 연관이 있는것이다.** \n\n2. 각 **오퍼레이션 실행 시** 임시적인 의존성 \n    * 의존(dependency)\n        * 오퍼레이션 실행시에만 수행된다. \n        * 메소드 단위로만 의존성이 생겼다 없어지고 메소드를 한번도 호출하지 않으면 의존성이 없기도하다.\n\n### 의존성 문제를 해결하기 위해서 우리가 '지향'해야할 방법\n> 상속 -> 연관 -> 의존 단계로 우리는 지향해야 한다. \n* 상속 -> 연관\n    - 상속을 소유로 바꾼는 것 \n* 연관 -> 의존\n    - 연관도 빡시면 **의존 단계에서 연산에서 처리**하지 꼭 필드에서 참조할 객체를 잡아야 하냐에서 시작\n    - 필드가 없다는건 상태가 없다는 것 -> 객체가 없다는건 함수를 쓰라는 것(이것이 `함수형프로그래밍`)\n    \n* 객체지향에서는 연관 -> 의존함부로 바꾸기 어렵다 왜? \n    - **객체지향에서는 '상태'를 유지하고 있기 때문** \n        - 수정 여파 규모증가\n        - 수정하기 어려운 구조 생성 3. 순환 의존성\n    - **그런데도 객체지향 클래스들도 함수들을 쓰려고 하는 이유가 의존성을 낮추기 위해서다** \n\n### 의존성이 높으면? \n1. 수정 여파 규모증가\n2. 수정하기 어려운 구조 생성\n3. 순환의존성 \n    - A, B 둘 사이 의존성 없다. \n    - A -> C -> D 이렇게 알고 있다.\n    - 그런데 여기서 D -> B를 알게 되면 A가 B를 알게 되는 경우가 생긴다.  \n    : A -> C -> D -> B\n    - 그래서 B를 고쳤는데 A가 문제가 생기는 이유가 된다. \n\n# 객체지향을 배우는 이유\n> `격리구간`을 세우고 `의존성`을 관리하기 위해서  \n>   - 의존성은 `변화에 대한 격리를 위해서`관리한다\n\n* 위 쳅터 \"Message-SRP\", \"Dependency\"에서 설명\n\n# Dependency Inversion\n[수정필요] 링크 추가하기\n* DIP Dependency Inversion(다운캐스팅금지)\n* Polymorphism\n> 어떠한 경우에도 다운캐스팅은 금지\n> 폴리모피즘(추상인터페이스) 사용\n\n```js\nconst Worker = class{ \n    run(){ console.log(\"working\") }\n    print(){ this.run(); } \n};\nconst HardWorker = class extends Worker{ \n    run(){ console.log(\"hardWorking\") }\n};\n\nconst Manager = class { \n    #workers; \n    constructor(...workers) {\n        if(workers.every(w=>w instanceof Worker)) this.#workers = workers;\n        else throw \"invalid workers\"; \n    }\n    doWork(){ this.#workers.forEach(w=>w.run()) }; \n};\n\nconst manager = new Manager(new Worker(), new HardWorker()); \nmanager.doWork();\n```\n* 아래 나오는 다음 3가지 설명으로 OCP, DIP를 통해서 객체지향을 느끼는 초석을 다지는데 좋은 설명이였다. \n    - \"OCP를 위 예제 코드를 통할 설명\", \"DIP(의존성 역전의 법칙)\", \"Manager class 코드 설명\" \n    \n* OCP를 위 예제 코드를 통할 설명 \n    * **worker 사상 검증시 Worker class기준으로 했다.** 이 의미는 HardWorker는 추상클래스로 본것이다.(폴리모피즘을 이용해서 대체가능성을 이용해서 추상클래스로 본것이다.) 하위 클래스를 인식하지 않음으로써 더 많은 하위 클래스 xxxWorker만들어도 Worker패밀리리면 다 받아준다는 의미이다. 그래서 Worker클래스를 확장해서 xxxWorker 클래스들을 많들어도 된다. \n        - 그래서 Manager class constructor에서 workers 사상검증시(instanceof 키워드를 통해서)Worker를 기준으로하고 있다.\n        - Worker 클래스를 확장한 xxxWorker 클래스들을 Manager class constructor에서 검증할때 constructor를 변경할 필요가 있을까? -> NO\n        - worker로 부터 더 많은 extention을 만들 수 있따 -> ***\"Open extend\"(확장이 열려있다)\u001d***\n        - 그럼에도 불구하고 Manager class constructor를 수정할 필요가 없다 -> ***변화에 \"Closed\"***\n    * OCP를 달성하면 자연스럽게 **의존성 역전**이 달성된다. \n\n* DIP(의존성 역전의 법칙)\n    - Manager class constructor에서 의존성을 무엇으로 가지고 있는가? \n        - ***구상클래스(Hardworker) 가지고 있지 않고 추상클래스(Worker)로 가지고 있다.*** \n    - 그래서 Manager class에 doWork 함수에서는 run이 사용될 수 있는것인가? \n        - 추상클래스(Worker)에 run 함수가 있기 때문이다.\n        - 왜냐하면 Manager class contsructor에서 Worker 클래스로 사상검증 했기 때문이다. \n\n* 위 코드를 보며 OCP, DIP를 설명했는데 Manager class 코드를 기준으로 다시 정리해보자\n    - constructor에서 `OCP`를 표현하고 싶고 Worker class level에서 instance를 인식할 것이니까 Manager class에서는 Worker level의 메서드를 쓸것이다.(`DIP`) 라고 해석 할수 있다. (HardWorker의 함수를 사용하지 않는다.)\n\n* OCP가 안되면 DIP가 될 수 없다.(OCP, DIP는 깊은 연관을 가지고 있다.)\n\n\n# Inversion of Control\n> 객체지향에서 가장 마지막으로 도달해야 할 지점   \n> DIP 조차도 IOC의 재료   \n> IOC에 도달하면 객체지향에 도달했다고 생각해도된다.   \n\n* Inversion의 보다 쉬운 설명\n    - 제어를 안한다는 의미가 아니라 \n    - **내가 직접하지 않고 위임 하겠다 라는 의미**\n    - <u>예를 들어 내가 운전을 못하지만 운전잘하는 사람의 차를 타면 밖에서 볼때 운전 잘하는 사람? 으로 보일 것이다. 오 이게 Inversion of Driving...이라고 말할 수 있겠네...😅</u>\n\n* 제어역전의 개념과 필요성\n    1. Control = flow control(흐름제어) \n    2. 광의에서흐름제어 = 프로그램실행통제 \n    3. 동기흐름제어, 비동기 흐름제어 등\n\n* 문제점\n    > 동적알고리즘(Dynamic Programing)에서 iterator를 돌면서 조건이 바뀌기 때문에 흐릅제어가 어렵다. \n    1. 흐름 제어는 상태와 결합하여 진행됨\n    2. 상태 통제와 흐름제어 = 알고리즘\n    3. 변화에 취약하고 구현하기도 어려움\n        - 제어문이 많아질수록 유지 보수가 어렵다.  \n\n* 대안\n    1. 제어를 추상화하고\n        - 일반화라는 관점이 필요\n        - 제어들을 모으려면 공통된 부분, 다른 부분을 filter하는 게 필요하다. (`연역적추리`)\n        - 연역적 추리가 되면 원리를 뽑아내서 `귀납적 상황`을 만들어서 연역적 내용들을 모두 처리 할 수 있게 된다. \n        - 귀납적추리, 연역적추리\n            - 귀납적추리(Indcution): 원리를 가지고 현상을 예측하는 것\n            - 연역적추리(Deduction): 현상으로 원리를 깨닫는 것 \n    2. 개별 제어의 차이점만 외부에서 주입받는다.\n\n\n# 예제 소스 \n```js\n// POINT1\n// Renderer: base element에 view가 주는 element를 집어 넣어서 그림을 그리는 녀석 \nconst Renderer = class {\n    #view = null;\n    #base = null;\n    \n    constructor (baseElement) {\n        this.#base = baseElement;\n    }\n    set view (v) {\n        if(v instanceof View) this.#view = v;\n        else throw `invalid view: ${v}`;\n    }\n    render (data) {\n        const base = this.#base;\n        const view = this.#view;\n\n        if(!base || !view) throw 'no base or no view';\n        let target = base.firstElementChild;\n        //POINT2\n        //base안 element를 제거한다. \n        do base.removeChild(target);\n        while (target = target.nextElementSibling);\n        //POINT3\n        //view.getElement은 render function에 의해서 받은 data에 합당한 el을 반환 \n        //아래 renderer.view에 상속받아 구현함.\n        base.appendChild(view.getElement(data));\n        view.initAni();     //애니메이션 초기화 \n        view.startAni();    //애니메이션 시작해\n    }\n}\n\nconst View = class {\n    getElement (data) { throw `override!` };\n    initAni () { throw 'override!' };\n    startAni () { throw 'override!' };\n}\n\n//특정뷰를 받아서 그리는 역할 \nconst renderer = new Renderer(document.body)\n//POINT4\n//* new class extends View\n//  :익명클래스처럼 view를 상속받는 class를 하나 만들고 인스턴스를 만드는 코드 \nrenderer.view = new class extends View {\n    #el\n    //POINT5\n    //data에 의해서 받은 데이터로 dom을 생성해 본인(View를 상속받은 class)필드 '#el'에 집어 넣고 반환 \n    getElement (data) {\n        this.#el = document.createElement('div');\n        this.#el.innerHTML = `<h2>${data.title}</h2><p>${data.description}</p>`;\n        this.#el.style.cssText = `width:100%;background:${data.background}`\n        return this.#el;\n    }\n    initAni () {\n        const style = this.#el.style;\n        style.marginLeft = '100%';  //화면 밖 오른족으로 쭉 밀어버린다.\n        style.transition = 'all 0.3s';  //0.3이후에 오라고 transition 검 \n    }\n    startAni () {\n        //한프레임 건너뛰고 람다에서 style에 margin 0을 넣는건 마진 100%에서 왼쪽으로 쫚들어온다.\n        requestAnimationFrame(() => this.#el.style.marginLeft = 0);\n    }\n\n    \n}\n\nrenderer.render(\n    { title:\"title test\", \n    description:\"contents.......\", \n    background:\"#ffffaa\"});\n```\n\n## 핵심1: Renderer, View Class 설명\n* 이 레시피가 개별 뷰마다 만들어지지 않고 render에만 집중되어 있다. \n* 이 레시피가 바로 제어문!\n    * 어떤 제어냐? \n        - 내용을 지우고 새로운 객체를 만들어서 내 자신을 만들어서 애니메이션을 처리 할꺼야 라는 레시피가 render안에 있다. \n        (== 제어문이 이 안에 있다라는 의미)\n* 그럼 이제 모든 뷰를 만들어 낼때 제어는 Renderer class의 render가 하고 제어에 해당하는 각각 부속물을 공급하는 역할을 view객체를 공급해주면 된다. \n* 그러면 앞으로 모든 뷰를 등장시킬때 render작업을 두번다시 할까? \n    - 안한다!    \n* render에 data에 맞는 view를 그린다라는 제어부분이 render에 집중되어 있고 개별뷰(set view)에는 없어진다. 개별뷰(set view)에 있는 제어문은 render쪽에 모여 있다. \n* view가 가져야 할 제어를 render쪽으로 역전시켜서 한군데에만 있는 제어를 사용하고 이 제어에 부속(Veiw)으로써가 개별 공급해야할 내용들만 공급해준다는 의미\n* **제어의 역전**이 일어나고 있다. \n: 내가 view를 여러번 만들다 보니 계속 반복되는 내용을 render에다가 몰아 넣고 view는 필요한 부품만 render에 몰아 넣으면 될것 같다.라고 판단해 만든것이 Render class에 set view, render와 같다.\n* **제어의 역전이 일어나니 \"의존성 역전\"(추상클래스를 받으니까)이 일어나고 \"OCP\"도 자동** \n\n\n## 핵심2: renderer.view객체 (View를 상속받은 instance 객체)\n* 뷰에대한 애니메이션 초기화와 애니메이션 동작은 각각 view에 대한 클래스에서 책임지고 있다. \n    - 전체적인 흐름은 Renderer class의 render가 한다. \n* 제어 역전에 들어가는 부속들은 일부 부속들(renderer.view가 가지고 있는 instance의 getElement, initAni, startAni)거기에 대한 일부 재료들만 제공만하고 실제 제어 부분은 빠지게 된다. 제어를다 중앙(Render class에 render)\n* 그래서 우리가 애니메이션 절차에 대해서 수정하고 싶으면 Render class의 render만 수정하면 된다. \n\n## 핵심3: 제어역전 코드(Renderer class의 render) & 제어역전에 대한 설명\n* Render class의 render쪽에 제어가 몰려 있고 공급되는 View들은 일부만 공급하게 된다 \n* 제어부분이 마음에 아니들면 renderer에서만 계속 고치면된다. 다른 애들은 '제어'에 대한 책임이 해제된다. 그래서 제어에 대한 부속(getElement, initAni, startAni)에만 관심을 갖게 되고 실제 제어는 renderer class의 render가 가져간다. \n* 스프링 프레임워크도 \"제어의역전\"을 사용하고 있다. 큰 프레임워크를 사용할때 사용하는 객체들은 controller들을 모은다. 그리고 web application이 움직이는건 '제어의역전'프레임워크가 해주는것이다. \n    - 제어의 역전의 의미\n    : 누군가 router태워서 필요한 컨트롤에 로딩해서 컨트롤에서 모델받아서 매칭되어 있는 뷰를 뿌려주는 이 과정 \n\n* 프레임워크, 라이브러리 차이 \n    - 프레임워크: 제어 역전이 있다.(IOC가 되어야 프레임워크가되는것이다)\n    - 라이브러리: 제어에 대한 책임 없음\n\n* IOC가 되어야 프레임워크는 받는 뷰를 요구한다.\n    - 나의 lifeCycle, 나의 미리 상속되어 있는 메소드들 일부만 구현에서 나에게 주기만하면 이를 제어해줄게이게 IOC 프레임워크이다. \n* 안드로이드 앱을 만들때 activity를 만들어야 하고 이 activity가 할수 있는 건 os에서 지정해놓은 메소드들만 구현한것이고 언제태어나고, 언제 만들어지고, 언제 앱이 뜨는지는 OS가 한다  \n\n\n# 제어역전 실제 구현\n\n* `전략패턴 & 템플릿 메소드 패턴` < `컴포지트 패턴` < `비지터 패턴` \n    - 오늘쪽으로 갈수록 넓은 범위의 제어 역전을 실현함\n    - 가장 소극전인 제어역전을 구현하고 있는 패턴은?   \n    : `전략패턴 & 템플릿 메소드 패턴` \n        - 전략패턴: 소유를 통한 제어의 역전 \n        - 템플릿메소드패턴: 상속을 통한 제어의 역전\n    - 위 예제 Renderer class는 `비지터 패턴`이다.\n\n## 추상팩토리 메소드 패턴\n* `비지터패턴`(위 예제 Renderer class)은 이미 만들어진 객체의 행위를 제어역전에 참여시킬 수 있지만 참여 할 객체 자체(View class)를 생성할 수 없음. 참여할 객체를 상황에 맞게 생성하고 행위까지 위임하기 위해 `추상팩토리 메소드 패턴`을 사용함.\n* 예를 들어 \n내가 피벗 테이블을 만들때 중간에 그래프, 플러그인이 끼워져 있으면 이것을 중간에 만들면서 셀을 만들고 싶다. 이미 주어져 있는 객체를 메소드 호출해서 만드는게 아니라 중간에 만들면서 끼워 넣고 싶다. 이렇게 만드려면 만들어주는 팩토리가 필요 \n* 그래서 `추상팩토리 메소드 패턴`은 `비지터 패턴`과 결함한다. \n    - 만드는것만 제공하는게 아니라 만들어진 메소드도 호출 가능하다 \n    - 그래서 \b`제어역전`을 구현하게 되면 `추상팩토리 메소드 패턴`을 사용 가능하게 되는 것이다. \n\n\n# 마무리 \n* 이번에 등장한 모든 디자인패턴들은 모두 `제어역전패턴`과 관련된 패턴이다.\n* 객체지향에서 `제어역전`을 궁극적으로 목표로 삼는 이유는 많은 버그를 제어문이 가지고 있어 제어를 한군데에서 하기 위함이다. \n* 앞으로 이어지는 4개의 강의는 샘플앱을 만들고 점진적으로 발전시켜가면서 제어역전, SOLID 역전이 지켜지는지 refactoring하면서 기능을 붙여나갈 예정 ","excerpt":"INTRO 목표: 객체 지향을 자바스크립트로 해보자  객체지향 이론 오늘 배운 이론 남은 4개 강의에서 활용 Value Context, Identifier Context value Context: 함수형 프로그래밍에서 사용 identifier…","fields":{"slug":"/코드스피츠 86 객체지향 자바스크립트- 1회차/"},"frontmatter":{"date":"Feb 01, 2020","title":"코드스피츠-객체지향 1회(객체지향이란?)","tags":["코드스피츠","객제지향 자바스크립트"]}}},{"node":{"rawMarkdownBody":"\n> mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element를 건너뛰는 특징'을 파악하지 못해서 시간을 지체한 경우가 있었는데 이후 검색하다 이유를 알게 되서 정리를 하게 됐다.\n\n\n# mouseover/ mouseout & relatedTarget\n\n* relatedTarget은 null 일수 있다. \n  * window창에서 바로 el로 진입하게 되면 \n\n# element를 건너뛰는 현상\n> 브라우저는 마우스가 움직일때 pixel 단위로 이벤트가 일어나는게 아니라 마우스 포지션을 시간별로 체크한다.  \n그래서 빠르게 움직일때 dom-elements를 건너뛰 수 있다.\n\n* 아래 링크에서 마우스를 빠르게 이동하면서 textArea를 확인해보자 \n  * <https://plnkr.co/edit/S99kMXYRIsDCf4wP4pkD?p=preview>\n  * **브라우저가 마우스 포지션을 시간별로 체크하기 때문에   \n  el의 경계선이 가까울 수록 모든 el에 visit 하지 않는다.**\n  ","excerpt":"mouseover/out 이벤트 일때마다 특정 동작을 구현하려고 했을때 '계층구조 el인 경우에 이벤트가 element…","fields":{"slug":"/Moving-the-mouse(mouseover_mouseout)/"},"frontmatter":{"date":"Jan 24, 2020","title":"mouseover, mouseout일때 element를 건너뛰는 특징","tags":["javascript"]}}},{"node":{"rawMarkdownBody":"\n개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다.\n\n\n```js\n\t1 실행 컨텍스트란? \n\t2 VariableEnvironment\n\t3 LexicalEnvironment\n\t\t3-1 environmentRecord와 hoisting\n            호이스팅 규칙  \n            함수 선언문과 함수 표현식\n      \n\t\t3-2 scope, scope chain, outerEnvironmentReference\n            스코프 체인\n            전역변수와 지역변수\n\n\t4 this\n```\n\n\n# 1 실행 컨텍스트란? \n> * 실행컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  \n> * 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념  \n> * 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어 올리고(=호이스팅), 외부환경정보를 구성, this값을 설정  하는 동작 수행    \n-> 이로인해 다른언어에서는 발견할 수 없는 특이한 현상들이 발생\n\n* 코드 실행시 실행 컨텍스트\n    - '동일한 환경'에 있느 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 \n    - 이를 콜 스택에 쌓아올렸다가\n    - 가장 위에 쌓여있는 컨텍스트와 관련 잇는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장\n\n* '동일한 환경'(하나의 실행 컨텍스트)을 구성할 수 있는 방법\n    - 전역공간, evan()함수, 함수 등이 있음\n    - eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것\n\n* javascript engine 역할\n  - 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 '필요한 환경정보들'을 수집해서 실행 컨텍스트 객체에 저장\n  - 이 객체는 javascript engine이 활용할 목적으로 생성(개발자가 코드를 통해 확인할 수 x)  \n  - 담기는 정보 세가지  \n    : 목차 2, 3, 4에서 각각 더 자세하게 설명하도록 한다. \n  ```txt\n    VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. \n                            : 선언 시점의 LexicalEnvironment의 스냅샷 \n                            : 변경 사항은 반영되지 않음\n    LexicalEnvironment  : 처음에는 VariableEnvironment와 같지만 변경사항이 실시간으로 반영\n    ThisBinding         : this 식별자가 바라봐야 할 객체\n  ```\n\n* 활성화된 실행 컨텍스트의 수집정보\n\n``` \n  * inner \n      Variableenvironment : environmentRecord(snapshot)/ outerEnvironmentReferenece(snapshot)\n      LexicalEnvironment  : environmentRecord/ outerenvironmentReferenece\n      ThisBindding\n  * outer\n  * 전역 컨텍스트\n```\n  \n# 2 VariableEnvironment\n* LexicalEnvironment와 같지만 최초 실행 시의 스탭 샷을 유지한다는점이 다름\n* 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음,  \n  이를 그대로 복사해서 Lexical environment를 만들어  LexicalEnvironment를 주로 활용하게 된다.\n* Variableenvironment, LexicalEnvironment의 내부는 **environmentRecord와 outerEnvironmentReference**로 구성\n  - 초기화 과정 중에는 사실상 완전히 동일, 이후 코드 진행에 따라 서로 달라짐\n  - 자세한 내용은 LexicalEnvironment를 통해 설명\n\n# 3 LexicalEnvironment\n* 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것 \n\n## 3-1 environmentRecord와 hoisting\n* js engine은 컨텍스트 내부 전체를 처음부터 쭉 훑어나가며 순서대로 수집 = \"호이스팅 개념\"  \n(= 식별자들을 최상단으로 끌어올려놓은 다음 실제코드를 실행-실제로 끌어 올리는 것이 아님, 편의상 끌어올린것으로 간주-)\n  - 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태\n  - 코드가 실행되기 전임에도 불구하고 js engine은 이미 해당 환경에 속한 코드의 변수명들으 모두 알고 있게 된다.\n                                                                \n### 호이스팅 규칙\n* environmentRecord에는 매개변수의 이름, 함수선언, 변수명 등이 담긴다\n* 예시\n  * 함수 선언문으로 선언한 함수는 hoisting 대상\n  * 함수 표현식은 hosisting 대상 x\n\n  ```js\n  function a(){\n      console.log(b);   //ƒ b() {}\n      var b; \n      console.log(b);   //ƒ b() {}\n      function b() {};  //함수 선언문\n      console.log(b);   //ƒ b() {}\n\n      console.log(c);   //undefined\n      var c = function() {}\n  }\n  ```\n\n\n\n### 함수 선언문과 함수 표현식\n* 함수를 정의하는 세가지 방식\n  * 함수 선언문: 반드시 함수명이 정의 돼 있어야 함/ hoisiting이 됨\n  * 함수 표현식: 함수명이 없어도 됨           / hoisiting이 안 됨\n  * 기명 함수 표현식: 함수명을 정의한 함수 표현식\n\n```js\nfunction a() {} //함수 선언문\na();\n\n//상대적으로 긴 코드 속에서 함수 표현식이 안전한다.\nvar b = function() {} //(익명) 함수 표현식\nb();\n\nvar c = function d() {} // 기명 함수 표현식. 변수명: c, 함수명 d\nc(); // 실행\nd(); // error\n\n```\n\n## 3-2 scope, scope chain, outerEnvironmentReference\n* scope: 식별자에 대한 유표범위\n  * ES5까지의 자바스크립트는 특이하게도 전역 공간을 제외하면 오직 함수에 의해서만 스코프가 생성\n* scope chain: 이런 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것\n* outerEnvironmentReference: 스코프체인을 가능하게 하는 것이 바로 Lexicalenvironment의 두번째 수집자료인 outerEnvironmentReferenece\n\n### scope chain\n* outerEnvironmentReferenece는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조\n  - 아래 예시1 scopechain 도식화 참고\n* 과거 시점인 '선언될 당시'는 행위가 실제로 일어 날 수 있는 시점이란?  \n  - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐\n  - 모든 코드는 실행 컨텍스트가 활성화 상태일 때 실행되기 때문\n\n* scope chain 예1\n  1. A함수 내부에 B함수 선언, B함수 내에 C함수 선언\n  2. 함수 C의 outerEnvironmentReferenece는 함수 B의 LexicalEnvironment를 참조 \n  3. 함수 B의 LexicalEnvironment에 있는 outerEnvironmentReferenece는 ***다시 함수 B가 선언되던 때*** A함수의 LexicalEnvironment를 참조 \n  4. 이처럼 outerEnvironmentReferenece는 연결리스트 형태를 띤다.\n  5. '선언 시점의 LexicalEnvironment'를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것'  \n\n* 위 예시로본 특징 \n  - 예시 3번에서 본것 처럼 각 outerEnvironmentReferenece는 오직 자신이 선언된 시점의 LexicalEnvironment만 침조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능\n  - 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능** \n\n* scope chain 예1 코드\n```js\n/*01*/ var a = 1;\n/*02*/ var outer = function () {\n/*03*/   var inner = function () {\n/*04*/     console.log(a);\n/*05*/     var a = 3;\n/*06*/  };\n/*07*/   inner();\n/*08*/   console.log(a);\n/*09*/ };\n/*10*/ ouer();\n/*11*/ console.log(a);\n```\n* scope chaing 예1 코드 도식화\n    * 그림을 보면서 라인별로 어떤 동작을 하는지 생각해보자\n    ```\n      LE: Lexical Envinronment\n      e: environmentRecord\n      o: outerEnvironmentReference\n    ```\n    ![](context.jpeg)\n\n\n* **전역 컨텍스트 활성화**\n  * 0: LexicalEnvironment, VariableEnvironment, thisBinding\n\n* 전역 컨텍스트 생성/ outer 함수 호출\n  * 1,2: a에 1, outer에 함수 할당\n  * 10: outer 함수호출, 전역 컨텍스트 비활성화\n  * 2: outer실행 컨텍스트 활성화\n\n* outer 컨텍스트 생성/ inner 함수 호출\n  * 3: inner에 함수 할당\n  * 7: inner 함수 호출, outer 실행 컨텍스트 비활성화\n  * 3: inner 실행 컨텍스트 활성화 \n\n* inner 함수 수행\n  * 4: inner의 LE에서 a 탐색 -> undefined 출력\n  * 5: a에 3할당\n\n* inner 컨텍스트 종료 \n  * 6: inner 함수 종료, inner 실행 컨텍스트 제거\n  * 7: outer 실행 컨텍스트 재활성화\n  * 8: outer의 LE에서 a탐색 -> GLOBAL의 LE에서 a 탐색 -> 1출력\n\n* outer 컨텍스트 종료 \n  * 9: outer함수 종료, outer 실행 컨텍스트 제거 \n  * 10: 전역 컨텍스트 재활성화 \n  * 11: GLOBAL의 LE에서 a탐색 -> 1출력\n\n\n* outer컨텍스트 \n\n```js\n\"전역 컨텍스트\": {\n    environmentRecord: 'a, outer function',\n    outerEnvironmentReferenece: null,\n    this: window\n}\n\n\"outer컨텍스트\": {\n    environmentRecord: ['inner function'], \n    outerEnvironmentReferenece: 'GLOBAL LexicalEnvironment',\n    this: window\n}\n\n\"inner컨텍스트\": {\n    environmentRecord: ['a'], \n    outerEnvironmentReferenece: 'outer 컨텍스트',\n    this: window\n}\n```\n\n### 전역변수와 지역변수\n* 전역변수: 전역 공간에서 선언\n* 지역변수: 함수 내부에서 선언\n\n# 4 this\n* 실행컨텍스트의 thisBinding에 this로 지정된 객체가 저장\n* 실행컨텍스 활성 당시 this가 지정되지 않은경우 \"전역객체\" 저장\n* 함수 호출하는 방법에 따라 this가 달라진다.(this에 대해서만 내용을 다룰 예정)\n\n\n\n# 참고 \n* 코어 자바스크립트 - 위키북스\n* 인사이드 자바스크립트\n* 자바스크립트 완벽 가이드\n* 제로초 블로그\n","excerpt":"개발을 하다보면 this의 범위가 함수, function, bind, call, apply별로 달라지는 걸볼 수 있는데 왜 이런지에 대해서 다뤄보려고 한다. 1 실행 컨텍스트란? 실행컨텍스트(execution context…","fields":{"slug":"/Excute-context/"},"frontmatter":{"date":"Jan 24, 2020","title":"실행 컨텍스트","tags":["javascript Core"]}}},{"node":{"rawMarkdownBody":"\n이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this 바인딩, 상황에 따라 달라지는 this scope, 프로토타입 기반 OOP, 비동기 처리\" 등 지식이 필요했다.\n\n자바스크립트 완벽 가이드 책을 보면서 키워드에 대한 내용을 알고 있었지만, product level의 일을 하려다 보니 알고 있지만 안다고 말할 수 있는 아니었다.\n\n일 년 동안 다음 세 권의 책과(자바스크립트 완벽 가이드, 완벽한 인사이드 자바스크립트, 속 깊은 자바스크립트) 유튜브, 검색을 통해서 배운 내용을 어떻게 정리할까 하던 중 이 책이 쉽게 정리되어 있어 너무 반가웠다.\n\n동문의 도움으로 저자의 오프라인 수업까지 들을 수 있어 연예인 보러 가는 심정으로 다녀왔는데 설명하는 과정에서 나보다도 훨씬 더 많이 고민하면서 썼다는 게 느껴져 멋있었고 떠먹기만 하면 되는 상황에서 감사한 마음이 들었다. 그래서 한편으론 실제로 적용하는 생각 연습과 다른 사람에게 효과적으로 전달 할 수 있는 고민을 하고 싶었다. (그래서 블로그에 자바스크립트 내용을 정리하는 연습을 해보려고 한다. -현재(2020.01 시작) 진행 중-) 그리고 책을 보면서 업무를 하며 익혔던 자바스크립트 내용을 상기하는 과정에서 지난 일 년 동안 달라진 느낌이 들어 기분이 좋았다.\n\n디버깅하다가 call Stack에서 jQuery, react, vue 코드들을 보게 되는데 아는 것들이 나오니 개발할 때 즐거움이 달라지는 것 같다.\njavascript를 더 깊게 알고 싶은 분에게 추천해주고 싶은 책이다.\n\n\n","excerpt":"이직을 하고 나서 vanilla JS로 이뤄진 자체 프론트엔드 프레임워크 안에서 개발을 해야 하는 상황에서 전 SI회사에서 폴리머로 프론트 작업을 할 때 신경 쓰지 않아도 되는 \"클로저, 비동기, scope, 명시적 this…","fields":{"slug":"/코어자바스크립트후기/"},"frontmatter":{"date":"Jan 20, 2020","title":"코어자바스크립트 후기","tags":["javascript","독서후기"]}}},{"node":{"rawMarkdownBody":"\n\n# 요약\n\n```js\n\nconst array = [1, 2, 300, 300, 300];\n\n//1\n[...new Set(array)];\n\n//2\narray.filter((item,index) => array.indexOf(item) === index);\n\n//3\naray.reduce((unique, item) => unique.include(item) ? unique : [...unique, item], []);\n\n```\n\n## 1. Set\n* Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이)\n\n* return value\n  - A new Set object.\n\n* Set Object를 array로 반드는 방법 2가지 \n  - spread opertator\n  - Array.from\n\n```js\nconst array = [1, 2, 300, 300, 300];\n\nconst uniqueSet = new Set(array);\n//Set {1, 2, 300}\n\nconst delDuplArr = [...uniqueSet];\nconst delDuplArr2 = Array.from(uniqueSet);\n//[1, 2, 300]\n```\n\n\n## 2. filter\n* 배열의 indexOf 메소드를 사용해서 반복문을 돌면서 각 요소의 인덱스가 아닌 다른 인덱스를 가르키면 중복된다는 개념을 이용\n* filter의 return 조건을 반대로 하면 중복되는 배열 요소를 반환할 수 있다. \n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.filter((val, idx) => {\n  console.log({ val, idx, indexOf: array.indexOf(val) });\n  return array.indexOf(val) === idx;\n});\n\n/**\n * # console.log({ val, idx, indexOf: array.indexOf(val) });\n *  {val: 1, idx: 0, indexOf: 0}\n *  {val: 2, idx: 1, indexOf: 1}\n *  {val: 300, idx: 2, indexOf: 2}\n *  {val: 300, idx: 3, indexOf: 2}\n *  {val: 300, idx: 4, indexOf: 2}\n * /\n```\n\n\n## 3. reduce\n\n\n```js\nvar array = [1, 2, 300, 300, 300];\narray.reduce((unique, item) => {\n  console.log({ \n    item,\n    unique,\n    'unique.includes(item)': unique.includes(item),\n    'return unique val': unique.includes(item) ? unique: [...unique, item]})\n  return unique.includes(item) ? unique: [...unique, item];\n}, []);\n\n\n/*\n  # console.log \n  => \n  {item: 1,   unique: Array(0), unique.includes(item): false,    return unique val: Array(1)}\n  {item: 2,   unique: Array(1), unique.includes(item): false,    return unique val: Array(2)}\n  {item: 300, unique: Array(2), unique.includes(item): false,    return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n  {item: 300, unique: Array(3), unique.includes(item): **true**, return unique val: Array(3)}\n\n*/\n```","excerpt":"요약 1. Set Set Ojbect는 unique한 값만 저장한다. (primitive values, obejct references 구분 없이) return value A new Set object. Set Object를 array…","fields":{"slug":"/How-to-remove-Array–Duplicates-in-js/"},"frontmatter":{"date":"Jan 20, 2020","title":"ES6로 배열을 제거 할 수 있는 3가지 방법","tags":["javascript","ES6"]}}}]}},"pageContext":{}}}